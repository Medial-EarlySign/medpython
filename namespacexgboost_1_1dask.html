<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medial Code Documentation: xgboost.dask Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Medial Code Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexgboost.html">xgboost</a></li><li class="navelem"><a class="el" href="namespacexgboost_1_1dask.html">dask</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">xgboost.dask Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1CommunicatorContext.html">CommunicatorContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1DaskDeviceQuantileDMatrix.html">DaskDeviceQuantileDMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1DaskPartitionIter.html">DaskPartitionIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1DaskQuantileDMatrix.html">DaskQuantileDMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1DaskScikitLearnBase.html">DaskScikitLearnBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1DaskXGBClassifier.html">DaskXGBClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1DaskXGBRanker.html">DaskXGBRanker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1DaskXGBRegressor.html">DaskXGBRegressor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1DaskXGBRFClassifier.html">DaskXGBRFClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxgboost_1_1dask_1_1DaskXGBRFRegressor.html">DaskXGBRFRegressor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa305eafb4ec435a7657912e46a295e5e" id="r_aa305eafb4ec435a7657912e46a295e5e"><td class="memItemLeft" align="right" valign="top"><a id="aa305eafb4ec435a7657912e46a295e5e" name="aa305eafb4ec435a7657912e46a295e5e"></a>
Dict[str, Union[int, str]]&#160;</td><td class="memItemRight" valign="bottom"><b>_try_start_tracker</b> (int n_workers, List[Union[Optional[str], Optional[Tuple[str, int]]]] addrs)</td></tr>
<tr class="separator:aa305eafb4ec435a7657912e46a295e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70bd390ab7b6986edb55361b62b1f3a" id="r_af70bd390ab7b6986edb55361b62b1f3a"><td class="memItemLeft" align="right" valign="top">Dict[str, Union[int, str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#af70bd390ab7b6986edb55361b62b1f3a">_start_tracker</a> (int n_workers, Optional[str] addr_from_dask, Optional[Tuple[str, int]] addr_from_user)</td></tr>
<tr class="separator:af70bd390ab7b6986edb55361b62b1f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b1bf5a1e375c35471615c4b930c7b" id="r_ad93b1bf5a1e375c35471615c4b930c7b"><td class="memItemLeft" align="right" valign="top"><a id="ad93b1bf5a1e375c35471615c4b930c7b" name="ad93b1bf5a1e375c35471615c4b930c7b"></a>
None&#160;</td><td class="memItemRight" valign="bottom"><b>_assert_dask_support</b> ()</td></tr>
<tr class="separator:ad93b1bf5a1e375c35471615c4b930c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99cce4653bd52c4664ef3d649cef780" id="r_ac99cce4653bd52c4664ef3d649cef780"><td class="memItemLeft" align="right" valign="top">_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#ac99cce4653bd52c4664ef3d649cef780">dconcat</a> (Sequence[_T] value)</td></tr>
<tr class="separator:ac99cce4653bd52c4664ef3d649cef780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b0ae4d970cee1ef2419fbc72b99518" id="r_a65b0ae4d970cee1ef2419fbc72b99518"><td class="memItemLeft" align="right" valign="top">&quot;distributed.Client&quot;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#a65b0ae4d970cee1ef2419fbc72b99518">_xgb_get_client</a> (Optional[&quot;distributed.Client&quot;] client)</td></tr>
<tr class="separator:a65b0ae4d970cee1ef2419fbc72b99518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20a18fc7d22ec673ccaf5c98f6eacdd" id="r_af20a18fc7d22ec673ccaf5c98f6eacdd"><td class="memItemLeft" align="right" valign="top">List[_MapRetT]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#af20a18fc7d22ec673ccaf5c98f6eacdd">map_worker_partitions</a> (Optional[&quot;distributed.Client&quot;] client, Callable[..., _MapRetT] func, *Any refs, Sequence[str] workers)</td></tr>
<tr class="separator:af20a18fc7d22ec673ccaf5c98f6eacdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac4fa3e1b80bbc020460f78eab5c663" id="r_afac4fa3e1b80bbc020460f78eab5c663"><td class="memItemLeft" align="right" valign="top"><a id="afac4fa3e1b80bbc020460f78eab5c663" name="afac4fa3e1b80bbc020460f78eab5c663"></a>
Dict[str, List[Any]]&#160;</td><td class="memItemRight" valign="bottom"><b>_get_worker_parts</b> (_DataParts list_of_parts)</td></tr>
<tr class="separator:afac4fa3e1b80bbc020460f78eab5c663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abc8fb9e6797e069638e554400054fa" id="r_a1abc8fb9e6797e069638e554400054fa"><td class="memItemLeft" align="right" valign="top"><a id="a1abc8fb9e6797e069638e554400054fa" name="a1abc8fb9e6797e069638e554400054fa"></a>
<a class="el" href="classxgboost_1_1core_1_1QuantileDMatrix.html">QuantileDMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_create_quantile_dmatrix</b> (Optional[FeatureNames] feature_names, Optional[Union[Any, List[Any]]] feature_types, Optional[Any] feature_weights, float missing, int nthread, Optional[_DataParts] parts, int max_bin, bool enable_categorical, Optional[<a class="el" href="classxgboost_1_1core_1_1DMatrix.html">DMatrix</a>] ref=None)</td></tr>
<tr class="separator:a1abc8fb9e6797e069638e554400054fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e4ee5170eeec5b41442f40947b4961" id="r_a10e4ee5170eeec5b41442f40947b4961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxgboost_1_1core_1_1DMatrix.html">DMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#a10e4ee5170eeec5b41442f40947b4961">_create_dmatrix</a> (Optional[FeatureNames] feature_names, Optional[Union[Any, List[Any]]] feature_types, Optional[Any] feature_weights, float missing, int nthread, bool enable_categorical, Optional[_DataParts] parts)</td></tr>
<tr class="separator:a10e4ee5170eeec5b41442f40947b4961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f981f0f4ef0dc2a72083178464e1f0d" id="r_a1f981f0f4ef0dc2a72083178464e1f0d"><td class="memItemLeft" align="right" valign="top"><a id="a1f981f0f4ef0dc2a72083178464e1f0d" name="a1f981f0f4ef0dc2a72083178464e1f0d"></a>
<a class="el" href="classxgboost_1_1core_1_1DMatrix.html">DMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_dmatrix_from_list_of_parts</b> (bool is_quantile, **Any kwargs)</td></tr>
<tr class="separator:a1f981f0f4ef0dc2a72083178464e1f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03d0e112c09dc88416bb73613a94ec2" id="r_ae03d0e112c09dc88416bb73613a94ec2"><td class="memItemLeft" align="right" valign="top">Dict[str, Union[str, int]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#ae03d0e112c09dc88416bb73613a94ec2">_get_rabit_args</a> (int n_workers, Optional[Dict[str, Any]] dconfig, &quot;distributed.Client&quot; client)</td></tr>
<tr class="separator:ae03d0e112c09dc88416bb73613a94ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b633646838af3451625aa256cadbec" id="r_ab1b633646838af3451625aa256cadbec"><td class="memItemLeft" align="right" valign="top"><a id="ab1b633646838af3451625aa256cadbec" name="ab1b633646838af3451625aa256cadbec"></a>
Optional[Dict[str, Any]]&#160;</td><td class="memItemRight" valign="bottom"><b>_get_dask_config</b> ()</td></tr>
<tr class="separator:ab1b633646838af3451625aa256cadbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91eec9c0ca4f821eae93fe4d44f782c" id="r_aa91eec9c0ca4f821eae93fe4d44f782c"><td class="memItemLeft" align="right" valign="top"><a id="aa91eec9c0ca4f821eae93fe4d44f782c" name="aa91eec9c0ca4f821eae93fe4d44f782c"></a>
List[str]&#160;</td><td class="memItemRight" valign="bottom"><b>_get_workers_from_data</b> (<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a> dtrain, Optional[Sequence[Tuple[<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>, str]]] evals)</td></tr>
<tr class="separator:aa91eec9c0ca4f821eae93fe4d44f782c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1804a5397f570aa8770ab8fe77155929" id="r_a1804a5397f570aa8770ab8fe77155929"><td class="memItemLeft" align="right" valign="top"><a id="a1804a5397f570aa8770ab8fe77155929" name="a1804a5397f570aa8770ab8fe77155929"></a>
Optional[TrainReturnT]&#160;</td><td class="memItemRight" valign="bottom"><b>_filter_empty</b> (<a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a> booster, TrainingCallback.EvalsLog local_history, bool is_valid)</td></tr>
<tr class="separator:a1804a5397f570aa8770ab8fe77155929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21d9b67dc2440d9834558feb45dcc87" id="r_aa21d9b67dc2440d9834558feb45dcc87"><td class="memItemLeft" align="right" valign="top"><a id="aa21d9b67dc2440d9834558feb45dcc87" name="aa21d9b67dc2440d9834558feb45dcc87"></a>
None&#160;</td><td class="memItemRight" valign="bottom"><b>_check_workers_are_alive</b> (List[str] workers, &quot;distributed.Client&quot; client)</td></tr>
<tr class="separator:aa21d9b67dc2440d9834558feb45dcc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08384b2b0370046b03d7860883e12fe5" id="r_a08384b2b0370046b03d7860883e12fe5"><td class="memItemLeft" align="right" valign="top"><a id="a08384b2b0370046b03d7860883e12fe5" name="a08384b2b0370046b03d7860883e12fe5"></a>
Optional[TrainReturnT]&#160;</td><td class="memItemRight" valign="bottom"><b>_train_async</b> (&quot;distributed.Client&quot; client, Dict[str, Any] global_config, Optional[Dict[str, Any]] dconfig, Dict[str, Any] params, <a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a> dtrain, int num_boost_round, Optional[Sequence[Tuple[<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>, str]]] evals, Optional[Objective] obj, Optional[Metric] feval, Optional[int] early_stopping_rounds, Union[int, bool] verbose_eval, Optional[<a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>] xgb_model, Optional[Sequence[<a class="el" href="classxgboost_1_1callback_1_1TrainingCallback.html">TrainingCallback</a>]] callbacks, Optional[Metric] custom_metric)</td></tr>
<tr class="separator:a08384b2b0370046b03d7860883e12fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc820624aac70e2f3a2f2e031906b00" id="r_a3dc820624aac70e2f3a2f2e031906b00"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#a3dc820624aac70e2f3a2f2e031906b00">train</a> (&quot;distributed.Client&quot; client, Dict[str, Any] params, <a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a> dtrain, int num_boost_round=10, *Optional[Sequence[Tuple[<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>, str]]] evals=None, Optional[Objective] obj=None, Optional[Metric] feval=None, Optional[int] early_stopping_rounds=None, Optional[<a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>] xgb_model=None, Union[int, bool] verbose_eval=True, Optional[Sequence[<a class="el" href="classxgboost_1_1callback_1_1TrainingCallback.html">TrainingCallback</a>]] callbacks=None, Optional[Metric] custom_metric=None)</td></tr>
<tr class="separator:a3dc820624aac70e2f3a2f2e031906b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e16c59e5b42346c01c4268ae862ff44" id="r_a4e16c59e5b42346c01c4268ae862ff44"><td class="memItemLeft" align="right" valign="top"><a id="a4e16c59e5b42346c01c4268ae862ff44" name="a4e16c59e5b42346c01c4268ae862ff44"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_can_output_df</b> (bool is_df, Tuple output_shape)</td></tr>
<tr class="separator:a4e16c59e5b42346c01c4268ae862ff44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc166b13e8b70701345f343e91c38948" id="r_acc166b13e8b70701345f343e91c38948"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#acc166b13e8b70701345f343e91c38948">_maybe_dataframe</a> (Any data, Any prediction, List[int] columns, bool is_df)</td></tr>
<tr class="separator:acc166b13e8b70701345f343e91c38948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa278683c3a390b73dc65fa21fce612" id="r_acfa278683c3a390b73dc65fa21fce612"><td class="memItemLeft" align="right" valign="top"><a id="acfa278683c3a390b73dc65fa21fce612" name="acfa278683c3a390b73dc65fa21fce612"></a>
_DaskCollection&#160;</td><td class="memItemRight" valign="bottom"><b>_direct_predict_impl</b> (Callable mapped_predict, &quot;distributed.Future&quot; booster, _DataT data, Optional[_DaskCollection] base_margin, Tuple[int,...] output_shape, Dict[int, str] meta)</td></tr>
<tr class="separator:acfa278683c3a390b73dc65fa21fce612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041d85efdb027a93d772a3ee8de12a69" id="r_a041d85efdb027a93d772a3ee8de12a69"><td class="memItemLeft" align="right" valign="top">Tuple[Tuple[int,...], Dict[int, str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#a041d85efdb027a93d772a3ee8de12a69">_infer_predict_output</a> (<a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a> booster, int features, bool is_df, bool inplace, **Any kwargs)</td></tr>
<tr class="separator:a041d85efdb027a93d772a3ee8de12a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf4995e29f94a6459b1110dc35cba7a" id="r_a4bf4995e29f94a6459b1110dc35cba7a"><td class="memItemLeft" align="right" valign="top"><a id="a4bf4995e29f94a6459b1110dc35cba7a" name="a4bf4995e29f94a6459b1110dc35cba7a"></a>
&quot;distributed.Future&quot;&#160;</td><td class="memItemRight" valign="bottom"><b>_get_model_future</b> (&quot;distributed.Client&quot; client, Union[<a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>, Dict, &quot;distributed.Future&quot;] model)</td></tr>
<tr class="separator:a4bf4995e29f94a6459b1110dc35cba7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efa41888f50e22874e033cd13237164" id="r_a1efa41888f50e22874e033cd13237164"><td class="memItemLeft" align="right" valign="top"><a id="a1efa41888f50e22874e033cd13237164" name="a1efa41888f50e22874e033cd13237164"></a>
_DaskCollection&#160;</td><td class="memItemRight" valign="bottom"><b>_predict_async</b> (&quot;distributed.Client&quot; client, Dict[str, Any] global_config, Union[<a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>, Dict, &quot;distributed.Future&quot;] model, _DataT data, bool output_margin, float missing, bool pred_leaf, bool pred_contribs, bool approx_contribs, bool pred_interactions, bool validate_features, Tuple[int, int] iteration_range, bool strict_shape)</td></tr>
<tr class="separator:a1efa41888f50e22874e033cd13237164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c4329a74b642c4adacc342604c41b3" id="r_a68c4329a74b642c4adacc342604c41b3"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#a68c4329a74b642c4adacc342604c41b3">predict</a> (Optional[&quot;distributed.Client&quot;] client, Union[TrainReturnT, <a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>, &quot;distributed.Future&quot;] model, Union[<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>, _DataT] data, bool output_margin=False, float missing=numpy.nan, bool pred_leaf=False, bool pred_contribs=False, bool approx_contribs=False, bool pred_interactions=False, bool validate_features=True, Tuple[int, int] iteration_range=(0, 0), bool strict_shape=False)</td></tr>
<tr class="separator:a68c4329a74b642c4adacc342604c41b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb00135443338c87ae0a4cf1efb42969" id="r_aeb00135443338c87ae0a4cf1efb42969"><td class="memItemLeft" align="right" valign="top"><a id="aeb00135443338c87ae0a4cf1efb42969" name="aeb00135443338c87ae0a4cf1efb42969"></a>
_DaskCollection&#160;</td><td class="memItemRight" valign="bottom"><b>_inplace_predict_async</b> (&quot;distributed.Client&quot; client, Dict[str, Any] global_config, Union[<a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>, Dict, &quot;distributed.Future&quot;] model, _DataT data, Tuple[int, int] iteration_range, str predict_type, float missing, bool validate_features, Optional[_DaskCollection] base_margin, bool strict_shape)</td></tr>
<tr class="separator:aeb00135443338c87ae0a4cf1efb42969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9069cc8661225e06b5b8e01b398b3149" id="r_a9069cc8661225e06b5b8e01b398b3149"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#a9069cc8661225e06b5b8e01b398b3149">inplace_predict</a> (Optional[&quot;distributed.Client&quot;] client, Union[TrainReturnT, <a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>, &quot;distributed.Future&quot;] model, _DataT data, Tuple[int, int] iteration_range=(0, 0), str predict_type=&quot;value&quot;, float missing=numpy.nan, bool validate_features=True, Optional[_DaskCollection] base_margin=None, bool strict_shape=False)</td></tr>
<tr class="separator:a9069cc8661225e06b5b8e01b398b3149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939de322773b674e702ee6b98080b5b4" id="r_a939de322773b674e702ee6b98080b5b4"><td class="memItemLeft" align="right" valign="top">Tuple[<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>, Optional[List[Tuple[<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>, str]]]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#a939de322773b674e702ee6b98080b5b4">_async_wrap_evaluation_matrices</a> (Optional[&quot;distributed.Client&quot;] client, Optional[str] tree_method, Optional[int] max_bin, **Any kwargs)</td></tr>
<tr class="separator:a939de322773b674e702ee6b98080b5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeedc37a62f24cced9a6b8407cc1ae4a" id="r_aaeedc37a62f24cced9a6b8407cc1ae4a"><td class="memItemLeft" align="right" valign="top">Generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#aaeedc37a62f24cced9a6b8407cc1ae4a">_set_worker_client</a> (&quot;DaskScikitLearnBase&quot; model, &quot;distributed.Client&quot; client)</td></tr>
<tr class="separator:aaeedc37a62f24cced9a6b8407cc1ae4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae56d04267dc351cd58f0b21103d5e747" id="r_ae56d04267dc351cd58f0b21103d5e747"><td class="memItemLeft" align="right" valign="top"><a id="ae56d04267dc351cd58f0b21103d5e747" name="ae56d04267dc351cd58f0b21103d5e747"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dd</b> = <a class="el" href="classxgboost_1_1compat_1_1LazyLoader.html">LazyLoader</a>(&quot;dd&quot;, globals(), &quot;dask.dataframe&quot;)</td></tr>
<tr class="separator:ae56d04267dc351cd58f0b21103d5e747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1cca83f400e340cbe5791f198b9f16" id="r_aea1cca83f400e340cbe5791f198b9f16"><td class="memItemLeft" align="right" valign="top"><a id="aea1cca83f400e340cbe5791f198b9f16" name="aea1cca83f400e340cbe5791f198b9f16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>da</b> = <a class="el" href="classxgboost_1_1compat_1_1LazyLoader.html">LazyLoader</a>(&quot;da&quot;, globals(), &quot;dask.array&quot;)</td></tr>
<tr class="separator:aea1cca83f400e340cbe5791f198b9f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23389104977f669f5239af438214782" id="r_aa23389104977f669f5239af438214782"><td class="memItemLeft" align="right" valign="top"><a id="aa23389104977f669f5239af438214782" name="aa23389104977f669f5239af438214782"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dask</b> = <a class="el" href="classxgboost_1_1compat_1_1LazyLoader.html">LazyLoader</a>(&quot;dask&quot;, globals(), &quot;dask&quot;)</td></tr>
<tr class="separator:aa23389104977f669f5239af438214782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0f19b3418ad65dad0a390398ff296a" id="r_a9a0f19b3418ad65dad0a390398ff296a"><td class="memItemLeft" align="right" valign="top"><a id="a9a0f19b3418ad65dad0a390398ff296a" name="a9a0f19b3418ad65dad0a390398ff296a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>distributed</b> = <a class="el" href="classxgboost_1_1compat_1_1LazyLoader.html">LazyLoader</a>(&quot;distributed&quot;, globals(), &quot;dask.distributed&quot;)</td></tr>
<tr class="separator:a9a0f19b3418ad65dad0a390398ff296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257d038287ac487bd269601ad78a2f39" id="r_a257d038287ac487bd269601ad78a2f39"><td class="memItemLeft" align="right" valign="top"><a id="a257d038287ac487bd269601ad78a2f39" name="a257d038287ac487bd269601ad78a2f39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_DaskCollection</b> = Union[&quot;da.Array&quot;, &quot;dd.DataFrame&quot;, &quot;dd.Series&quot;]</td></tr>
<tr class="separator:a257d038287ac487bd269601ad78a2f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5453c23b326f6d703a30a91b42b7b686" id="r_a5453c23b326f6d703a30a91b42b7b686"><td class="memItemLeft" align="right" valign="top"><a id="a5453c23b326f6d703a30a91b42b7b686" name="a5453c23b326f6d703a30a91b42b7b686"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_DataT</b> = Union[&quot;da.Array&quot;, &quot;dd.DataFrame&quot;]</td></tr>
<tr class="separator:a5453c23b326f6d703a30a91b42b7b686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22cbdb94b4aab09d30a2847875dfe8d" id="r_aa22cbdb94b4aab09d30a2847875dfe8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexgboost_1_1dask.html#aa22cbdb94b4aab09d30a2847875dfe8d">TrainReturnT</a></td></tr>
<tr class="separator:aa22cbdb94b4aab09d30a2847875dfe8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea38ce9ca4a60ccc88e87518750a06d3" id="r_aea38ce9ca4a60ccc88e87518750a06d3"><td class="memItemLeft" align="right" valign="top"><a id="aea38ce9ca4a60ccc88e87518750a06d3" name="aea38ce9ca4a60ccc88e87518750a06d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LOGGER</b> = logging.getLogger(&quot;[xgboost.dask]&quot;)</td></tr>
<tr class="separator:aea38ce9ca4a60ccc88e87518750a06d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34577c4ebf3fe8b048862c768d59237f" id="r_a34577c4ebf3fe8b048862c768d59237f"><td class="memItemLeft" align="right" valign="top"><a id="a34577c4ebf3fe8b048862c768d59237f" name="a34577c4ebf3fe8b048862c768d59237f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_MapRetT</b> = TypeVar(&quot;_MapRetT&quot;)</td></tr>
<tr class="separator:a34577c4ebf3fe8b048862c768d59237f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c8ebd0400b85b259b0ba4218d33573" id="r_ad0c8ebd0400b85b259b0ba4218d33573"><td class="memItemLeft" align="right" valign="top"><a id="ad0c8ebd0400b85b259b0ba4218d33573" name="ad0c8ebd0400b85b259b0ba4218d33573"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_DataParts</b> = List[Dict[str, Any]]</td></tr>
<tr class="separator:ad0c8ebd0400b85b259b0ba4218d33573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Dask extensions for distributed training
----------------------------------------

See :doc:`Distributed XGBoost with Dask &lt;/tutorials/dask&gt;` for simple tutorial.  Also
:doc:`/python/dask-examples/index` for some examples.

There are two sets of APIs in this module, one is the functional API including
``train`` and ``predict`` methods.  Another is stateful Scikit-Learner wrapper
inherited from single-node Scikit-Learn interface.

The implementation is heavily influenced by dask_xgboost:
https://github.com/dask/dask-xgboost

Optional dask configuration
===========================

- **xgboost.scheduler_address**: Specify the scheduler address, see :ref:`tracker-ip`.

  .. versionadded:: 1.6.0

  .. code-block:: python

      dask.config.set({"xgboost.scheduler_address": "192.0.0.100"})
      # We can also specify the port.
      dask.config.set({"xgboost.scheduler_address": "192.0.0.100:12345"})</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a939de322773b674e702ee6b98080b5b4" name="a939de322773b674e702ee6b98080b5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939de322773b674e702ee6b98080b5b4">&#9670;&#160;</a></span>_async_wrap_evaluation_matrices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>, Optional[List[Tuple[<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>, str]]]] xgboost.dask._async_wrap_evaluation_matrices </td>
          <td>(</td>
          <td class="paramtype">Optional[&quot;distributed.Client&quot;]&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str]&#160;</td>
          <td class="paramname"><em>tree_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[int]&#160;</td>
          <td class="paramname"><em>max_bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A switch function for async environment.</pre> 
</div>
</div>
<a id="a10e4ee5170eeec5b41442f40947b4961" name="a10e4ee5170eeec5b41442f40947b4961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e4ee5170eeec5b41442f40947b4961">&#9670;&#160;</a></span>_create_dmatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classxgboost_1_1core_1_1DMatrix.html">DMatrix</a> xgboost.dask._create_dmatrix </td>
          <td>(</td>
          <td class="paramtype">Optional[FeatureNames]&#160;</td>
          <td class="paramname"><em>feature_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Union[Any, List[Any]]]&#160;</td>
          <td class="paramname"><em>feature_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any]&#160;</td>
          <td class="paramname"><em>feature_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>missing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_categorical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_DataParts]&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get data that local to worker from DaskDMatrix.

Returns
-------
A DMatrix object.</pre> 
</div>
</div>
<a id="ae03d0e112c09dc88416bb73613a94ec2" name="ae03d0e112c09dc88416bb73613a94ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03d0e112c09dc88416bb73613a94ec2">&#9670;&#160;</a></span>_get_rabit_args()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, Union[str, int]] xgboost.dask._get_rabit_args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_workers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Dict[str, Any]]&#160;</td>
          <td class="paramname"><em>dconfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;distributed.Client&quot;
&#160;</td>
          <td class="paramname"><em>client</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get rabit context arguments from data distribution in DaskDMatrix.</pre> 
</div>
</div>
<a id="a041d85efdb027a93d772a3ee8de12a69" name="a041d85efdb027a93d772a3ee8de12a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041d85efdb027a93d772a3ee8de12a69">&#9670;&#160;</a></span>_infer_predict_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[Tuple[int, ...], Dict[int, str]] xgboost.dask._infer_predict_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>&#160;</td>
          <td class="paramname"><em>booster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Create a dummy test sample to infer output shape for prediction.</pre> 
</div>
</div>
<a id="acc166b13e8b70701345f343e91c38948" name="acc166b13e8b70701345f343e91c38948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc166b13e8b70701345f343e91c38948">&#9670;&#160;</a></span>_maybe_dataframe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Any xgboost.dask._maybe_dataframe </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>prediction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List[int]&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
&#160;</td>
          <td class="paramname"><em>is_df</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return dataframe for prediction when applicable.</pre> 
</div>
</div>
<a id="aaeedc37a62f24cced9a6b8407cc1ae4a" name="aaeedc37a62f24cced9a6b8407cc1ae4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeedc37a62f24cced9a6b8407cc1ae4a">&#9670;&#160;</a></span>_set_worker_client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Generator xgboost.dask._set_worker_client </td>
          <td>(</td>
          <td class="paramtype">&quot;DaskScikitLearnBase&quot;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;distributed.Client&quot;
&#160;</td>
          <td class="paramname"><em>client</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Temporarily set the client for sklearn model.</pre> 
</div>
</div>
<a id="af70bd390ab7b6986edb55361b62b1f3a" name="af70bd390ab7b6986edb55361b62b1f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70bd390ab7b6986edb55361b62b1f3a">&#9670;&#160;</a></span>_start_tracker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, Union[int, str]] xgboost.dask._start_tracker </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_workers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str]&#160;</td>
          <td class="paramname"><em>addr_from_dask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Tuple[str, int]]&#160;</td>
          <td class="paramname"><em>addr_from_user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Start Rabit tracker, recurse to try different addresses.</pre> 
</div>
</div>
<a id="a65b0ae4d970cee1ef2419fbc72b99518" name="a65b0ae4d970cee1ef2419fbc72b99518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b0ae4d970cee1ef2419fbc72b99518">&#9670;&#160;</a></span>_xgb_get_client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> &quot;distributed.Client&quot; xgboost.dask._xgb_get_client </td>
          <td>(</td>
          <td class="paramtype">Optional[&quot;distributed.Client&quot;]&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Simple wrapper around testing None.</pre> 
</div>
</div>
<a id="ac99cce4653bd52c4664ef3d649cef780" name="ac99cce4653bd52c4664ef3d649cef780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99cce4653bd52c4664ef3d649cef780">&#9670;&#160;</a></span>dconcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> _T xgboost.dask.dconcat </td>
          <td>(</td>
          <td class="paramtype">Sequence[_T]&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Concatenate sequence of partitions.</pre> 
</div>
</div>
<a id="a9069cc8661225e06b5b8e01b398b3149" name="a9069cc8661225e06b5b8e01b398b3149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9069cc8661225e06b5b8e01b398b3149">&#9670;&#160;</a></span>inplace_predict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any xgboost.dask.inplace_predict </td>
          <td>(</td>
          <td class="paramtype">Optional[&quot;distributed.Client&quot;]&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[TrainReturnT, <a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>, &quot;distributed.Future&quot;]&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_DataT&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple[int, int] &#160;</td>
          <td class="paramname"><em>iteration_range</em> = <code>(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>predict_type</em> = <code>&quot;value&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &#160;</td>
          <td class="paramname"><em>missing</em> = <code>numpy.nan</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>validate_features</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_DaskCollection] &#160;</td>
          <td class="paramname"><em>base_margin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>strict_shape</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Inplace prediction. See doc in :py:meth:`xgboost.Booster.inplace_predict` for
details.

.. versionadded:: 1.1.0

Parameters
----------
client:
    Specify the dask client used for training.  Use default client
    returned from dask if it's set to None.
model:
    See :py:func:`xgboost.dask.predict` for details.
data :
    dask collection.
iteration_range:
    See :py:meth:`xgboost.Booster.predict` for details.
predict_type:
    See :py:meth:`xgboost.Booster.inplace_predict` for details.
missing:
    Value in the input data which needs to be present as a missing
    value. If None, defaults to np.nan.
base_margin:
    See :py:obj:`xgboost.DMatrix` for details.

    .. versionadded:: 1.4.0

strict_shape:
    See :py:meth:`xgboost.Booster.predict` for details.

    .. versionadded:: 1.4.0

Returns
-------
prediction :
    When input data is ``dask.array.Array``, the return value is an array, when
    input data is ``dask.dataframe.DataFrame``, return value can be
    ``dask.dataframe.Series``, ``dask.dataframe.DataFrame``, depending on the output
    shape.</pre> 
</div>
</div>
<a id="af20a18fc7d22ec673ccaf5c98f6eacdd" name="af20a18fc7d22ec673ccaf5c98f6eacdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20a18fc7d22ec673ccaf5c98f6eacdd">&#9670;&#160;</a></span>map_worker_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[_MapRetT] xgboost.dask.map_worker_partitions </td>
          <td>(</td>
          <td class="paramtype">Optional[&quot;distributed.Client&quot;]&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., _MapRetT]&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Any&#160;</td>
          <td class="paramname"><em>refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[str]&#160;</td>
          <td class="paramname"><em>workers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Map a function onto partitions of each worker.</pre> 
</div>
</div>
<a id="a68c4329a74b642c4adacc342604c41b3" name="a68c4329a74b642c4adacc342604c41b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c4329a74b642c4adacc342604c41b3">&#9670;&#160;</a></span>predict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any xgboost.dask.predict </td>
          <td>(</td>
          <td class="paramtype">Optional[&quot;distributed.Client&quot;]&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[TrainReturnT, <a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>, &quot;distributed.Future&quot;]&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>, _DataT]&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>output_margin</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &#160;</td>
          <td class="paramname"><em>missing</em> = <code>numpy.nan</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>pred_leaf</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>pred_contribs</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>approx_contribs</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>pred_interactions</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>validate_features</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple[int, int] &#160;</td>
          <td class="paramname"><em>iteration_range</em> = <code>(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>strict_shape</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Run prediction with a trained booster.

.. note::

    Using ``inplace_predict`` might be faster when some features are not needed.
    See :py:meth:`xgboost.Booster.predict` for details on various parameters.  When
    output has more than 2 dimensions (shap value, leaf with strict_shape), input
    should be ``da.Array`` or ``DaskDMatrix``.

.. versionadded:: 1.0.0

Parameters
----------
client:
    Specify the dask client used for training.  Use default client
    returned from dask if it's set to None.
model:
    The trained model.  It can be a distributed.Future so user can
    pre-scatter it onto all workers.
data:
    Input data used for prediction.  When input is a dataframe object,
    prediction output is a series.
missing:
    Used when input data is not DaskDMatrix.  Specify the value
    considered as missing.

Returns
-------
prediction: dask.array.Array/dask.dataframe.Series
    When input data is ``dask.array.Array`` or ``DaskDMatrix``, the return value is
    an array, when input data is ``dask.dataframe.DataFrame``, return value can be
    ``dask.dataframe.Series``, ``dask.dataframe.DataFrame``, depending on the output
    shape.</pre> 
</div>
</div>
<a id="a3dc820624aac70e2f3a2f2e031906b00" name="a3dc820624aac70e2f3a2f2e031906b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc820624aac70e2f3a2f2e031906b00">&#9670;&#160;</a></span>train()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any xgboost.dask.train </td>
          <td>(</td>
          <td class="paramtype">&quot;distributed.Client&quot;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any]&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>&#160;</td>
          <td class="paramname"><em>dtrain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>num_boost_round</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[Sequence[Tuple[<a class="el" href="classxgboost_1_1dask_1_1DaskDMatrix.html">DaskDMatrix</a>, str]]] &#160;</td>
          <td class="paramname"><em>evals</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Objective] &#160;</td>
          <td class="paramname"><em>obj</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Metric] &#160;</td>
          <td class="paramname"><em>feval</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[int] &#160;</td>
          <td class="paramname"><em>early_stopping_rounds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classxgboost_1_1core_1_1Booster.html">Booster</a>] &#160;</td>
          <td class="paramname"><em>xgb_model</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[int, bool] &#160;</td>
          <td class="paramname"><em>verbose_eval</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Sequence[<a class="el" href="classxgboost_1_1callback_1_1TrainingCallback.html">TrainingCallback</a>]] &#160;</td>
          <td class="paramname"><em>callbacks</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Metric] &#160;</td>
          <td class="paramname"><em>custom_metric</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Train XGBoost model.

.. versionadded:: 1.0.0

.. note::

    Other parameters are the same as :py:func:`xgboost.train` except for
    `evals_result`, which is returned as part of function return value instead of
    argument.

Parameters
----------
client :
    Specify the dask client used for training.  Use default client returned from
    dask if it's set to None.

Returns
-------
results: dict
    A dictionary containing trained booster and evaluation history.  `history` field
    is the same as `eval_result` from `xgboost.train`.

    .. code-block:: python

        {'booster': xgboost.Booster,
         'history': {'train': {'logloss': ['0.48253', '0.35953']},
                     'eval': {'logloss': ['0.480385', '0.357756']}}}</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa22cbdb94b4aab09d30a2847875dfe8d" name="aa22cbdb94b4aab09d30a2847875dfe8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22cbdb94b4aab09d30a2847875dfe8d">&#9670;&#160;</a></span>TrainReturnT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xgboost.dask.TrainReturnT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  TypedDict(</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;TrainReturnT&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>    {</div>
<div class="line"><span class="lineno">    4</span>        <span class="stringliteral">&quot;booster&quot;</span>: Booster,</div>
<div class="line"><span class="lineno">    5</span>        <span class="stringliteral">&quot;history&quot;</span>: Dict,</div>
<div class="line"><span class="lineno">    6</span>    },</div>
<div class="line"><span class="lineno">    7</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 10 2025 06:12:42 for Medial Code Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
