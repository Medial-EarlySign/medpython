<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medial Code Documentation: dmlc::InputSplit Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Medial Code Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedmlc.html">dmlc</a></li><li class="navelem"><a class="el" href="classdmlc_1_1InputSplit.html">InputSplit</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">dmlc::InputSplit Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>input split creates that allows reading of records from split of data, independent part that covers all the dataset  
 <a href="classdmlc_1_1InputSplit.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dmlc-core_2include_2dmlc_2io_8h_source.html">io.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for dmlc::InputSplit:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classdmlc_1_1InputSplit.png" usemap="#dmlc::InputSplit_map" alt=""/>
  <map id="dmlc::InputSplit_map" name="dmlc::InputSplit_map">
<area href="classdmlc_1_1InputSplitShuffle.html" title="class to construct input split with global shuffling" alt="dmlc::InputSplitShuffle" shape="rect" coords="0,56,200,80"/>
<area href="classdmlc_1_1io_1_1InputSplitBase.html" title="class to construct input split from multiple files" alt="dmlc::io::InputSplitBase" shape="rect" coords="210,56,410,80"/>
<area href="classdmlc_1_1io_1_1SingleFileSplit.html" title="line split implementation from single FILE simply returns lines of files, used for stdin" alt="dmlc::io::SingleFileSplit" shape="rect" coords="420,56,620,80"/>
<area href="classdmlc_1_1io_1_1SingleThreadedInputSplit.html" title="provides a single threaded input split Useful for debugging purposes. Be cautious of use for producti..." alt="dmlc::io::SingleThreadedInputSplit" shape="rect" coords="630,56,830,80"/>
<area href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html" title="class that splits the recordIO file by record" alt="dmlc::io::IndexedRecordIOSplitter" shape="rect" coords="0,112,200,136"/>
<area href="classdmlc_1_1io_1_1LineSplitter.html" title="class that split the files by line" alt="dmlc::io::LineSplitter" shape="rect" coords="210,112,410,136"/>
<area href="classdmlc_1_1io_1_1RecordIOSplitter.html" title="class that split the files by line" alt="dmlc::io::RecordIOSplitter" shape="rect" coords="420,112,620,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a blob of memory region  <a href="structdmlc_1_1InputSplit_1_1Blob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af73e8f2ba0ccbf17326d8d5ff1cfd96e" id="r_af73e8f2ba0ccbf17326d8d5ff1cfd96e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#af73e8f2ba0ccbf17326d8d5ff1cfd96e">HintChunkSize</a> (size_t)</td></tr>
<tr class="memdesc:af73e8f2ba0ccbf17326d8d5ff1cfd96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">hint the inputsplit how large the chunk size it should return when implementing NextChunk this is a hint so may not be enforced, but <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> will try adjust its internal buffer size to the hinted value  <br /></td></tr>
<tr class="separator:af73e8f2ba0ccbf17326d8d5ff1cfd96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fb3e0f9acd6bae599a398eb0758044" id="r_af2fb3e0f9acd6bae599a398eb0758044"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#af2fb3e0f9acd6bae599a398eb0758044">GetTotalSize</a> (void)=0</td></tr>
<tr class="memdesc:af2fb3e0f9acd6bae599a398eb0758044"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the total size of the <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a>  <br /></td></tr>
<tr class="separator:af2fb3e0f9acd6bae599a398eb0758044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f111755a3434097bdd2a765982180a7" id="r_a2f111755a3434097bdd2a765982180a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#a2f111755a3434097bdd2a765982180a7">BeforeFirst</a> (void)=0</td></tr>
<tr class="memdesc:a2f111755a3434097bdd2a765982180a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the position of <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> to beginning  <br /></td></tr>
<tr class="separator:a2f111755a3434097bdd2a765982180a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f124b34e62d9319dca39fa42e5a59f7" id="r_a0f124b34e62d9319dca39fa42e5a59f7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#a0f124b34e62d9319dca39fa42e5a59f7">NextRecord</a> (<a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *out_rec)=0</td></tr>
<tr class="memdesc:a0f124b34e62d9319dca39fa42e5a59f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the next record, the returning value is valid until next call to NextRecord, NextChunk or NextBatch caller can modify the memory content of out_rec  <br /></td></tr>
<tr class="separator:a0f124b34e62d9319dca39fa42e5a59f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e835c07ce77d8d873592e006c242156" id="r_a2e835c07ce77d8d873592e006c242156"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#a2e835c07ce77d8d873592e006c242156">NextChunk</a> (<a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *out_chunk)=0</td></tr>
<tr class="memdesc:a2e835c07ce77d8d873592e006c242156"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a chunk of memory that can contain multiple records, the caller needs to parse the content of the resulting chunk, for text file, out_chunk can contain data of multiple lines for recordio, out_chunk can contain multiple records(including headers)  <br /></td></tr>
<tr class="separator:a2e835c07ce77d8d873592e006c242156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b7c78fed8312c221d9999f73fe615b" id="r_ac7b7c78fed8312c221d9999f73fe615b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#ac7b7c78fed8312c221d9999f73fe615b">NextBatch</a> (<a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *out_chunk, size_t)</td></tr>
<tr class="memdesc:ac7b7c78fed8312c221d9999f73fe615b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a chunk of memory that can contain multiple records, with hint for how many records is needed, the caller needs to parse the content of the resulting chunk, for text file, out_chunk can contain data of multiple lines for recordio, out_chunk can contain multiple records(including headers)  <br /></td></tr>
<tr class="separator:ac7b7c78fed8312c221d9999f73fe615b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a1f234a44de0950d1011495f41b265" id="r_a00a1f234a44de0950d1011495f41b265"><td class="memItemLeft" align="right" valign="top"><a id="a00a1f234a44de0950d1011495f41b265" name="a00a1f234a44de0950d1011495f41b265"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~InputSplit</b> (void) DMLC_THROW_EXCEPTION</td></tr>
<tr class="memdesc:a00a1f234a44de0950d1011495f41b265"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a00a1f234a44de0950d1011495f41b265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa17b8be6b3f1da35ced68379e3e8dbe" id="r_aaa17b8be6b3f1da35ced68379e3e8dbe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#aaa17b8be6b3f1da35ced68379e3e8dbe">ResetPartition</a> (unsigned part_index, unsigned num_parts)=0</td></tr>
<tr class="memdesc:aaa17b8be6b3f1da35ced68379e3e8dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the Input split to a certain part id, The <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> will be pointed to the head of the new specified segment. This feature may not be supported by every implementation of <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a>.  <br /></td></tr>
<tr class="separator:aaa17b8be6b3f1da35ced68379e3e8dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5ff5b80044f8b418f960fdedba2906c7" id="r_a5ff5b80044f8b418f960fdedba2906c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdmlc_1_1InputSplit.html">InputSplit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#a5ff5b80044f8b418f960fdedba2906c7">Create</a> (const char *uri, unsigned part_index, unsigned num_parts, const char *type)</td></tr>
<tr class="memdesc:a5ff5b80044f8b418f960fdedba2906c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory function: create input split given a uri  <br /></td></tr>
<tr class="separator:a5ff5b80044f8b418f960fdedba2906c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38556c27a1fd889d17e20817a988f6a2" id="r_a38556c27a1fd889d17e20817a988f6a2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdmlc_1_1InputSplit.html">InputSplit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#a38556c27a1fd889d17e20817a988f6a2">Create</a> (const char *uri, const char *index_uri, unsigned part_index, unsigned num_parts, const char *type, const bool shuffle=false, const int seed=0, const size_t batch_size=256, const bool recurse_directories=false)</td></tr>
<tr class="memdesc:a38556c27a1fd889d17e20817a988f6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory function: create input split given a uri for input and index  <br /></td></tr>
<tr class="separator:a38556c27a1fd889d17e20817a988f6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>input split creates that allows reading of records from split of data, independent part that covers all the dataset </p>
<p>see <a class="el" href="classdmlc_1_1InputSplit.html#a5ff5b80044f8b418f960fdedba2906c7" title="factory function: create input split given a uri">InputSplit::Create</a> for definition of record </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2f111755a3434097bdd2a765982180a7" name="a2f111755a3434097bdd2a765982180a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f111755a3434097bdd2a765982180a7">&#9670;&#160;</a></span>BeforeFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dmlc::InputSplit::BeforeFirst </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset the position of <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> to beginning </p>

<p>Implemented in <a class="el" href="classdmlc_1_1io_1_1SingleThreadedInputSplit.html#a666fdafcd03773051d654d9fa3ee454e">dmlc::io::SingleThreadedInputSplit</a>, <a class="el" href="classdmlc_1_1InputSplitShuffle.html#af3f6ae9b61f4d18494d4bfbda0fab9c8">dmlc::InputSplitShuffle</a>, <a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#abe9654a0600b12fc0fcc26835c79438c">dmlc::io::InputSplitBase</a>, <a class="el" href="classdmlc_1_1io_1_1SingleFileSplit.html#a7466a166bead6e833411bbaa7b80a27b">dmlc::io::SingleFileSplit</a>, and <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#acd0b46ddc3155e8c5d3d59bc3cfc1a22">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="a38556c27a1fd889d17e20817a988f6a2" name="a38556c27a1fd889d17e20817a988f6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38556c27a1fd889d17e20817a988f6a2">&#9670;&#160;</a></span>Create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdmlc_1_1InputSplit.html">InputSplit</a> * dmlc::InputSplit::Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>index_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>part_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shuffle</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recurse_directories</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>factory function: create input split given a uri for input and index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>the uri of the input, can contain hdfs prefix </td></tr>
    <tr><td class="paramname">index_uri</td><td>the uri of the index, can contain hdfs prefix </td></tr>
    <tr><td class="paramname">part_index</td><td>the part id of current input </td></tr>
    <tr><td class="paramname">num_parts</td><td>total number of splits </td></tr>
    <tr><td class="paramname">type</td><td>type of record List of possible types: "text", "recordio", "indexed_recordio"<ul>
<li>"text": text file, each line is treated as a record input split will split on '\n' or '\r'</li>
<li>"recordio": binary recordio file, see <a class="el" href="recordio_8h.html" title="recordio that is able to pack binary data into a splittable format, useful to exchange data in binary...">recordio.h</a></li>
<li>"indexed_recordio": binary recordio file with index, see <a class="el" href="recordio_8h.html" title="recordio that is able to pack binary data into a splittable format, useful to exchange data in binary...">recordio.h</a> </li>
</ul>
</td></tr>
    <tr><td class="paramname">shuffle</td><td>whether to shuffle the output from the <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a>, supported only by "indexed_recordio" type. Defaults to "false" </td></tr>
    <tr><td class="paramname">seed</td><td>random seed to use in conjunction with the "shuffle" option. Defaults to 0 </td></tr>
    <tr><td class="paramname">batch_size</td><td>a hint to <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> what is the intended number of examples return per batch. Used only by "indexed_recordio" type </td></tr>
    <tr><td class="paramname">recurse_directories</td><td>whether to recursively traverse directories </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new input split </dd></dl>
<dl class="section see"><dt>See also</dt><dd>InputSplit::Type </dd></dl>

</div>
</div>
<a id="a5ff5b80044f8b418f960fdedba2906c7" name="a5ff5b80044f8b418f960fdedba2906c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff5b80044f8b418f960fdedba2906c7">&#9670;&#160;</a></span>Create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdmlc_1_1InputSplit.html">InputSplit</a> * dmlc::InputSplit::Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>part_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>factory function: create input split given a uri </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>the uri of the input, can contain hdfs prefix </td></tr>
    <tr><td class="paramname">part_index</td><td>the part id of current input </td></tr>
    <tr><td class="paramname">num_parts</td><td>total number of splits </td></tr>
    <tr><td class="paramname">type</td><td>type of record List of possible types: "text", "recordio", "indexed_recordio"<ul>
<li>"text": text file, each line is treated as a record input split will split on '\n' or '\r'</li>
<li>"recordio": binary recordio file, see <a class="el" href="recordio_8h.html" title="recordio that is able to pack binary data into a splittable format, useful to exchange data in binary...">recordio.h</a></li>
<li>"indexed_recordio": binary recordio file with index, see <a class="el" href="recordio_8h.html" title="recordio that is able to pack binary data into a splittable format, useful to exchange data in binary...">recordio.h</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new input split </dd></dl>
<dl class="section see"><dt>See also</dt><dd>InputSplit::Type </dd></dl>

</div>
</div>
<a id="af2fb3e0f9acd6bae599a398eb0758044" name="af2fb3e0f9acd6bae599a398eb0758044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fb3e0f9acd6bae599a398eb0758044">&#9670;&#160;</a></span>GetTotalSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t dmlc::InputSplit::GetTotalSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the total size of the <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> </p>

<p>Implemented in <a class="el" href="classdmlc_1_1InputSplitShuffle.html#a768b224c5dad3d7cef5af3c5cbd08263">dmlc::InputSplitShuffle</a>, <a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a856b7e1c571740b20dcad25c0c2ecaf1">dmlc::io::InputSplitBase</a>, <a class="el" href="classdmlc_1_1io_1_1SingleFileSplit.html#a4a2ebde5ea34699f938e4e4c000d61e8">dmlc::io::SingleFileSplit</a>, and <a class="el" href="classdmlc_1_1io_1_1SingleThreadedInputSplit.html#a57fec8cd03beeaf64c95ffae380f85d5">dmlc::io::SingleThreadedInputSplit</a>.</p>

</div>
</div>
<a id="af73e8f2ba0ccbf17326d8d5ff1cfd96e" name="af73e8f2ba0ccbf17326d8d5ff1cfd96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73e8f2ba0ccbf17326d8d5ff1cfd96e">&#9670;&#160;</a></span>HintChunkSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dmlc::InputSplit::HintChunkSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hint the inputsplit how large the chunk size it should return when implementing NextChunk this is a hint so may not be enforced, but <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> will try adjust its internal buffer size to the hinted value </p>

<p>Reimplemented in <a class="el" href="classdmlc_1_1InputSplitShuffle.html#a491c4e5c44919e24d32403caeecdf468">dmlc::InputSplitShuffle</a>, <a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a260100404e746cf53bcad4b9d0eb87da">dmlc::io::InputSplitBase</a>, <a class="el" href="classdmlc_1_1io_1_1SingleFileSplit.html#a9a4bbea35c5ed1938b9c6550e683e9ec">dmlc::io::SingleFileSplit</a>, and <a class="el" href="classdmlc_1_1io_1_1SingleThreadedInputSplit.html#a8a84d25c2aa68e00f76e66dea2d0e919">dmlc::io::SingleThreadedInputSplit</a>.</p>

</div>
</div>
<a id="ac7b7c78fed8312c221d9999f73fe615b" name="ac7b7c78fed8312c221d9999f73fe615b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b7c78fed8312c221d9999f73fe615b">&#9670;&#160;</a></span>NextBatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dmlc::InputSplit::NextBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *&#160;</td>
          <td class="paramname"><em>out_chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a chunk of memory that can contain multiple records, with hint for how many records is needed, the caller needs to parse the content of the resulting chunk, for text file, out_chunk can contain data of multiple lines for recordio, out_chunk can contain multiple records(including headers) </p>
<p>This function ensures there won't be partial record in the chunk caller can modify the memory content of out_chunk, the memory is valid until next call to NextRecord, NextChunk or NextBatch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_chunk</td><td>used to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we can successfully get next record false if we reached end of split </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdmlc_1_1InputSplit.html#a5ff5b80044f8b418f960fdedba2906c7" title="factory function: create input split given a uri">InputSplit::Create</a> for definition of record </dd>
<dd>
<a class="el" href="classdmlc_1_1RecordIOChunkReader.html" title="reader of binary recordio from Blob returned by InputSplit This class divides the blob into several i...">RecordIOChunkReader</a> to parse recordio content from out_chunk </dd></dl>

<p>Reimplemented in <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#ad83c4c5e24b3fb81e3d1806c8a28c948">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="a2e835c07ce77d8d873592e006c242156" name="a2e835c07ce77d8d873592e006c242156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e835c07ce77d8d873592e006c242156">&#9670;&#160;</a></span>NextChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dmlc::InputSplit::NextChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *&#160;</td>
          <td class="paramname"><em>out_chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a chunk of memory that can contain multiple records, the caller needs to parse the content of the resulting chunk, for text file, out_chunk can contain data of multiple lines for recordio, out_chunk can contain multiple records(including headers) </p>
<p>This function ensures there won't be partial record in the chunk caller can modify the memory content of out_chunk, the memory is valid until next call to NextRecord, NextChunk or NextBatch</p>
<p>Usually NextRecord is sufficient, NextChunk can be used by some multi-threaded parsers to parse the input content</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_chunk</td><td>used to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we can successfully get next record false if we reached end of split </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdmlc_1_1InputSplit.html#a5ff5b80044f8b418f960fdedba2906c7" title="factory function: create input split given a uri">InputSplit::Create</a> for definition of record </dd>
<dd>
<a class="el" href="classdmlc_1_1RecordIOChunkReader.html" title="reader of binary recordio from Blob returned by InputSplit This class divides the blob into several i...">RecordIOChunkReader</a> to parse recordio content from out_chunk </dd></dl>

<p>Implemented in <a class="el" href="classdmlc_1_1InputSplitShuffle.html#a88433138b96bc4c00d3e3bc8f2856025">dmlc::InputSplitShuffle</a>, <a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a808a46ac098da6a743dbb60c14900dd1">dmlc::io::InputSplitBase</a>, <a class="el" href="classdmlc_1_1io_1_1SingleFileSplit.html#a986dc69ceb89ee2848dfbeae5b1d60b8">dmlc::io::SingleFileSplit</a>, <a class="el" href="classdmlc_1_1io_1_1SingleThreadedInputSplit.html#a80ef57bc3ed0d05e711886590857f8a6">dmlc::io::SingleThreadedInputSplit</a>, and <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#a99037d20f277b04890d9bc1074c343f6">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="a0f124b34e62d9319dca39fa42e5a59f7" name="a0f124b34e62d9319dca39fa42e5a59f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f124b34e62d9319dca39fa42e5a59f7">&#9670;&#160;</a></span>NextRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dmlc::InputSplit::NextRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *&#160;</td>
          <td class="paramname"><em>out_rec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the next record, the returning value is valid until next call to NextRecord, NextChunk or NextBatch caller can modify the memory content of out_rec </p>
<p>For text, out_rec contains a single line For recordio, out_rec contains one record content(with header striped)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_rec</td><td>used to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we can successfully get next record false if we reached end of split </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdmlc_1_1InputSplit.html#a5ff5b80044f8b418f960fdedba2906c7" title="factory function: create input split given a uri">InputSplit::Create</a> for definition of record </dd></dl>

<p>Implemented in <a class="el" href="classdmlc_1_1InputSplitShuffle.html#ab8812c94aa95744a475a1549b2b6f6a6">dmlc::InputSplitShuffle</a>, <a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a3e0e8e963bd184e653eb0f84e874951b">dmlc::io::InputSplitBase</a>, <a class="el" href="classdmlc_1_1io_1_1SingleFileSplit.html#a456403a9825ab8fbce3b9d9c998920ab">dmlc::io::SingleFileSplit</a>, <a class="el" href="classdmlc_1_1io_1_1SingleThreadedInputSplit.html#a57bed018f497021795938c7d3667309d">dmlc::io::SingleThreadedInputSplit</a>, and <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#a74e038c96feb757fa83897835b8f50c9">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="aaa17b8be6b3f1da35ced68379e3e8dbe" name="aaa17b8be6b3f1da35ced68379e3e8dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa17b8be6b3f1da35ced68379e3e8dbe">&#9670;&#160;</a></span>ResetPartition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dmlc::InputSplit::ResetPartition </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>part_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset the Input split to a certain part id, The <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> will be pointed to the head of the new specified segment. This feature may not be supported by every implementation of <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_index</td><td>The part id of the new input. </td></tr>
    <tr><td class="paramname">num_parts</td><td>The total number of parts. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdmlc_1_1io_1_1SingleFileSplit.html#a536ec8ec56227fa5f42420d6e3490fec">dmlc::io::SingleFileSplit</a>, <a class="el" href="classdmlc_1_1io_1_1SingleThreadedInputSplit.html#a30bd3566fec79ff4afdc5f4b140f76be">dmlc::io::SingleThreadedInputSplit</a>, <a class="el" href="classdmlc_1_1InputSplitShuffle.html#a2e3056434b2605d42f935b242d0e4a3d">dmlc::InputSplitShuffle</a>, <a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#afd40d14188022fe8d39ae12708fcfe4d">dmlc::io::InputSplitBase</a>, and <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#ac64182e623982bdad5a0b9ef94c33a77">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>External/xgboost/dmlc-core/include/dmlc/<a class="el" href="dmlc-core_2include_2dmlc_2io_8h_source.html">io.h</a></li>
<li>External/xgboost/dmlc-core/src/<a class="el" href="dmlc-core_2src_2io_8cc_source.html">io.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 12 2025 11:25:22 for Medial Code Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
