<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medial Code Documentation: dmlc::io::InputSplitBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Medial Code Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedmlc.html">dmlc</a></li><li class="navelem"><b>io</b></li><li class="navelem"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html">InputSplitBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">dmlc::io::InputSplitBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>class to construct input split from multiple files  
 <a href="classdmlc_1_1io_1_1InputSplitBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="input__split__base_8h_source.html">input_split_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for dmlc::io::InputSplitBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classdmlc_1_1io_1_1InputSplitBase.png" usemap="#dmlc::io::InputSplitBase_map" alt=""/>
  <map id="dmlc::io::InputSplitBase_map" name="dmlc::io::InputSplitBase_map">
<area href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a..." alt="dmlc::InputSplit" shape="rect" coords="207,0,404,24"/>
<area href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html" title="class that splits the recordIO file by record" alt="dmlc::io::IndexedRecordIOSplitter" shape="rect" coords="0,112,197,136"/>
<area href="classdmlc_1_1io_1_1LineSplitter.html" title="class that split the files by line" alt="dmlc::io::LineSplitter" shape="rect" coords="207,112,404,136"/>
<area href="classdmlc_1_1io_1_1RecordIOSplitter.html" title="class that split the files by line" alt="dmlc::io::RecordIOSplitter" shape="rect" coords="414,112,611,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html">Chunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper struct to hold chunk data with internal pointer to move along the record  <a href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe9654a0600b12fc0fcc26835c79438c" id="r_abe9654a0600b12fc0fcc26835c79438c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#abe9654a0600b12fc0fcc26835c79438c">BeforeFirst</a> (void)</td></tr>
<tr class="memdesc:abe9654a0600b12fc0fcc26835c79438c"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the position of <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> to beginning  <br /></td></tr>
<tr class="separator:abe9654a0600b12fc0fcc26835c79438c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260100404e746cf53bcad4b9d0eb87da" id="r_a260100404e746cf53bcad4b9d0eb87da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a260100404e746cf53bcad4b9d0eb87da">HintChunkSize</a> (size_t chunk_size)</td></tr>
<tr class="memdesc:a260100404e746cf53bcad4b9d0eb87da"><td class="mdescLeft">&#160;</td><td class="mdescRight">hint the inputsplit how large the chunk size it should return when implementing NextChunk this is a hint so may not be enforced, but <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> will try adjust its internal buffer size to the hinted value  <br /></td></tr>
<tr class="separator:a260100404e746cf53bcad4b9d0eb87da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856b7e1c571740b20dcad25c0c2ecaf1" id="r_a856b7e1c571740b20dcad25c0c2ecaf1"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a856b7e1c571740b20dcad25c0c2ecaf1">GetTotalSize</a> (void)</td></tr>
<tr class="memdesc:a856b7e1c571740b20dcad25c0c2ecaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the total size of the <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a>  <br /></td></tr>
<tr class="separator:a856b7e1c571740b20dcad25c0c2ecaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0e8e963bd184e653eb0f84e874951b" id="r_a3e0e8e963bd184e653eb0f84e874951b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a3e0e8e963bd184e653eb0f84e874951b">NextRecord</a> (<a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *out_rec)</td></tr>
<tr class="memdesc:a3e0e8e963bd184e653eb0f84e874951b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the next record, the returning value is valid until next call to NextRecord, NextChunk or NextBatch caller can modify the memory content of out_rec  <br /></td></tr>
<tr class="separator:a3e0e8e963bd184e653eb0f84e874951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808a46ac098da6a743dbb60c14900dd1" id="r_a808a46ac098da6a743dbb60c14900dd1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a808a46ac098da6a743dbb60c14900dd1">NextChunk</a> (<a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *out_chunk)</td></tr>
<tr class="memdesc:a808a46ac098da6a743dbb60c14900dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a chunk of memory that can contain multiple records, the caller needs to parse the content of the resulting chunk, for text file, out_chunk can contain data of multiple lines for recordio, out_chunk can contain multiple records(including headers)  <br /></td></tr>
<tr class="separator:a808a46ac098da6a743dbb60c14900dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd40d14188022fe8d39ae12708fcfe4d" id="r_afd40d14188022fe8d39ae12708fcfe4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#afd40d14188022fe8d39ae12708fcfe4d">ResetPartition</a> (unsigned rank, unsigned nsplit)</td></tr>
<tr class="memdesc:afd40d14188022fe8d39ae12708fcfe4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the Input split to a certain part id, The <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> will be pointed to the head of the new specified segment. This feature may not be supported by every implementation of <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a>.  <br /></td></tr>
<tr class="separator:afd40d14188022fe8d39ae12708fcfe4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52aee6082915814951596e09967c5f8" id="r_ad52aee6082915814951596e09967c5f8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#ad52aee6082915814951596e09967c5f8">ReadChunk</a> (void *buf, size_t *size)</td></tr>
<tr class="memdesc:ad52aee6082915814951596e09967c5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a chunk of data into buf the data can span multiple records, but cannot contain partial records  <br /></td></tr>
<tr class="separator:ad52aee6082915814951596e09967c5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11f755c14bfe3332a82eeead0414916" id="r_aa11f755c14bfe3332a82eeead0414916"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#aa11f755c14bfe3332a82eeead0414916">ExtractNextChunk</a> (<a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *out_rchunk, <a class="el" href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html">Chunk</a> *chunk)</td></tr>
<tr class="memdesc:aa11f755c14bfe3332a82eeead0414916"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract next chunk from the chunk  <br /></td></tr>
<tr class="separator:aa11f755c14bfe3332a82eeead0414916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90233e76ce2c46d4037ae29e98d0014" id="r_ae90233e76ce2c46d4037ae29e98d0014"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#ae90233e76ce2c46d4037ae29e98d0014">ExtractNextRecord</a> (<a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *out_rec, <a class="el" href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html">Chunk</a> *chunk)=0</td></tr>
<tr class="memdesc:ae90233e76ce2c46d4037ae29e98d0014"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract next record from the chunk  <br /></td></tr>
<tr class="separator:ae90233e76ce2c46d4037ae29e98d0014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590b21eb9b8f04bd0c6f82cca5e1f7c1" id="r_a590b21eb9b8f04bd0c6f82cca5e1f7c1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a590b21eb9b8f04bd0c6f82cca5e1f7c1">IsTextParser</a> (void)=0</td></tr>
<tr class="memdesc:a590b21eb9b8f04bd0c6f82cca5e1f7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">query whether this object is a text parser  <br /></td></tr>
<tr class="separator:a590b21eb9b8f04bd0c6f82cca5e1f7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e61fd99a713e725f8a009cd6c4c5bd" id="r_a02e61fd99a713e725f8a009cd6c4c5bd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a02e61fd99a713e725f8a009cd6c4c5bd">NextChunkEx</a> (<a class="el" href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html">Chunk</a> *chunk)</td></tr>
<tr class="memdesc:a02e61fd99a713e725f8a009cd6c4c5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill the given chunk with new data without using internal temporary chunk  <br /></td></tr>
<tr class="separator:a02e61fd99a713e725f8a009cd6c4c5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744b03b12d8eb8fdbeb59b7b6f383ff8" id="r_a744b03b12d8eb8fdbeb59b7b6f383ff8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a744b03b12d8eb8fdbeb59b7b6f383ff8">NextBatchEx</a> (<a class="el" href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html">Chunk</a> *chunk, size_t)</td></tr>
<tr class="memdesc:a744b03b12d8eb8fdbeb59b7b6f383ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill the given chunk with new batch of data without using internal temporary chunk  <br /></td></tr>
<tr class="separator:a744b03b12d8eb8fdbeb59b7b6f383ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdmlc_1_1InputSplit"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdmlc_1_1InputSplit')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdmlc_1_1InputSplit.html">dmlc::InputSplit</a></td></tr>
<tr class="memitem:ac7b7c78fed8312c221d9999f73fe615b inherit pub_methods_classdmlc_1_1InputSplit" id="r_ac7b7c78fed8312c221d9999f73fe615b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#ac7b7c78fed8312c221d9999f73fe615b">NextBatch</a> (<a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *out_chunk, size_t)</td></tr>
<tr class="memdesc:ac7b7c78fed8312c221d9999f73fe615b inherit pub_methods_classdmlc_1_1InputSplit"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a chunk of memory that can contain multiple records, with hint for how many records is needed, the caller needs to parse the content of the resulting chunk, for text file, out_chunk can contain data of multiple lines for recordio, out_chunk can contain multiple records(including headers)  <br /></td></tr>
<tr class="separator:ac7b7c78fed8312c221d9999f73fe615b inherit pub_methods_classdmlc_1_1InputSplit"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a1f234a44de0950d1011495f41b265 inherit pub_methods_classdmlc_1_1InputSplit" id="r_a00a1f234a44de0950d1011495f41b265"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~InputSplit</b> (void) DMLC_THROW_EXCEPTION</td></tr>
<tr class="memdesc:a00a1f234a44de0950d1011495f41b265 inherit pub_methods_classdmlc_1_1InputSplit"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a00a1f234a44de0950d1011495f41b265 inherit pub_methods_classdmlc_1_1InputSplit"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:afc990a438bcb9e7e14c5659447a53c6d" id="r_afc990a438bcb9e7e14c5659447a53c6d"><td class="memItemLeft" align="right" valign="top"><a id="afc990a438bcb9e7e14c5659447a53c6d" name="afc990a438bcb9e7e14c5659447a53c6d"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kBufferSize</b> = 2UL &lt;&lt; 20UL</td></tr>
<tr class="separator:afc990a438bcb9e7e14c5659447a53c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a52864175a7762b7688255b211b09b3c0" id="r_a52864175a7762b7688255b211b09b3c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a52864175a7762b7688255b211b09b3c0">Init</a> (FileSystem *fs, const char *uri, size_t align_bytes, const bool recurse_directories=false)</td></tr>
<tr class="memdesc:a52864175a7762b7688255b211b09b3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">intialize the base before doing anything  <br /></td></tr>
<tr class="separator:a52864175a7762b7688255b211b09b3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0f57a7d2e28d8203eb8f7f606218b5" id="r_a8b0f57a7d2e28d8203eb8f7f606218b5"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#a8b0f57a7d2e28d8203eb8f7f606218b5">SeekRecordBegin</a> (<a class="el" href="classdmlc_1_1Stream.html">Stream</a> *fi)=0</td></tr>
<tr class="memdesc:a8b0f57a7d2e28d8203eb8f7f606218b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">seek to the beginning of the first record in current file pointer  <br /></td></tr>
<tr class="separator:a8b0f57a7d2e28d8203eb8f7f606218b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c0abf15a2d52c6b1f0d20eeb4ffd78" id="r_ae3c0abf15a2d52c6b1f0d20eeb4ffd78"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1io_1_1InputSplitBase.html#ae3c0abf15a2d52c6b1f0d20eeb4ffd78">FindLastRecordBegin</a> (const char *begin, const char *end)=0</td></tr>
<tr class="memdesc:ae3c0abf15a2d52c6b1f0d20eeb4ffd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the last occurance of record header  <br /></td></tr>
<tr class="separator:ae3c0abf15a2d52c6b1f0d20eeb4ffd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7420d824c7076ec973cfa6d01a4c3e0" id="r_ac7420d824c7076ec973cfa6d01a4c3e0"><td class="memItemLeft" align="right" valign="top"><a id="ac7420d824c7076ec973cfa6d01a4c3e0" name="ac7420d824c7076ec973cfa6d01a4c3e0"></a>
std::vector&lt; URI &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertToURIs</b> (const std::string &amp;uri)</td></tr>
<tr class="memdesc:ac7420d824c7076ec973cfa6d01a4c3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">split string list of files into vector of URIs <br /></td></tr>
<tr class="separator:ac7420d824c7076ec973cfa6d01a4c3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3351a9e7416ae28a4535a3cf050a0d4" id="r_ae3351a9e7416ae28a4535a3cf050a0d4"><td class="memItemLeft" align="right" valign="top"><a id="ae3351a9e7416ae28a4535a3cf050a0d4" name="ae3351a9e7416ae28a4535a3cf050a0d4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>Read</b> (void *ptr, size_t size)</td></tr>
<tr class="memdesc:ae3351a9e7416ae28a4535a3cf050a0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as stream.Read <br /></td></tr>
<tr class="separator:ae3351a9e7416ae28a4535a3cf050a0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a622321e60d346de5a6cbbd57e1cf74ca" id="r_a622321e60d346de5a6cbbd57e1cf74ca"><td class="memItemLeft" align="right" valign="top"><a id="a622321e60d346de5a6cbbd57e1cf74ca" name="a622321e60d346de5a6cbbd57e1cf74ca"></a>
FileSystem *&#160;</td><td class="memItemRight" valign="bottom"><b>filesys_</b></td></tr>
<tr class="memdesc:a622321e60d346de5a6cbbd57e1cf74ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">FileSystem. <br /></td></tr>
<tr class="separator:a622321e60d346de5a6cbbd57e1cf74ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703e837bb62ac3a5832ce6bddd1f3a3e" id="r_a703e837bb62ac3a5832ce6bddd1f3a3e"><td class="memItemLeft" align="right" valign="top"><a id="a703e837bb62ac3a5832ce6bddd1f3a3e" name="a703e837bb62ac3a5832ce6bddd1f3a3e"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>file_offset_</b></td></tr>
<tr class="memdesc:a703e837bb62ac3a5832ce6bddd1f3a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte-offset of each file <br /></td></tr>
<tr class="separator:a703e837bb62ac3a5832ce6bddd1f3a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add959bb1158d18ede7159cf672a12c50" id="r_add959bb1158d18ede7159cf672a12c50"><td class="memItemLeft" align="right" valign="top"><a id="add959bb1158d18ede7159cf672a12c50" name="add959bb1158d18ede7159cf672a12c50"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>offset_curr_</b></td></tr>
<tr class="memdesc:add959bb1158d18ede7159cf672a12c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current offset <br /></td></tr>
<tr class="separator:add959bb1158d18ede7159cf672a12c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e13f1fdb4f23f1abf66bd1a11cd8644" id="r_a0e13f1fdb4f23f1abf66bd1a11cd8644"><td class="memItemLeft" align="right" valign="top"><a id="a0e13f1fdb4f23f1abf66bd1a11cd8644" name="a0e13f1fdb4f23f1abf66bd1a11cd8644"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>offset_begin_</b></td></tr>
<tr class="memdesc:a0e13f1fdb4f23f1abf66bd1a11cd8644"><td class="mdescLeft">&#160;</td><td class="mdescRight">beginning of offset <br /></td></tr>
<tr class="separator:a0e13f1fdb4f23f1abf66bd1a11cd8644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da27d164dd3e391355355c5091072a5" id="r_a1da27d164dd3e391355355c5091072a5"><td class="memItemLeft" align="right" valign="top"><a id="a1da27d164dd3e391355355c5091072a5" name="a1da27d164dd3e391355355c5091072a5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>offset_end_</b></td></tr>
<tr class="memdesc:a1da27d164dd3e391355355c5091072a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">end of the offset <br /></td></tr>
<tr class="separator:a1da27d164dd3e391355355c5091072a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5598ec7a80f267e9e63e39168e36ac87" id="r_a5598ec7a80f267e9e63e39168e36ac87"><td class="memItemLeft" align="right" valign="top"><a id="a5598ec7a80f267e9e63e39168e36ac87" name="a5598ec7a80f267e9e63e39168e36ac87"></a>
std::vector&lt; FileInfo &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>files_</b></td></tr>
<tr class="memdesc:a5598ec7a80f267e9e63e39168e36ac87"><td class="mdescLeft">&#160;</td><td class="mdescRight">information about files <br /></td></tr>
<tr class="separator:a5598ec7a80f267e9e63e39168e36ac87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e08b34658599aeb4c6540948219b05" id="r_a42e08b34658599aeb4c6540948219b05"><td class="memItemLeft" align="right" valign="top"><a id="a42e08b34658599aeb4c6540948219b05" name="a42e08b34658599aeb4c6540948219b05"></a>
<a class="el" href="classdmlc_1_1SeekStream.html">SeekStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>fs_</b></td></tr>
<tr class="memdesc:a42e08b34658599aeb4c6540948219b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">current input stream <br /></td></tr>
<tr class="separator:a42e08b34658599aeb4c6540948219b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87597af0f587e93af418275599b54744" id="r_a87597af0f587e93af418275599b54744"><td class="memItemLeft" align="right" valign="top"><a id="a87597af0f587e93af418275599b54744" name="a87597af0f587e93af418275599b54744"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>file_ptr_</b></td></tr>
<tr class="memdesc:a87597af0f587e93af418275599b54744"><td class="mdescLeft">&#160;</td><td class="mdescRight">file pointer of which file to read on <br /></td></tr>
<tr class="separator:a87597af0f587e93af418275599b54744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcc66471d89adefbbcfdb37d9af93fd" id="r_a4dcc66471d89adefbbcfdb37d9af93fd"><td class="memItemLeft" align="right" valign="top"><a id="a4dcc66471d89adefbbcfdb37d9af93fd" name="a4dcc66471d89adefbbcfdb37d9af93fd"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>file_ptr_end_</b></td></tr>
<tr class="memdesc:a4dcc66471d89adefbbcfdb37d9af93fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">file pointer where the end of file lies <br /></td></tr>
<tr class="separator:a4dcc66471d89adefbbcfdb37d9af93fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae880b469838bd74201e54c24762c4965" id="r_ae880b469838bd74201e54c24762c4965"><td class="memItemLeft" align="right" valign="top"><a id="ae880b469838bd74201e54c24762c4965" name="ae880b469838bd74201e54c24762c4965"></a>
<a class="el" href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html">Chunk</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tmp_chunk_</b></td></tr>
<tr class="memdesc:ae880b469838bd74201e54c24762c4965"><td class="mdescLeft">&#160;</td><td class="mdescRight">temporal chunk <br /></td></tr>
<tr class="separator:ae880b469838bd74201e54c24762c4965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0aa4fc648921de53146b484058380c5" id="r_ae0aa4fc648921de53146b484058380c5"><td class="memItemLeft" align="right" valign="top"><a id="ae0aa4fc648921de53146b484058380c5" name="ae0aa4fc648921de53146b484058380c5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_size_</b></td></tr>
<tr class="memdesc:ae0aa4fc648921de53146b484058380c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer size <br /></td></tr>
<tr class="separator:ae0aa4fc648921de53146b484058380c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classdmlc_1_1InputSplit"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classdmlc_1_1InputSplit')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classdmlc_1_1InputSplit.html">dmlc::InputSplit</a></td></tr>
<tr class="memitem:a5ff5b80044f8b418f960fdedba2906c7 inherit pub_static_methods_classdmlc_1_1InputSplit" id="r_a5ff5b80044f8b418f960fdedba2906c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdmlc_1_1InputSplit.html">InputSplit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#a5ff5b80044f8b418f960fdedba2906c7">Create</a> (const char *uri, unsigned part_index, unsigned num_parts, const char *type)</td></tr>
<tr class="memdesc:a5ff5b80044f8b418f960fdedba2906c7 inherit pub_static_methods_classdmlc_1_1InputSplit"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory function: create input split given a uri  <br /></td></tr>
<tr class="separator:a5ff5b80044f8b418f960fdedba2906c7 inherit pub_static_methods_classdmlc_1_1InputSplit"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38556c27a1fd889d17e20817a988f6a2 inherit pub_static_methods_classdmlc_1_1InputSplit" id="r_a38556c27a1fd889d17e20817a988f6a2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdmlc_1_1InputSplit.html">InputSplit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html#a38556c27a1fd889d17e20817a988f6a2">Create</a> (const char *uri, const char *index_uri, unsigned part_index, unsigned num_parts, const char *type, const bool shuffle=false, const int seed=0, const size_t batch_size=256, const bool recurse_directories=false)</td></tr>
<tr class="memdesc:a38556c27a1fd889d17e20817a988f6a2 inherit pub_static_methods_classdmlc_1_1InputSplit"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory function: create input split given a uri for input and index  <br /></td></tr>
<tr class="separator:a38556c27a1fd889d17e20817a988f6a2 inherit pub_static_methods_classdmlc_1_1InputSplit"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>class to construct input split from multiple files </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abe9654a0600b12fc0fcc26835c79438c" name="abe9654a0600b12fc0fcc26835c79438c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9654a0600b12fc0fcc26835c79438c">&#9670;&#160;</a></span>BeforeFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dmlc::io::InputSplitBase::BeforeFirst </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset the position of <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> to beginning </p>

<p>Implements <a class="el" href="classdmlc_1_1InputSplit.html#a2f111755a3434097bdd2a765982180a7">dmlc::InputSplit</a>.</p>

<p>Reimplemented in <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#acd0b46ddc3155e8c5d3d59bc3cfc1a22">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="aa11f755c14bfe3332a82eeead0414916" name="aa11f755c14bfe3332a82eeead0414916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11f755c14bfe3332a82eeead0414916">&#9670;&#160;</a></span>ExtractNextChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::io::InputSplitBase::ExtractNextChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *&#160;</td>
          <td class="paramname"><em>out_rchunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html">Chunk</a> *&#160;</td>
          <td class="paramname"><em>chunk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract next chunk from the chunk </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_chunk</td><td>the output record </td></tr>
    <tr><td class="paramname">chunk</td><td>the chunk information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if non-empty record is extracted false if the chunk is already finishes its life </dd></dl>

</div>
</div>
<a id="ae90233e76ce2c46d4037ae29e98d0014" name="ae90233e76ce2c46d4037ae29e98d0014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90233e76ce2c46d4037ae29e98d0014">&#9670;&#160;</a></span>ExtractNextRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dmlc::io::InputSplitBase::ExtractNextRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *&#160;</td>
          <td class="paramname"><em>out_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html">Chunk</a> *&#160;</td>
          <td class="paramname"><em>chunk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract next record from the chunk </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_rec</td><td>the output record </td></tr>
    <tr><td class="paramname">chunk</td><td>the chunk information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if non-empty record is extracted false if the chunk is already finishes its life </dd></dl>

<p>Implemented in <a class="el" href="classdmlc_1_1io_1_1LineSplitter.html#ad7e1020db6b41b1d269c8a909e4686ba">dmlc::io::LineSplitter</a>, <a class="el" href="classdmlc_1_1io_1_1RecordIOSplitter.html#abe6675bef8a4fdf6c5f83bab69954b1d">dmlc::io::RecordIOSplitter</a>, and <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#ab6232ce1202d92f46fabedf5b2cedbb1">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="ae3c0abf15a2d52c6b1f0d20eeb4ffd78" name="ae3c0abf15a2d52c6b1f0d20eeb4ffd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c0abf15a2d52c6b1f0d20eeb4ffd78">&#9670;&#160;</a></span>FindLastRecordBegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * dmlc::io::InputSplitBase::FindLastRecordBegin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the last occurance of record header </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer between [begin, end] indicating the last record head </dd></dl>

<p>Implemented in <a class="el" href="classdmlc_1_1io_1_1LineSplitter.html#a74794238d52d03d3ba7fec2df9efc502">dmlc::io::LineSplitter</a>, <a class="el" href="classdmlc_1_1io_1_1RecordIOSplitter.html#a814e292202ad9e8d66e0856ab226946c">dmlc::io::RecordIOSplitter</a>, and <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#aa09ac0a061c3c1a7e9d86accb666eab9">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="a856b7e1c571740b20dcad25c0c2ecaf1" name="a856b7e1c571740b20dcad25c0c2ecaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856b7e1c571740b20dcad25c0c2ecaf1">&#9670;&#160;</a></span>GetTotalSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t dmlc::io::InputSplitBase::GetTotalSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the total size of the <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> </p>

<p>Implements <a class="el" href="classdmlc_1_1InputSplit.html#af2fb3e0f9acd6bae599a398eb0758044">dmlc::InputSplit</a>.</p>

</div>
</div>
<a id="a260100404e746cf53bcad4b9d0eb87da" name="a260100404e746cf53bcad4b9d0eb87da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260100404e746cf53bcad4b9d0eb87da">&#9670;&#160;</a></span>HintChunkSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dmlc::io::InputSplitBase::HintChunkSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hint the inputsplit how large the chunk size it should return when implementing NextChunk this is a hint so may not be enforced, but <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> will try adjust its internal buffer size to the hinted value </p>

<p>Reimplemented from <a class="el" href="classdmlc_1_1InputSplit.html#af73e8f2ba0ccbf17326d8d5ff1cfd96e">dmlc::InputSplit</a>.</p>

</div>
</div>
<a id="a52864175a7762b7688255b211b09b3c0" name="a52864175a7762b7688255b211b09b3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52864175a7762b7688255b211b09b3c0">&#9670;&#160;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dmlc::io::InputSplitBase::Init </td>
          <td>(</td>
          <td class="paramtype">FileSystem *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recurse_directories</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>intialize the base before doing anything </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>the filesystem ptr </td></tr>
    <tr><td class="paramname">uri</td><td>the uri of the files </td></tr>
    <tr><td class="paramname">rank</td><td>the rank of the split </td></tr>
    <tr><td class="paramname">nsplit</td><td>number of splits </td></tr>
    <tr><td class="paramname">align_bytes</td><td>the head split must be multiple of align_bytes this also checks if file size are multiple of align_bytes </td></tr>
    <tr><td class="paramname">recurse_directories</td><td>recursively travese directories </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a590b21eb9b8f04bd0c6f82cca5e1f7c1" name="a590b21eb9b8f04bd0c6f82cca5e1f7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590b21eb9b8f04bd0c6f82cca5e1f7c1">&#9670;&#160;</a></span>IsTextParser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dmlc::io::InputSplitBase::IsTextParser </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>query whether this object is a text parser </p>
<dl class="section return"><dt>Returns</dt><dd>true if this object represents a text parser; false if it represents a binary parser </dd></dl>

<p>Implemented in <a class="el" href="classdmlc_1_1io_1_1LineSplitter.html#a9b36fc6c5d93280d7e9dcac4f4845cd8">dmlc::io::LineSplitter</a>, <a class="el" href="classdmlc_1_1io_1_1RecordIOSplitter.html#a978aebb5698ed260b615e7c5c1861714">dmlc::io::RecordIOSplitter</a>, and <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#ae4925f8e35fd6651e6d96af1588206db">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="a744b03b12d8eb8fdbeb59b7b6f383ff8" name="a744b03b12d8eb8fdbeb59b7b6f383ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744b03b12d8eb8fdbeb59b7b6f383ff8">&#9670;&#160;</a></span>NextBatchEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dmlc::io::InputSplitBase::NextBatchEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html">Chunk</a> *&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fill the given chunk with new batch of data without using internal temporary chunk </p>

<p>Reimplemented in <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#a15676857044e9e550f6d8657cc907452">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="a808a46ac098da6a743dbb60c14900dd1" name="a808a46ac098da6a743dbb60c14900dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808a46ac098da6a743dbb60c14900dd1">&#9670;&#160;</a></span>NextChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dmlc::io::InputSplitBase::NextChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *&#160;</td>
          <td class="paramname"><em>out_chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a chunk of memory that can contain multiple records, the caller needs to parse the content of the resulting chunk, for text file, out_chunk can contain data of multiple lines for recordio, out_chunk can contain multiple records(including headers) </p>
<p>This function ensures there won't be partial record in the chunk caller can modify the memory content of out_chunk, the memory is valid until next call to NextRecord, NextChunk or NextBatch</p>
<p>Usually NextRecord is sufficient, NextChunk can be used by some multi-threaded parsers to parse the input content</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_chunk</td><td>used to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we can successfully get next record false if we reached end of split </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdmlc_1_1InputSplit.html#a5ff5b80044f8b418f960fdedba2906c7" title="factory function: create input split given a uri">InputSplit::Create</a> for definition of record </dd>
<dd>
<a class="el" href="classdmlc_1_1RecordIOChunkReader.html" title="reader of binary recordio from Blob returned by InputSplit This class divides the blob into several i...">RecordIOChunkReader</a> to parse recordio content from out_chunk </dd></dl>

<p>Implements <a class="el" href="classdmlc_1_1InputSplit.html#a2e835c07ce77d8d873592e006c242156">dmlc::InputSplit</a>.</p>

<p>Reimplemented in <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#a99037d20f277b04890d9bc1074c343f6">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="a02e61fd99a713e725f8a009cd6c4c5bd" name="a02e61fd99a713e725f8a009cd6c4c5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e61fd99a713e725f8a009cd6c4c5bd">&#9670;&#160;</a></span>NextChunkEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dmlc::io::InputSplitBase::NextChunkEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1io_1_1InputSplitBase_1_1Chunk.html">Chunk</a> *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fill the given chunk with new data without using internal temporary chunk </p>

<p>Reimplemented in <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#adce3050011b94c4ec8de529a31cbdff0">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="a3e0e8e963bd184e653eb0f84e874951b" name="a3e0e8e963bd184e653eb0f84e874951b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0e8e963bd184e653eb0f84e874951b">&#9670;&#160;</a></span>NextRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dmlc::io::InputSplitBase::NextRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1InputSplit_1_1Blob.html">Blob</a> *&#160;</td>
          <td class="paramname"><em>out_rec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the next record, the returning value is valid until next call to NextRecord, NextChunk or NextBatch caller can modify the memory content of out_rec </p>
<p>For text, out_rec contains a single line For recordio, out_rec contains one record content(with header striped)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_rec</td><td>used to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we can successfully get next record false if we reached end of split </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdmlc_1_1InputSplit.html#a5ff5b80044f8b418f960fdedba2906c7" title="factory function: create input split given a uri">InputSplit::Create</a> for definition of record </dd></dl>

<p>Implements <a class="el" href="classdmlc_1_1InputSplit.html#a0f124b34e62d9319dca39fa42e5a59f7">dmlc::InputSplit</a>.</p>

<p>Reimplemented in <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#a74e038c96feb757fa83897835b8f50c9">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="ad52aee6082915814951596e09967c5f8" name="ad52aee6082915814951596e09967c5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52aee6082915814951596e09967c5f8">&#9670;&#160;</a></span>ReadChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::io::InputSplitBase::ReadChunk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read a chunk of data into buf the data can span multiple records, but cannot contain partial records </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the memory region of the buffer, should be properly aligned to 64 bits </td></tr>
    <tr><td class="paramname">size</td><td>the maximum size of memory, after the function returns, it stores the size of the chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether end of file was reached </dd></dl>

<p>Reimplemented in <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#aac26014f8c68a6b56ae6b40c1798d0ff">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="afd40d14188022fe8d39ae12708fcfe4d" name="afd40d14188022fe8d39ae12708fcfe4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd40d14188022fe8d39ae12708fcfe4d">&#9670;&#160;</a></span>ResetPartition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dmlc::io::InputSplitBase::ResetPartition </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>part_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset the Input split to a certain part id, The <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> will be pointed to the head of the new specified segment. This feature may not be supported by every implementation of <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_index</td><td>The part id of the new input. </td></tr>
    <tr><td class="paramname">num_parts</td><td>The total number of parts. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdmlc_1_1InputSplit.html#aaa17b8be6b3f1da35ced68379e3e8dbe">dmlc::InputSplit</a>.</p>

<p>Reimplemented in <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#ac64182e623982bdad5a0b9ef94c33a77">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<a id="a8b0f57a7d2e28d8203eb8f7f606218b5" name="a8b0f57a7d2e28d8203eb8f7f606218b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0f57a7d2e28d8203eb8f7f606218b5">&#9670;&#160;</a></span>SeekRecordBegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t dmlc::io::InputSplitBase::SeekRecordBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1Stream.html">Stream</a> *&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>seek to the beginning of the first record in current file pointer </p>
<dl class="section return"><dt>Returns</dt><dd>how many bytes we read past </dd></dl>

<p>Implemented in <a class="el" href="classdmlc_1_1io_1_1LineSplitter.html#a0a3bacf473166d6475a1b8d3cb4b55cb">dmlc::io::LineSplitter</a>, <a class="el" href="classdmlc_1_1io_1_1RecordIOSplitter.html#a5ed8d16ab0300dae45084133d7ab29b6">dmlc::io::RecordIOSplitter</a>, and <a class="el" href="classdmlc_1_1io_1_1IndexedRecordIOSplitter.html#a0660fafbfe60c1ec084a86accc5ea4a3">dmlc::io::IndexedRecordIOSplitter</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>External/xgboost/dmlc-core/src/io/<a class="el" href="input__split__base_8h_source.html">input_split_base.h</a></li>
<li>External/xgboost/dmlc-core/src/io/<a class="el" href="input__split__base_8cc_source.html">input_split_base.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 9 2025 16:36:38 for Medial Code Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
