<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medial Code Documentation: Understand your dataset with XGBoost</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Medial Code Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Understand your dataset with XGBoost</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md150"></a> </p>
<h1><a class="anchor" id="autotoc_md151"></a>
Introduction</h1>
<p>The purpose of this vignette is to show you how to use <b>XGBoost</b> to discover and understand your own dataset better.</p>
<p>This vignette is not about predicting anything (see <a href="https://github.com/dmlc/xgboost/blob/master/R-package/vignettes/xgboostPresentation.Rmd">XGBoost presentation</a>). We will explain how to use <b>XGBoost</b> to highlight the <em>link</em> between the <em>features</em> of your data and the <em>outcome</em>.</p>
<p>Package loading: </p><pre class="fragment">require(xgboost)
require(Matrix)
require(data.table)
if (!require('vcd')) {
  install.packages('vcd')
}
</pre> <blockquote class="doxtable">
<p>&zwj;<b>VCD</b> package is used for one of its embedded dataset only. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md152"></a>
Preparation of the dataset</h1>
<h2><a class="anchor" id="autotoc_md153"></a>
Numeric v.s. categorical variables</h2>
<p><b>XGBoost</b> manages only <code>numeric</code> vectors.</p>
<p>What to do when you have <em>categorical</em> data?</p>
<p>A <em>categorical</em> variable has a fixed number of different values. For instance, if a variable called <em>Colour</em> can have only one of these three values, <em>red</em>, <em>blue</em> or <em>green</em>, then <em>Colour</em> is a <em>categorical</em> variable.</p>
<blockquote class="doxtable">
<p>&zwj;In <b>R</b>, a <em>categorical</em> variable is called <code>factor</code>.</p>
<p>Type <code>?factor</code> in the console for more information. </p>
</blockquote>
<p>To answer the question above we will convert <em>categorical</em> variables to <code>numeric</code> ones.</p>
<h2><a class="anchor" id="autotoc_md154"></a>
Conversion from categorical to numeric variables</h2>
<h3><a class="anchor" id="autotoc_md155"></a>
Looking at the raw data</h3>
<p>+In this Vignette we will see how to transform a <em>dense</em> <code>data.frame</code> (<em>dense</em> = the majority of the matrix is non-zero) with <em>categorical</em> variables to a very <em>sparse</em> matrix (<em>sparse</em> = lots of zero entries in the matrix) of <code>numeric</code> features.</p>
<p>The method we are going to see is usually called <a href="https://en.wikipedia.org/wiki/One-hot">one-hot encoding</a>.</p>
<p>The first step is to load the <code>Arthritis</code> dataset in memory and wrap it with the <code>data.table</code> package. </p><pre class="fragment">data(Arthritis)
df &lt;- data.table(Arthritis, keep.rownames = FALSE)
</pre> <blockquote class="doxtable">
<p>&zwj;<code>data.table</code> is 100% compliant with <b>R</b> <code>data.frame</code> but its syntax is more consistent and its performance for large dataset is <a href="https://stackoverflow.com/questions/21435339/data-table-vs-dplyr-can-one-do-something-well-the-other-cant-or-does-poorly">best in class</a> (<code>dplyr</code> from <b>R</b> and <code>Pandas</code> from <b>Python</b> <a href="https://github.com/Rdatatable/data.table/wiki/Benchmarks-%3A-Grouping">included</a>). Some parts of <b>XGBoost’s</b> <b>R</b> package use <code>data.table</code>. </p>
</blockquote>
<p>The first thing we want to do is to have a look to the first few lines of the <code>data.table</code>: </p><pre class="fragment">head(df)

##    ID Treatment  Sex Age Improved
## 1: 57   Treated Male  27     Some
## 2: 46   Treated Male  29     None
## 3: 77   Treated Male  30     None
## 4: 17   Treated Male  32   Marked
## 5: 36   Treated Male  46   Marked
## 6: 23   Treated Male  58   Marked
</pre><p> Now we will check the format of each column. </p><pre class="fragment">str(df)

## Classes 'data.table' and 'data.frame':   84 obs. of  5 variables:
##  $ ID       : int  57 46 77 17 36 23 75 39 33 55 ...
##  $ Treatment: Factor w/ 2 levels "Placebo","Treated": 2 2 2 2 2 2 2 2 2 2 ...
##  $ Sex      : Factor w/ 2 levels "Female","Male": 2 2 2 2 2 2 2 2 2 2 ...
##  $ Age      : int  27 29 30 32 46 58 59 59 63 63 ...
##  $ Improved : Ord.factor w/ 3 levels "None"&lt;"Some"&lt;..: 2 1 1 3 3 3 1 3 1 1 ...
##  - attr(*, ".internal.selfref")=&lt;externalptr&gt;
</pre><p> 2 columns have <code>factor</code> type, one has <code>ordinal</code> type.</p>
<blockquote class="doxtable">
<p>&zwj;<code>ordinal</code> variable :</p>
<ul>
<li>can take a limited number of values (like <code>factor</code>) ;</li>
<li>these values are ordered (unlike <code>factor</code>). Here these ordered values are: <code>Marked &gt; Some &gt; None</code> </li>
</ul>
</blockquote>
<h3><a class="anchor" id="autotoc_md156"></a>
Creation of new features based on old ones</h3>
<p>We will add some new <em>categorical</em> features to see if it helps.</p>
<h4><a class="anchor" id="autotoc_md157"></a>
Grouping per 10 years</h4>
<p>For the first features we create groups of age by rounding the real age.</p>
<p>Note that we transform it to <code>factor</code> so the algorithm treats these age groups as independent values.</p>
<p>Therefore, 20 is not closer to 30 than 60. In other words, the distance between ages is lost in this transformation. </p><pre class="fragment">head(df[, AgeDiscret := as.factor(round(Age / 10, 0))])

##    ID Treatment  Sex Age Improved AgeDiscret
## 1: 57   Treated Male  27     Some          3
## 2: 46   Treated Male  29     None          3
## 3: 77   Treated Male  30     None          3
## 4: 17   Treated Male  32   Marked          3
## 5: 36   Treated Male  46   Marked          5
## 6: 23   Treated Male  58   Marked          6
</pre> <h4><a class="anchor" id="autotoc_md158"></a>
Randomly split into two groups</h4>
<p>The following is an even stronger simplification of the real age with an arbitrary split at 30 years old. I choose this value <b>based on nothing</b>. We will see later if simplifying the information based on arbitrary values is a good strategy (you may already have an idea of how well it will work…). </p><pre class="fragment">head(df[, AgeCat := as.factor(ifelse(Age &gt; 30, "Old", "Young"))])

##    ID Treatment  Sex Age Improved AgeDiscret AgeCat
## 1: 57   Treated Male  27     Some          3  Young
## 2: 46   Treated Male  29     None          3  Young
## 3: 77   Treated Male  30     None          3  Young
## 4: 17   Treated Male  32   Marked          3    Old
## 5: 36   Treated Male  46   Marked          5    Old
## 6: 23   Treated Male  58   Marked          6    Old
</pre> <h4><a class="anchor" id="autotoc_md159"></a>
Risks in adding correlated features</h4>
<p>These new features are highly correlated to the <code>Age</code> feature because they are simple transformations of this feature.</p>
<p>For many machine learning algorithms, using correlated features is not a good idea. It may sometimes make prediction less accurate, and most of the time make interpretation of the model almost impossible. GLM, for instance, assumes that the features are uncorrelated.</p>
<p>Fortunately, decision tree algorithms (including boosted trees) are very robust to these features. Therefore we don’t have to do anything to manage this situation.</p>
<h4><a class="anchor" id="autotoc_md160"></a>
Cleaning data</h4>
<p>We remove ID as there is nothing to learn from this feature (it would just add some noise). </p><pre class="fragment">df[, ID := NULL]
</pre><p> We will list the different values for the column <code>Treatment</code>: </p><pre class="fragment">levels(df[, Treatment])

## [1] "Placebo" "Treated"
</pre> <h3><a class="anchor" id="autotoc_md161"></a>
Encoding categorical features</h3>
<p>Next step, we will transform the categorical data to dummy variables. Several encoding methods exist, e.g., <a href="https://en.wikipedia.org/wiki/One-hot">one-hot encoding</a> is a common approach. We will use the <a href="https://stats.oarc.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/">dummy contrast coding</a> which is popular because it produces “full rank” encoding (also see <a href="http://appliedpredictivemodeling.com/blog/2013/10/23/the-basics-of-encoding-categorical-data-for-predictive-models">this blog post by Max Kuhn</a>).</p>
<p>The purpose is to transform each value of each <em>categorical</em> feature into a <em>binary</em> feature <code>{0, 1}</code>.</p>
<p>For example, the column <code>Treatment</code> will be replaced by two columns, <code>TreatmentPlacebo</code>, and <code>TreatmentTreated</code>. Each of them will be <em>binary</em>. Therefore, an observation which has the value <code>Placebo</code> in column <code>Treatment</code> before the transformation will have the value <code>1</code> in the new column <code>TreatmentPlacebo</code> and the value <code>0</code> in the new column <code>TreatmentTreated</code> after the transformation. The column <code>TreatmentPlacebo</code> will disappear during the contrast encoding, as it would be absorbed into a common constant intercept column.</p>
<p>Column <code>Improved</code> is excluded because it will be our <code>label</code> column, the one we want to predict. </p><pre class="fragment">sparse_matrix &lt;- sparse.model.matrix(Improved ~ ., data = df)[, -1]
head(sparse_matrix)

## 6 x 9 sparse Matrix of class "dgCMatrix"
##   TreatmentTreated SexMale Age AgeDiscret3 AgeDiscret4 AgeDiscret5 AgeDiscret6
## 1                1       1  27           1           .           .           .
## 2                1       1  29           1           .           .           .
## 3                1       1  30           1           .           .           .
## 4                1       1  32           1           .           .           .
## 5                1       1  46           .           .           1           .
## 6                1       1  58           .           .           .           1
##   AgeDiscret7 AgeCatYoung
## 1           .           1
## 2           .           1
## 3           .           1
## 4           .           .
## 5           .           .
## 6           .           .
</pre> <blockquote class="doxtable">
<p>&zwj;Formula <code>Improved ~ .</code> used above means transform all <em>categorical</em> features but column <code>Improved</code> to binary values. The <code>-1</code> column selection removes the intercept column which is full of <code>1</code> (this column is generated by the conversion). For more information, you can type <code>?sparse.model.matrix</code> in the console. </p>
</blockquote>
<p>Create the output <code>numeric</code> vector (not as a sparse <code>Matrix</code>): </p><pre class="fragment">output_vector &lt;- df[, Improved] == "Marked"
</pre><ol type="1">
<li>set <code>Y</code> vector to <code>0</code>;</li>
<li>set <code>Y</code> to <code>1</code> for rows where <code>Improved == Marked</code> is <code>TRUE</code> ;</li>
<li>return <code>Y</code> vector.</li>
</ol>
<h1><a class="anchor" id="autotoc_md162"></a>
Build the model</h1>
<p>The code below is very usual. For more information, you can look at the documentation of <code>xgboost</code> function (or at the vignette <a href="https://github.com/dmlc/xgboost/blob/master/R-package/vignettes/xgboostPresentation.Rmd">XGBoost presentation</a>). </p><pre class="fragment">bst &lt;- xgboost(data = sparse_matrix, label = output_vector, max_depth = 4,
               eta = 1, nthread = 2, nrounds = 10, objective = "binary:logistic")

## [1]  train-logloss:0.485466 
## [2]  train-logloss:0.438534 
## [3]  train-logloss:0.412250 
## [4]  train-logloss:0.395828 
## [5]  train-logloss:0.384264 
## [6]  train-logloss:0.374028 
## [7]  train-logloss:0.365005 
## [8]  train-logloss:0.351233 
## [9]  train-logloss:0.341678 
## [10] train-logloss:0.334465
</pre><p> You can see some <code>train-logloss: 0.XXXXX</code> lines followed by a number. It decreases. Each line shows how well the model explains the data. Lower is better.</p>
<p>A small value for training error may be a symptom of <a href="https://en.wikipedia.org/wiki/Overfitting">overfitting</a>, meaning the model will not accurately predict unseen values.</p>
<h1><a class="anchor" id="autotoc_md163"></a>
Feature importance</h1>
<h1><a class="anchor" id="autotoc_md164"></a>
Measure feature importance</h1>
<h2><a class="anchor" id="autotoc_md165"></a>
Build the feature importance data.table</h2>
<p>Remember, each binary column corresponds to a single value of one of <em>categorical</em> features. </p><pre class="fragment">importance &lt;- xgb.importance(feature_names = colnames(sparse_matrix), model = bst)
head(importance)

##             Feature        Gain      Cover  Frequency
## 1:              Age 0.622031769 0.67251696 0.67241379
## 2: TreatmentTreated 0.285750540 0.11916651 0.10344828
## 3:          SexMale 0.048744022 0.04522028 0.08620690
## 4:      AgeDiscret6 0.016604639 0.04784639 0.05172414
## 5:      AgeDiscret3 0.016373781 0.08028951 0.05172414
## 6:      AgeDiscret4 0.009270557 0.02858801 0.01724138
</pre> <blockquote class="doxtable">
<p>&zwj;The column <code>Gain</code> provides the information we are looking for.</p>
<p>As you can see, features are classified by <code>Gain</code>. </p>
</blockquote>
<p><code>Gain</code> is the improvement in accuracy brought by a feature to the branches it is on. The idea is that before adding a new split on a feature X to the branch there were some wrongly classified elements; after adding the split on this feature, there are two new branches, and each of these branches is more accurate (one branch saying if your observation is on this branch then it should be classified as <code>1</code>, and the other branch saying the exact opposite).</p>
<p><code>Cover</code> is related to the second order derivative (or Hessian) of the loss function with respect to a particular variable; thus, a large value indicates a variable has a large potential impact on the loss function and so is important.</p>
<p><code>Frequency</code> is a simpler way to measure the <code>Gain</code>. It just counts the number of times a feature is used in all generated trees. You should not use it (unless you know why you want to use it).</p>
<h2><a class="anchor" id="autotoc_md166"></a>
Plotting the feature importance</h2>
<p>All these things are nice, but it would be even better to plot the results. </p><pre class="fragment">xgb.plot.importance(importance_matrix = importance)
</pre><p> <img src="discoverYourData_files/figure-markdown_strict/unnamed-chunk-12-1.png" alt="" style="display: block; margin: auto;" class="inline"/></p>
<p>Running this line of code, you should get a bar chart showing the importance of the 6 features (containing the same data as the output we saw earlier, but displaying it visually for easier consumption). Note that <code>xgb.ggplot.importance</code> is also available for all the ggplot2 fans!</p>
<blockquote class="doxtable">
<p>&zwj;Depending of the dataset and the learning parameters you may have more than two clusters. Default value is to limit them to <code>10</code>, but you can increase this limit. Look at the function documentation for more information. </p>
</blockquote>
<p>According to the plot above, the most important features in this dataset to predict if the treatment will work are :</p>
<ul>
<li>An individual’s age;</li>
<li>Having received a placebo or not;</li>
<li>Gender;</li>
<li>Our generated feature AgeDiscret. We can see that its contribution is very low.</li>
</ul>
<h2><a class="anchor" id="autotoc_md167"></a>
Do these results make sense?</h2>
<p>Let’s check some <b>Chi2</b> between each of these features and the label.</p>
<p>Higher <b>Chi2</b> means better correlation. </p><pre class="fragment">c2 &lt;- chisq.test(df$Age, output_vector)
print(c2)

## 
##  Pearson's Chi-squared test
## 
## data:  df$Age and output_vector
## X-squared = 35.475, df = 35, p-value = 0.4458
</pre><p> The Pearson correlation between Age and illness disappearing is <b>35.47</b>. </p><pre class="fragment">c2 &lt;- chisq.test(df$AgeDiscret, output_vector)
print(c2)

## 
##  Pearson's Chi-squared test
## 
## data:  df$AgeDiscret and output_vector
## X-squared = 8.2554, df = 5, p-value = 0.1427
</pre><p> Our first simplification of Age gives a Pearson correlation of <b>8.26</b>. </p><pre class="fragment">c2 &lt;- chisq.test(df$AgeCat, output_vector)
print(c2)

## 
##  Pearson's Chi-squared test with Yates' continuity correction
## 
## data:  df$AgeCat and output_vector
## X-squared = 2.3571, df = 1, p-value = 0.1247
</pre><p> The perfectly random split we did between young and old at 30 years old has a low correlation of <b>2.36</b>. This suggests that, for the particular illness we are studying, the age at which someone is vulnerable to this disease is likely very different from 30.</p>
<p>Moral of the story: don’t let your <em>gut</em> lower the quality of your model.</p>
<p>In <em>data science</em>, there is the word <em>science</em> :-)</p>
<h1><a class="anchor" id="autotoc_md168"></a>
Conclusion</h1>
<p>As you can see, in general <em>destroying information by simplifying it won’t improve your model</em>. <b>Chi2</b> just demonstrates that.</p>
<p>But in more complex cases, creating a new feature from an existing one may help the algorithm and improve the model.</p>
<p>+The case studied here is not complex enough to show that. Check <a href="https://www.kaggle.com/">Kaggle website</a> for some challenging datasets.</p>
<p>Moreover, you can see that even if we have added some new features which are not very useful/highly correlated with other features, the boosting tree algorithm was still able to choose the best one (which in this case is the Age).</p>
<p>Linear models may not perform as well.</p>
<h1><a class="anchor" id="autotoc_md169"></a>
Special Note: What about Random Forests™?</h1>
<p>As you may know, the <a href="https://en.wikipedia.org/wiki/Random_forest">Random Forests</a> algorithm is cousin with boosting and both are part of the <a href="https://en.wikipedia.org/wiki/Ensemble_learning">ensemble learning</a> family.</p>
<p>Both train several decision trees for one dataset. The <em>main</em> difference is that in Random Forests, trees are independent and in boosting, the <code>N+1</code>-st tree focuses its learning on the loss (&lt;=&gt; what has not been well modeled by the tree <code>N</code>).</p>
<p>This difference can have an impact on a edge case in feature importance analysis: <em>correlated features</em>.</p>
<p>Imagine two features perfectly correlated, feature <code>A</code> and feature <code>B</code>. For one specific tree, if the algorithm needs one of them, it will choose randomly (true in both boosting and Random Forests).</p>
<p>However, in Random Forests this random choice will be done for each tree, because each tree is independent from the others. Therefore, approximately (and depending on your parameters) 50% of the trees will choose feature <code>A</code> and the other 50% will choose feature <code>B</code>. So the <em>importance</em> of the information contained in <code>A</code> and <code>B</code> (which is the same, because they are perfectly correlated) is diluted in <code>A</code> and <code>B</code>. So you won’t easily know this information is important to predict what you want to predict! It is even worse when you have 10 correlated features…</p>
<p>In boosting, when a specific link between feature and outcome have been learned by the algorithm, it will try to not refocus on it (in theory it is what happens, reality is not always that simple). Therefore, all the importance will be on feature <code>A</code> or on feature <code>B</code> (but not both). You will know that one feature has an important role in the link between the observations and the label. It is still up to you to search for the correlated features to the one detected as important if you need to know all of them.</p>
<p>If you want to try Random Forests algorithm, you can tweak XGBoost parameters!</p>
<p>For instance, to compute a model with 1000 trees, with a 0.5 factor on sampling rows and columns: </p><pre class="fragment">data(agaricus.train, package = 'xgboost')
data(agaricus.test, package = 'xgboost')
train &lt;- agaricus.train
test &lt;- agaricus.test

#Random Forest - 1000 trees
bst &lt;- xgboost(
    data = train$data
    , label = train$label
    , max_depth = 4
    , num_parallel_tree = 1000
    , subsample = 0.5
    , colsample_bytree = 0.5
    , nrounds = 1
    , objective = "binary:logistic"
)

## [1]  train-logloss:0.456201

#Boosting - 3 rounds
bst &lt;- xgboost(
    data = train$data
    , label = train$label
    , max_depth = 4
    , nrounds = 3
    , objective = "binary:logistic"
)

## [1]  train-logloss:0.444882 
## [2]  train-logloss:0.302428 
## [3]  train-logloss:0.212847
</pre> <blockquote class="doxtable">
<p>&zwj;Note that the parameter <code>round</code> is set to <code>1</code>. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<a href="https://www.stat.berkeley.edu/~breiman/RandomForests/cc_papers.htm"><b>Random Forests</b></a> is a trademark of Leo Breiman and Adele Cutler and is licensed exclusively to Salford Systems for the commercial release of the software. </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 14 2025 19:20:24 for Medial Code Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
