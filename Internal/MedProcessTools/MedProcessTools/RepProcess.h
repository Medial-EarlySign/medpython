#ifndef _REP_PROCESS_H_
#define _REP_PROCESS_H_

#include "InfraMed/InfraMed/InfraMed.h"
#include "InfraMed/InfraMed/MedPidRepository.h"
#include "MedProcessTools/MedProcessTools/MedSamples.h"
#include "MedUtils/MedUtils/MedUtils.h"
#include "MedProcessTools/MedProcessTools/MedProcessUtils.h"
#include "MedProcessTools/MedProcessTools/SerializableObject.h"
#include "MedProcessTools/MedProcessTools/MedValueCleaner.h"

#define DEFAULT_REP_CLNR_NTHREADS 8

//.......................................................................................
/** Define types of repository processors
*/
//.......................................................................................
/// Define types of repository processors
typedef enum {
	REP_PROCESS_MULTI, ///<"multi_processor" or "multi" to activate RepMultiProcessor
	REP_PROCESS_BASIC_OUTLIER_CLEANER,///<"basic_outlier_cleaner" or "basic_cln" to activate RepBasicOutlierCleaner
	REP_PROCESS_NBRS_OUTLIER_CLEANER,///<"nbrs_outlier_cleaner" or "nbrs_cln" to activate RepNbrsOutlierCleaner
	REP_PROCESS_CONFIGURED_OUTLIER_CLEANER,///<"configured_outlier_cleaner" or "conf_cln" to activate RepConfiguredOutlierCleaner
	REP_PROCESS_RULEBASED_OUTLIER_CLEANER,///<"rulebased_outlier_cleaner" or "rule_cln" to activate RepRuleBasedOutlierCleaner
	REP_PROCESS_CALC_SIGNALS,///<"calc_signals" or "calculator" to activate RepCalcSimpleSignals
	REP_PROCESS_COMPLETE, ///<"complete" to activate RepPanelCompleter
	REP_PROCESS_CHECK_REQ, ///<"req" or "requirements" check compliance with minimal requirement to activate RepCheckReq
	REP_PROCESS_SIM_VAL, ///<"sim_val" or "sim_val_handler" handle multiple simultanous values to activate RepSimValHandler
	REP_PROCESS_SIGNAL_RATE, ///<"signal_rate" combine complition for Drug rate based on Drug amount to actiate RepSignalRate
	REP_PROCESS_COMBINE, ///<"combine" flatten signals to 1 signal by dates. if conflict chooses based on order given. to actiate RepCombineSignals
	REP_PROCESS_SPLIT, ///<"split" split signal to two signals based on set of values - usefull for example to give diffrent rule\factor to diffrent drug units.  to actiate RepSplitSignal
	REP_PROCESS_AGGREGATE, ///<"aggregate" aggregate signal in sliding time window to calc some aggregation function. to actiate RepAggregateSignal
	REP_PROCESS_LAST
} RepProcessorTypes;

/** @file
* RepProcessor is the parent class for processing a MedRepository or PidDynamicRec\n
* Basic functionalities:\n
*		learn : learn the processoring parameters from a given list of ids and a rpository \n
*		apply : process a dynamic PidDynamicRec\n
*/
class RepProcessor : public SerializableObject {
public:

	RepProcessorTypes processor_type = REP_PROCESS_LAST; ///< type of repository processor

	unordered_set<string> req_signals; ///< names of signals required for processsing
	unordered_set<int> req_signal_ids; ///< ids of signals required for processing

	unordered_set<string> aff_signals; ///< names of signals affected by processing
	unordered_set<int> aff_signal_ids; ///< ids of signals affected by processing
	bool unconditional = false; ///< indicated that processor should ALWAYS be applied

	vector<string> attributes; ///< attributes generated by the processor (optional)

	virtual ~RepProcessor() { clear(); }
	virtual void clear() {  };

	/// <summary> 
	/// virtual signals are created only in rep processors but can be used by any rep processor that comes after
	/// or any feture generator as a regular signal.
	/// a virtual signal can be defined as one only once - in the rep processor that actually creates it.
	/// The other rep processors and feature generators using it are simply blind to the fact that it is virtual 
	/// and use it by name as a regular signal.
	/// </summary>
	vector<pair<string, int>> virtual_signals; ///< list of all virtual signals CREATED by this rep processor

	// create a new rep_processor
	/// <summary> create a new repository processor from name </summary>
	static RepProcessor *make_processor(string name);
	/// <summary> create a new repository processor from name and a parameters string</summary>
	static RepProcessor *make_processor(string type, string params);
	/// <summary> create a new repository processor from type </summary>
	static RepProcessor *make_processor(RepProcessorTypes type);
	/// <summary> create a new repository processor from type and a parameters string</summary>
	static RepProcessor *make_processor(RepProcessorTypes type, string params);

	/// <summary> create a new repository processor from parameters string which contains rp_type </summary>
	static RepProcessor *create_processor(string &params);

	/// <summary> initialize from a params object :  Should be implemented for inheriting classes that have parameters </summary>
	virtual int init(void *params) { return 0; };
	/// <summary> initialize from a map :  Should be implemented for inheriting classes that have parameters </summary>
	virtual int init(map<string, string>& mapper) { return 0; };
	/// <summary> initialize to default values :  Should be implemented for inheriting classes that have parameters </summary>
	virtual void init_defaults() {};

	/// <summary> set signal-name :  Should be implemented for inheriting classes that have signalName </summary>
	virtual void set_signal(const string& _signalName) { return; };

	/// <summary> set signal-name :  Should be implemented for inheriting classes that have signalId  </summary>
	virtual void set_signal_ids(MedDictionarySections& dict) { return; }

	// Required Signals functions : get all signals that are required by the processor
	/// <summary> Append required signal names to set : parent function just uses req_signals  </summary>
	virtual void get_required_signal_names(unordered_set<string>& signalNames);
	// Required Signals functions : get all signals that are required by the processor
	/// <summary> Append required signal names to set only if processor is actually required to produce any of preReqSignals : parent function just uses req_signals  </summary>
	virtual void get_required_signal_names(unordered_set<string>& signalNames, unordered_set<string> preReqSignals);

	/// <summary> Fill req_signal_ids : parent function just fills from req_signals </summary>
	virtual void set_required_signal_ids(MedDictionarySections& dict);

	/// <summary> rep processors CREATING virtual signals need to implement this: adding their signals to the pile </summary>
	virtual void add_virtual_signals(map<string, int> &_virtual_signals) { return; };

	// Required Signals functions : get all signals that are required by the processor
	/// <summary> Append required signal names to set : parent function just uses req_signals  </summary>
	virtual void get_required_signal_ids(unordered_set<int>& signalIds);
	// Required Signals functions : get all signals that are required by the processor
	/// <summary> Append required signal names to set only if processor is actually required to produce any of preReqSignals : parent function just uses req_signals  </summary>
	virtual void get_required_signal_ids(unordered_set<int>& signalIds, unordered_set<int> preReqSignals);

	// Affected Signals functions;
	/// <summary> Fill aff_signal_ids : parent function just fills from aff_signals </summary>
	virtual void set_affected_signal_ids(MedDictionarySections& dict);
	/// <summary>  Check if a signal is affected by processor </summray>
	/// <returns> true if affected, false if not </returns>
	inline bool is_signal_affected(int signalId) { return (aff_signal_ids.find(signalId) != aff_signal_ids.end()); }
	inline bool is_signal_affected(string& signalName) { return (aff_signals.find(signalName) != aff_signals.end()); }

	///Register section id to section name of new virtual signals
	virtual void register_virtual_section_name_id(MedDictionarySections& dict) { };

	// check filtering
	/// <summary> Check if processor (and 'sub'-processors within) should be applied according to set of required signals  </summray>
	/// <returns> true if processor is not required and can be filtered, false otherwise </returns>
	virtual bool filter(unordered_set<string>& reqSignals);

	/// <summary> Init required tables : Should be implemented for inheriting classes that have such tables </summary>
	virtual void init_tables(MedDictionarySections& dict, MedSignals& sigs) { return; }

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	virtual void init_attributes() { return; }

	// Learning
	/// <summary> learn processing model on a subset of samples. Apply set of preceeding processors on DynamicPidRec before learning : 
	// Should be implemented for inheriting classes that require learning </summary>
	virtual int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { return 0; };
	/// <summary> learn processing model on a subset of samples only if required. Apply set of preceeding processors on DynamicPidRec before learning : 
	// May be implemented for inheriting classes that require learning </summary>
	virtual int _conditional_learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors, unordered_set<int>& neededSignalIds);

	// Learning envelopes - Here because of issues with overloading and inheritance
	/// <summary> learn processing model on a subset of ids. Apply set of preceeding processors on DynamicPidRec before learning </summary>
	int learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { return _learn(rep, samples, prev_processors); };
	/// <summary> learn on all pids in repository, using fake samples - works only for repProcessors that ignore sample dates</summary>
	int learn(MedPidRepository& rep);
	/// <summary> learn on subset of samples without preceesing processors  </summary>
	int learn(MedPidRepository& rep, MedSamples& samples) { vector<RepProcessor *> temp;  return _learn(rep, samples, temp); }
	/// <summary> learn processing model on a subset of samples only if required. Apply set of preceeding processors on DynamicPidRec before learning : 
	virtual int conditional_learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors, unordered_set<int>& neededSignalIds) {
		return _conditional_learn(rep, samples, prev_processors, neededSignalIds);
	}
	/// <summary> learn processing model on a subset of ids only if required without preceesing processors </summary>
	int conditional_learn(MedPidRepository& rep, MedSamples& samples, unordered_set<int>& neededSignalIds) { vector<RepProcessor *> temp;  return _conditional_learn(rep, samples, temp, neededSignalIds); }

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes.
	/// <summary> if time_points is empty, processinng is done for each version for all times </summary>
	virtual int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_vals) { return -1; };
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points only if required : May be implemented for inheriting classes </summary>
	virtual int _conditional_apply(PidDynamicRec& rec, vector<int>& time_points, unordered_set<int>& neededSignalIds, vector<vector<float>>& attributes_vals);

	// next is needed for efficient applying of a single records
	virtual int _apply_simple(PidDynamicRec& rec, vector<int>& time_points) {
		vector<vector<float>> attributes_vals;
		return _apply(rec, time_points, attributes_vals);
	}

	// Applying envelopes - Here because of issues with overloading and inheritance
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points</summary>
	int apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_vals) { return _apply(rec, time_points, attributes_vals); }
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points only if required : if any of the signals in neededSignalIds is actually affected by processor </summary>
	int conditional_apply(PidDynamicRec& rec, vector<int>& time_points, unordered_set<int>& neededSignalIds, vector<vector<float>>& attributes_vals) {
		return _conditional_apply(rec, time_points, neededSignalIds, attributes_vals);
	}
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points given by samples </summary>
	int apply(PidDynamicRec& rec, MedIdSamples& samples);
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points given by samples only if required </summary>
	int conditional_apply(PidDynamicRec& rec, MedIdSamples& samples, unordered_set<int>& neededSignalIds);


	// debug prints
	/// used for debug prints, each inheriting class can overload this one to get a more precise debug print. rp_flag can be used to transfer verbosity levels.
	/// the default print just prints the basic type, etc.
	virtual void dprint(const string &pref, int rp_flag);


	// Serialization (including type)
	ADD_CLASS_NAME(RepProcessor)
	ADD_SERIALIZATION_FUNCS(processor_type, req_signals, aff_signals, unconditional)
	void *new_polymorphic(string derived_class_name);

	/// <summary> get size of processor + processor_type </summary>
	size_t get_processor_size();
	/// <summary> seialize processor + processor_type </summary>
	size_t processor_serialize(unsigned char *blob);

	/// <summary> optional printing of processor </summary>
	virtual void print() { fprintf(stderr, "No implementation for print()\n"); }
};

// Utilities
/// <summary> get RepProcessorTypes from name </summary>
RepProcessorTypes rep_processor_name_to_type(const string& procesor_name);

//.......................................................................................
/** RepMultiProcessor is a repository processor which contains a vector of simpler processors that can be
* learned/applied  in parallel. Useful for applying same cleaners on a set of signals, for example
*/
//.......................................................................................
class RepMultiProcessor : public RepProcessor {
public:
	vector<RepProcessor *> processors; ///< Set of processors

	vector<vector<int>> attributes_map; ///< A map from the index of an attribute in the list of attributes of each processor to the index in the list of attributes of the multi-processor

	/// <summary> Constructor </summary>
	RepMultiProcessor() { processor_type = REP_PROCESS_MULTI; };
	~RepMultiProcessor() { clear(); };

	void clear();


	/// <summary> Add processors to set  </summary>
	void add_processors_set(RepProcessorTypes type, vector<string>& signals);
	/// <summary> Add processors to set with initialization string  </summary>
	void add_processors_set(RepProcessorTypes type, vector<string>& signals, string init_string);
	/// <summary> Required Signals ids : Fill the member vector - req_signal_ids </summary>
	void set_required_signal_ids(MedDictionarySections& dict);
	/// <summary> Reporting back virtual signals if there are any </summary>
	void add_virtual_signals(map<string, int> &_virtual_signals);

	/// <summary> Required Signals names : Fill the unordered set signalNames </summary>
	void get_required_signal_names(unordered_set<string>& signalNames);
	/// <summary> Append required signal names to set only if processor is actually required to produce any of preReqSignals </summary>
	virtual void get_required_signal_names(unordered_set<string>& signalNames, unordered_set<string> preReqSignals);

	/// <summary> Required Signals ids : Fill the unordered set signalNames </summary>
	void get_required_signal_ids(unordered_set<int>& signalIds);
	/// <summary> Append required signal names to set only if processor is actually required to produce any of preReqSignals </summary>
	virtual void get_required_signal_ids(unordered_set<int>& signalIds, unordered_set<int> preReqSignals);

	/// <summary> Affected Signals : Fill the member set aff_signal_ids </summary>
	void set_affected_signal_ids(MedDictionarySections& dict);


	void register_virtual_section_name_id(MedDictionarySections& dict);
	// check filtering
	/// <summary> Check if processor (and 'sub'-processors within) should be applied according to set of required signals  </summray>
	/// <returns> true if processor is not required and can be filtered, false otherwise </returns>
	bool filter(unordered_set<string>& reqSignals);

	/// <summary> Set signal-ids for all linked signals </summary>
	void set_signal_ids(MedDictionarySections& dict);

	/// <summary> Init required tables : Should be implemented for inheriting classes that have such tables </summary>
	void init_tables(MedDictionarySections& dict, MedSignals& sigs) { for (RepProcessor * proc : processors) { proc->init_tables(dict, sigs); } }

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes();

	/// <summary> learn processors </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors);
	int _conditional_learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors, unordered_set<int>& neededSignalIds);

	/// <summary> Apply processors </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_vals);
	int _apply_simple(PidDynamicRec& rec, vector<int>& time_points);
	/// <summary> Apply processors that affect any of the needed signals </summary>
	int _conditional_apply(PidDynamicRec& rec, vector<int>& time_points, unordered_set<int>& neededSignals, vector<vector<float>>& attributes_mat);

	/// debug prints
	void dprint(const string &pref, int rp_flag);

	/// serialization
	ADD_CLASS_NAME(RepMultiProcessor)
	ADD_SERIALIZATION_FUNCS(processor_type, processors)

	/// <summary> Print processors information </summary>
	void print() { for (auto& processor : processors) processor->print(); }
};

#define DEF_REP_TRIMMING_SD_NUM 7
#define DEF_REP_REMOVING_SD_NUM 14

//.......................................................................................
/**
* A simple cleaner considering each value of a certain signal separatley
*/
//.......................................................................................
class RepBasicOutlierCleaner : public RepProcessor, public MedValueCleaner {
public:

	string signalName; 	///< name of signal to clean
	int signalId;	///< id of signal to clean
	int time_channel = 0; ///< time channel to consider in cleaning
	int val_channel = 0; ///< value cahnnel to consider in cleaning

	string nRem_attr = ""; ///< Attribute name (in sample) for number of removed. not recorded if empty
	string nTrim_attr = ""; ///< Attribute name (in sample) for number of trimmed. not recorded if empty
	string nRem_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of removed. not recorded if empty
	string nTrim_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of trimmed. not recorded if empty

	/// <summary> default constructor </summary>
	RepBasicOutlierCleaner() { init_defaults(); }
	/// <summary> default constructor + setting signal name </summary>
	RepBasicOutlierCleaner(const string& _signalName) { init_defaults(); signalId = -1; signalName = _signalName; init_lists(); }
	/// <summary> default constructor + setting signal name + initialize from string </summary>
	RepBasicOutlierCleaner(const string& _signalName, string init_string) { init_defaults(); signalId = -1; signalName = _signalName; init_from_string(init_string); }
	/// <summary> default constructor + setting signal name + initialize from parameters </summary>
	RepBasicOutlierCleaner(const string& _signalName, ValueCleanerParams *_params) { signalId = -1; signalName = _signalName; init_lists(); MedValueCleaner::init(_params); }

	/// <summary> Initialize to default values </summary>
	void init_defaults() {
		processor_type = REP_PROCESS_BASIC_OUTLIER_CLEANER;
		params.trimming_sd_num = DEF_REP_TRIMMING_SD_NUM; params.removing_sd_num = DEF_REP_REMOVING_SD_NUM; params.nbrs_sd_num = 0;
		params.take_log = 0;
		params.doTrim = params.doRemove = true;
		signalId = -1;
		params.type = VAL_CLNR_ITERATIVE;
		params.missing_value = MED_MAT_MISSING_VALUE;
	};

	/// <summary> Set signal name and fill affected and required signals sets </summary> 
	void set_signal(const string& _signalName) { signalId = -1; signalName = _signalName; init_lists(); }

	/// <summary> Set signal id </summary>
	void set_signal_ids(MedDictionarySections& dict) { signalId = dict.id(signalName); }

	/// <summary> Fill required- and affected-signals sets </summary>
	int init(void *processor_params) { return MedValueCleaner::init(processor_params); };
	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepBasicOutlierCleaner::init
	virtual int init(map<string, string>& mapper);
	/// Fill req- and aff-signals vectors
	void init_lists();

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes();

	/// <summary> learn cleaning boundaries </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);
	/// <summary> Learning : learn cleaning boundaries using MedValueCleaner's iterative approximation of moments </summary>
	int iterativeLearn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);
	/// <summary> Learning : learn cleaning boundaries using MedValueCleaner's quantile approximation of moments </summary>
	int quantileLearn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);

	/// <summary> Apply cleaning model </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	/// Serialization
	ADD_CLASS_NAME(RepBasicOutlierCleaner)
	ADD_SERIALIZATION_FUNCS(processor_type, signalName, time_channel, val_channel, req_signals, aff_signals, params.take_log, params.missing_value, params.doTrim, params.doRemove,
		trimMax, trimMin, removeMax, removeMin, nRem_attr, nTrim_attr, nRem_attr_suffix, nTrim_attr_suffix)

	/// <summary> Print processors information </summary>
		void print();
};

/** Parameters for configured outliers cleaner
*/
//.......................................................................................
class confRecord : public SerializableObject {
public:
	float logicalLow, logicalHigh, confirmedLow, confirmedHigh;
	string distLow, distHigh; //"none" "norm" or "log" 
	ADD_CLASS_NAME(confRecord)
	ADD_SERIALIZATION_FUNCS(logicalLow, logicalHigh, confirmedLow, confirmedHigh, distLow, distHigh)
};
MEDSERIALIZE_SUPPORT(confRecord)

//.......................................................................................
/** RepConfiguredOutlierCleaner is a simple cleaner considering each value of a certain signal separatley,
* but this time use configuration file that holds for each signal the logical values, statistically confirmed
* values  and distribution for relearning statistical values
*/
//.......................................................................................
class RepConfiguredOutlierCleaner : public  RepBasicOutlierCleaner {
public:

	string confFileName; ///< configuration file and mapping
	string cleanMethod; ///< cleaning method :  "logical" "confirmed" or "learned"
	map<string, confRecord> outlierParams; ///< a map from signal name to outliers parameters

	RepConfiguredOutlierCleaner() { init_defaults(); }

	/// <summary> Initialize to default values </summary>
	void init_defaults() {
		processor_type = REP_PROCESS_CONFIGURED_OUTLIER_CLEANER;
		params.trimming_sd_num = DEF_REP_TRIMMING_SD_NUM; params.removing_sd_num = DEF_REP_REMOVING_SD_NUM; params.nbrs_sd_num = 0;
		params.take_log = 0;
		params.doTrim = params.doRemove = true;
		signalId = -1;
		params.type = VAL_CLNR_ITERATIVE;
		params.missing_value = MED_MAT_MISSING_VALUE;
	};

	/// <summary> learn cleaning boundaries </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);

	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepConfiguredOutlierCleaner::init
	int init(map<string, string>& mapper);

	// Apply cleaning model -inheritted


	/// Serialization
	ADD_CLASS_NAME(RepConfiguredOutlierCleaner)
	ADD_SERIALIZATION_FUNCS(processor_type, signalName, time_channel, val_channel, req_signals, aff_signals, params.take_log, params.missing_value, params.doTrim, params.doRemove,
		trimMax, trimMin, removeMax, removeMin, confFileName, cleanMethod, outlierParams, nRem_attr, nTrim_attr, nRem_attr_suffix, nTrim_attr_suffix)

		void print();
};

void learnDistributionBorders(float& borderHi, float& borderLo, vector<float> filteredValues);
// a function that takes sorted vector of filtered values and estimates the +- 7 sd borders based on the center of distribution
// predefined calibration constants are used for estimation of the borders. 


/**
* A cleaner that is based on rules that describe relations of signal values to each other.\n
* This is a static cleaner ( no learning involved).\n
\n
Rules:\n
Rule1: BMI = Weight / Height ^ 2 * 1e4\n
Rule2:MCH = Hemoglobin / RBC\n
Rule3:MCV = Hematocrit / RBC\n
Rule4:MCHC - M = MCH / MCV\n
Rule5:Eosinophils# + Monocytes# + Basophils# + Lymphocytes# + Neutrophils# <= WBC\n
Rule6:MPV = Platelets_Hematocrit / Platelets\n
Rule7:UrineAlbumin <= UrineTotalProtein\n
Rule8:UrineAlbumin_over_Creatinine = UrineAlbumin / UrineCreatinine\n
Rule9:LDL + HDL <= Cholesterol\n
Rule10:NonHDLCholesterol + HDL = Cholesterol\n
Rule11:HDL_over_nonHDL = HDL / NonHDLCholesterol\n
Rule12:HDL_over_Cholesterol = HDL / Cholesterol\n
Rule13:HDL_over_LDL = HDL / LDL\n
Rule14:HDL_over_LDL = 1 / LDL_over_HDL\n
Rule15:Cholesterol_over_HDL = Cholesterol / HDL\n
Rule16:---------------------\n
Rule17:Cholesterol_over_HDL = 1 / HDL_over_Cholestrol\n
Rule18:LDL_over_HDL = LDL / HDL\n
Rule19:Albumin <= Protein_Total\n
Rule20:FreeT4 <= T4\n
Rule21:NRBC <= RBC\n
Rule22:CHADS2_VASC >= CHADS2\n
*/
class RepRuleBasedOutlierCleaner : public RepProcessor, public MedValueCleaner {
	// get multiple signals and clean them according to consistency  with other signals from same date
public:

	/// Signals to clean
	vector <string> signalNames;
	vector <int> signalIds;
	int time_channel = 0;
	int val_channel = 0;
	bool addRequiredSignals = false; ///< a flag stating if we want to load signals that are not in the cleaned signal list 
								   /// because they share a rule with the cleaned signals (set it in jason)
	vector<int> consideredRules;///< only rules in this list will be considered in this cleaner (read list from jason)
								/// rule number 0 means apply all rules. Empty vector: do nothing in this cleaner.

	string nRem_attr = ""; ///< Attribute name (in sample) for number of removed. not recorded if empty
	string nRem_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of removed. not recorded if empty

	float tolerance = 0.1F;

	/// static map from rule to participating signals
	map <int, vector<string>>rules2Signals = {
	{1,{"BMI","Weight","Height"}},
	{2,{"MCH", "Hemoglobin","RBC"}},
	{3,{"MCV","Hematocrit","RBC"} },
	{4,{"MCHC-M","MCH","MCV"}},
	{5,{"Eosinophils#","Monocytes#","Basophils#","Lymphocytes#","Neutrophils#","WBC" }},
	{6,{ "MPV","Platelets_Hematocrit","Platelets" }},
	{7,{"UrineAlbumin","UrineTotalProtein" }},
	{8,{"UrineAlbumin_over_Creatinine","UrineAlbumin","UrineCreatinine" }},
	{9,{"LDL","HDL","Cholesterol"}},
	{10,{"NonHDLCholesterol","HDL","Cholesterol"}},
	{11,{"HDL_over_nonHDL","HDL","NonHDLCholesterol"}},
	{12,{"HDL_over_Cholesterol","HDL","Cholesterol"}},
	{13,{"HDL_over_LDL","HDL","LDL"}},
	{14,{"HDL_over_LDL","LDL_over_HDL"}},
	{15,{"Cholesterol_over_HDL","Cholesterol","HDL"}},
	{17,{"Cholesterol_over_HDL","HDL_over_Cholestrol"}}, //rule 16 canceled
	{18,{"LDL_over_HDL","LDL","HDL"}},
	{19,{"Albumin","Protein_Total"}},
	{20,{"FreeT4","T4"}},
	{21,{"NRBC","RBC"}},
	{22,{"CHADS2","CHADS2_VASC"}}
	};

	vector <int> rulesToApply;

	/// Helpers
	set <int> reqSignalIds, affSignalIds;
	vector<vector<int >> rules_sids;
	vector<vector<bool>> affected_by_rules;

	// Constructors 
	RepRuleBasedOutlierCleaner() : RepProcessor() { init_defaults(); }

	void init_defaults() {
		processor_type = REP_PROCESS_RULEBASED_OUTLIER_CLEANER;

		params.take_log = 0;
		params.doRemove = true;

		params.type = VAL_CLNR_ITERATIVE;
		params.missing_value = MED_MAT_MISSING_VALUE;
	};

	// Init
	int init(void *processor_params) { return MedValueCleaner::init(processor_params); };

	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepRuleBasedOutlierCleaner::init
	int init(map<string, string>& mapper);

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes();

	///set signals
	void set_signal_ids(MedDictionarySections& dict);

	/// <summary> Init required tables : Should be implemented for inheriting classes that have such tables </summary>
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	// Learning
	/// <summary> In this class there's never learning - we init tables and return 0 immediately </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { init_tables(rep.dict, rep.sigs); return 0; };

	/// Apply cleaning model 
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	/// Serialization
	ADD_CLASS_NAME(RepRuleBasedOutlierCleaner)
	ADD_SERIALIZATION_FUNCS(processor_type, signalNames, time_channel, val_channel, addRequiredSignals, consideredRules, tolerance, req_signals, aff_signals, nRem_attr, nRem_attr_suffix)

private:
	///ruleUsvs hold the signals in the order they appear in the rule in the rules2Signals above
	/// apply the rule and return true if data is consistent with the rule
	bool  applyRule(int rule, vector <UniversalSigVec> ruleUsvs, vector <int >sPointer);

};

#define DEF_REP_NBRS_NBRS_SD_NUM 5
#define DEF_REP_NBRS_TRIM_SD_NUM 7
#define DEF_REP_NBRS_REMOVING_SD_NUM 14
//.......................................................................................
/** RepNbrsOutlierCleaner is cleaner that looks at the neighbourhood of a certain signal value
*/
//.......................................................................................
class RepNbrsOutlierCleaner : public RepProcessor, public MedValueCleaner {
public:

	string signalName; ///< name of signal to clean
	int signalId; ///< id of signal to clean
	int time_channel = 0; ///< time channel to consider in cleaning
	int val_channel = 0; ///< value cahnnel to consider in cleaning

	int nbr_time_width = 7; ///< size of neighborhood for defining neighboring values
	int nbr_time_unit = MedTime::Days; ///< time unit for defining neighboring values

	string nRem_attr = ""; ///< Attribute name (in sample) for number of removed. not recorded if empty
	string nTrim_attr = ""; ///< Attribute name (in sample) for number of trimmed. not recorded if empty
	string nRem_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of removed. not recorded if empty
	string nTrim_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of trimmed. not recorded if empty

	/// <summary> default constructor </summary>
	RepNbrsOutlierCleaner() { init_defaults(); }
	/// <summary> default constructor + setting signal name </summary>
	RepNbrsOutlierCleaner(const string& _signalName) { init_defaults(); signalId = -1; signalName = _signalName; init_lists(); }
	/// <summary> default constructor + setting signal name + initialize from string </summary>
	RepNbrsOutlierCleaner(const string& _signalName, string init_string) { init_defaults(); signalId = -1; signalName = _signalName; init_from_string(init_string); }
	/// <summary> default constructor + setting signal name + initialize from parameters </summary>
	RepNbrsOutlierCleaner(const string& _signalName, ValueCleanerParams *_params) { signalId = -1; signalName = _signalName; init_lists(); MedValueCleaner::init(_params); }

	/// <summary> Initialize to default values </summary>
	void init_defaults() {
		processor_type = REP_PROCESS_NBRS_OUTLIER_CLEANER;
		params.trimming_sd_num = DEF_REP_NBRS_TRIM_SD_NUM; params.removing_sd_num = DEF_REP_NBRS_REMOVING_SD_NUM; params.nbrs_sd_num = DEF_REP_NBRS_NBRS_SD_NUM;
		params.take_log = 0;
		params.doTrim = params.doRemove = true;
		signalId = -1;
		params.type = VAL_CLNR_ITERATIVE;
		params.missing_value = MED_MAT_MISSING_VALUE;
	};

	/// <summary> Set signal name and fill affected and required signals sets </summary> 
	void set_signal(const string& _signalName) { signalId = -1; signalName = _signalName; init_lists(); }

	/// <summary> Set signal id </summary>
	void set_signal_ids(MedDictionarySections& dict) { signalId = dict.id(signalName); }

	/// <summary> Fill required- and affected-signals sets </summary>
	int init(void *processor_params) { return MedValueCleaner::init(processor_params); };
	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepNbrsOutlierCleaner::init
	int init(map<string, string>& mapper);
	void init_lists();
	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes();

	/// <summary> learn cleaning boundaries </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);
	/// <summary> Learning : learn cleaning boundaries using MedValueCleaner's iterative approximation of moments </summary>
	int iterativeLearn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);
	/// <summary> Learning : learn cleaning boundaries using MedValueCleaner's quantile approximation of moments </summary>
	int quantileLearn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);

	/// <summary> Apply cleaning model </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	// Serialization
	ADD_CLASS_NAME(RepNbrsOutlierCleaner)
	ADD_SERIALIZATION_FUNCS(processor_type, signalName, time_channel, val_channel, req_signals, aff_signals, params.take_log, params.missing_value, params.doTrim, params.doRemove,
		trimMax, trimMin, removeMax, removeMin, nbr_time_unit, nbr_time_width, nbrsMax, nbrsMin, nRem_attr, nTrim_attr, nRem_attr_suffix, nTrim_attr_suffix)

		/// <summary> Print processors information </summary>
		void print();
};

//.......................................................................................
/** SimValHandler handles multiple values at the same time **/
//.......................................................................................

// Modes of handling multiple values at the same time
typedef enum {
	SIM_VAL_FIRST_VAL,
	SIM_VAL_LAST_VAL,
	SIM_VAL_MEAN,
	SIM_VAL_REM,
	SIM_VAL_REM_DIFF,
	MULT_VAL_LAST
} SimValHandleTypes;

class RepSimValHandler : public RepProcessor {
public:
	string signalName; 	///< name of signal to handle
	int signalId;	///< id of signal to handle
	vector<int> time_channels; ///< time channels to consider. All if empty
	SimValHandleTypes handler_type; ///< type of handling multiple-values

	int nValChannels; ///< number of value-channels, important for rem-diff and mean modes

	string nHandle_attr = ""; ///< Attribute name (in sample) for number of multiple-values handled. not recorded if empty
	string nHandle_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of multiple-values handled. not recorded if empty
	bool debug = false; ///<If True will print out till 3 examples for samples have been changed

	/// <summary> default constructor </summary>
	RepSimValHandler() { processor_type = REP_PROCESS_SIM_VAL; }
	/// <summary> default constructor + setting signal name </summary>
	RepSimValHandler(const string& _signalName) { processor_type = REP_PROCESS_SIM_VAL;; signalId = -1; signalName = _signalName; init_lists(); }
	/// <summary> default constructor + setting signal name + initialize from string </summary>
	RepSimValHandler(const string& _signalName, string init_string) { processor_type = REP_PROCESS_SIM_VAL; signalId = -1; signalName = _signalName; init_from_string(init_string); }

	/// <summary> Set signal name and fill affected and required signals sets </summary> 
	void set_signal(const string& _signalName) { signalId = -1; signalName = _signalName; init_lists(); }

	/// <summary> Set signal id </summary>
	void set_signal_ids(MedDictionarySections& dict) { signalId = dict.id(signalName); }

	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepSimValHandler::init
	virtual int init(map<string, string>& mapper);

	/// Fill req- and aff-signals vectors
	void init_lists();

	/// init tables - get time-channels
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes();

	/// <summary> Apply multiple-value handling </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	/// <summary> get SimHandleType from name </summary>
	/// @snippet RepProcess.cpp RepSimValHandler::get_sim_val_handle_type
	static SimValHandleTypes get_sim_val_handle_type(string& name);

	/// Serialization
	ADD_CLASS_NAME(RepSimValHandler)
	ADD_SERIALIZATION_FUNCS(processor_type, signalName, time_channels, req_signals, aff_signals, nHandle_attr, nHandle_attr_suffix, handler_type)
private:
	void handle_block(int start, int end, UniversalSigVec& usv, vector<int>& remove, int& nRemove, vector<pair<int, vector<float>>>& change, int& nChange, int& nTimes);
	int verbose_cnt = 0;
};

//.......................................................................................
/** RepPanelCompleter fills-in calculatable signal values. Enriching existing signals

	The available completions are currently -
		1. RedLineCompleter : MCV,HCT,RBC,MCH,MCHC,HGB
		2. WhiteLineCompleter : WBC,Eosonophils#,Eosonophils%,Neutrophils#,Neutrophils%,Lymphocytes#,Lymphocytes%,Monocytes#,Monocytes%,Basophils#,Basophils%
		3. PlateletsCompleter : Platelets, Platelets_Hematocrit and MPV
		4. LipidsCompleter : Cholesterol,LDL,HDL,HDL_over_Cholesterol,Cholesterol_over_HDL,HDL_over_LDL,LDL_over_HDL,NonHDLCholesterol,HDL_over_nonHDL,Tryglicerids
		5. eGFRCompleter : Creatinine, eGFR_CKD_EPI,eGFR_MDRD
		6. BMICompleter : BMI,Weight,Height

	Signals above are the default values. They can be changed, keeping the order, or set to NULL, in which case the completion is not-performed

*/
//.......................................................................................

typedef enum {
	REP_CMPLT_RED_LINE_PANEL, ///< complete values of the red blood line
	REP_CMPLT_WHITE_LINE_PANEL, ///< complete values of the white blood line
	REP_CMPLT_PLATELETS_PANEL, ///< complete values of platelets measurements
	REP_CMPLT_LIPIDS_PANEL, ///< complete lipd values
	REP_CMPLT_EGFR_PANEL, ///< complete eGFR values
	REP_CMPLT_BMI_PANEL, ///< complete BMI/HIGHT/WEIGHT values
	REP_CMPLT_GCS, ///< complete Glasgow Coma Score
	REP_CMPLT_LAST ///< Last not in use
} PanelCompleterTypes;

typedef enum {
	RED_PNL_MCV,
	RED_PNL_HCT,
	RED_PNL_RBC,
	RED_PNL_MCH,
	RED_PNL_MCHC,
	RED_PNL_HGB,
	RED_PNL_LAST
} RedPanelSignals;

typedef enum {
	WHITE_PNL_WBC,
	WHITE_PNL_EOS_N, WHITE_PNL_EOS_P,
	WHITE_PNL_NEU_N, WHITE_PNL_NEU_P,
	WHITE_PNL_LYM_N, WHITE_PNL_LYM_P,
	WHITE_PNL_MON_N, WHITE_PNL_MON_P,
	WHITE_PNL_BAS_N, WHITE_PNL_BAS_P,
	WHITE_PNL_LAST
} WhitePanelSignals;

typedef enum {
	PLT_PNL_PLTS,
	PLT_PNL_PLT_HCT,
	PLT_PNL_MPV,
	PLT_PNL_LAST
} PltsPanelSignals;

typedef enum {
	LIPIDS_PNL_CHOL,
	LIPIDS_PNL_LDL,
	LIPIDS_PNL_HDL,
	LIPIDS_PNL_HDL_OVER_CHOL,
	LIPIDS_PNL_CHOL_OVER_HDL,
	LIPIDS_PNL_HDL_OVER_LDL,
	LIPIDS_PNL_LDL_OVER_HDL,
	LIPIDS_PNL_NON_HDL_CHOL,
	LIPIDS_PNL_HDL_OVER_NON_HDL,
	LIPIDS_PNL_TRGS,
	LIPIDS_PNL_VLDL,
	LIPIDS_PNL_LAST
} LipidsPanelSignals;

typedef enum {
	EGFR_PNL_CRT,
	EGFR_PNL_CKD_EPI,
	EGFR_PNL_MDRD,
	EGFR_PNL_LAST
} eGFRPanelSignals;

typedef enum {
	BMI_PNL_BMI,
	BMI_PNL_WGT,
	BMI_PNL_HGT,
	BMI_PNL_HGT_SQR,
	BMI_PNL_LAST
} BMIPanelSignals;

typedef enum {
	GCS_PNL,
	GCS_PNL_EYE,
	GCS_PNL_MOTOR,
	GCS_PNL_VERBAL,
	GCS_PNL_LAST
} GCSPanelSignals;

/**
* A Repository panel completer for a complete panel of signals that are dependent and given on same time.
* TODO: add support for look in the past threshold
*/
class RepPanelCompleter : public RepProcessor {
public:
	// Signals for completions
	vector<vector<string> > panel_signal_names;
	vector<vector<int> > panel_signal_ids;

	// Extra signal ids
	int byearId, genderId;
	string genderSignalName;

	// Missing value indication
	float missing_val = MED_MAT_MISSING_VALUE;

	// Handling multiple values
	SimValHandleTypes sim_val_handler = SIM_VAL_LAST_VAL;

	// Signals meta-data : original and final resolution and factors
	string metadata_file;
	vector<vector<float> > original_sig_res, final_sig_res, sig_conversion_factors;

	RepPanelCompleter() { processor_type = REP_PROCESS_COMPLETE; init_defaults(); }

	/// @snippet RepProcess.cpp RepPanelCompleter::init
	int init(map<string, string>& mapper);

	/// <summary> initialize to default values :  Should be implemented for inheriting classes that have parameters </summary>
	void init_defaults();

	// Change signal names from defualt
	int update_signal_names(string panel, string& names);

	// Change panels to handle
	int update_panels(string& panels);

	// initialize signal ids
	void set_signal_ids(MedDictionarySections& dict);

	/// Fill req- and aff-signals vectors
	void init_lists();

	// Read conversion and resolution info
	void read_metadata();

	// Learning
	/// <summary> In this class there's never learning - we init tables and return 0 immediately </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { init_tables(rep.dict, rep.sigs); read_metadata(); return 0; };

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	// calculators implementations
	int apply_red_line_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_white_line_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_platelets_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_lipids_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_eGFR_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_BMI_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_GCS_completer(PidDynamicRec& rec, vector<int>& time_points);

	// Utilities
	// Age/Gender
	int perpare_for_age_and_gender(PidDynamicRec& rec, int& age, int& bYear, int& gender);

	// Rounding - take care of resolution both in original and final units 
	inline float completer_round(float value, float orig_res, float final_res, float factor) { return  set_resolution(set_resolution(value / factor, orig_res) * factor, final_res); }
	inline float set_resolution(float value, float res) { return res * (int)(value / res + 0.5); }

	// Generating panels from usvs
	void get_panels(vector<UniversalSigVec>& usvs, vector<int>& panel_times, vector<vector<float>>& panels, int time_limit, int panel_size);

	// Applying formulas
	int triplet_complete(vector<float>& panel, float factor, int x_idx, int y_idx, int z_idx, vector<float>& orig_res, vector<float>& final_res, vector<float>& conv, vector<int>& changed);
	int sum_complete(vector<float>& panel, int sum, vector<int>& summands, vector<float>& orig_res, vector<float>& final_res, vector<float>& conv, vector<int>& changed);
	int reciprocal_complete(vector<float>& panel, float factor, int x_idx, int y_idx, vector<float>& orig_res, vector<float>& final_res, vector<float>& conv, vector<int>& changed);
	int egfr_complete(vector<float>& panel, float age, int gender, vector<float>& orig_res, vector<float>& final_res, vector<float>& conv, vector<int>& changed);

	// Updating signals in dynamic-rec
	int update_signals(PidDynamicRec& rec, int iver, vector<vector<float>>& panels, vector<int>& panel_times, vector<int>& sigs_ids, vector<int>& changed);

	// serialization. meta-data file is kept for information but not used in apply
	void print();
	ADD_CLASS_NAME(RepPanelCompleter)
	ADD_SERIALIZATION_FUNCS(processor_type, panel_signal_names, missing_val, sim_val_handler, original_sig_res, final_sig_res, sig_conversion_factors, metadata_file, req_signals, aff_signals)

private:

	map<string, PanelCompleterTypes> panel2type = {
		{ "red_line",REP_CMPLT_RED_LINE_PANEL },
		{ "white_line",REP_CMPLT_WHITE_LINE_PANEL },
		{ "platelets",REP_CMPLT_PLATELETS_PANEL },
		{ "lipids",REP_CMPLT_LIPIDS_PANEL },
		{ "egfr",REP_CMPLT_EGFR_PANEL },
		{ "bmi",REP_CMPLT_BMI_PANEL },
		{ "gcs", REP_CMPLT_GCS }
	};

	// definitions and defaults for each panel-completer
	map<string, vector<string> > panel2signals = {
		{ "red_line", {"MCV","Hematocrit","RBC","MCH","MCHC-M","Hemoglobin"}},
		{ "white_line", {"WBC", "Eosinophils#", "Eosinophils%", "Neutrophils#", "Neutrophils%", "Lymphocytes#", "Lymphocytes%", "Monocytes#", "Monocytes%", "Basophils#", "Basophils%"}},
		{ "platelets", {"Platelets", "Platelets_Hematocrit","MPV"}},
		{ "lipids",{"Cholesterol", "LDL", "HDL", "HDL_over_Cholesterol", "Cholesterol_over_HDL", "HDL_over_LDL", "LDL_over_HDL", "NonHDLCholesterol", "HDL_over_nonHDL", "Triglycerides"}},
		{ "egfr", {"Creatinine","eGFR_CKD_EPI","eGFR_MDRD"}},
		{ "bmi", {"BMI","Weight","Height"}},
		{"gcs", {"GCS", "GCS_Eye", "GCS_Motor", "GCS_Verbal"}}
	};

	vector<int> white_panel_nums = { WHITE_PNL_EOS_N,WHITE_PNL_NEU_N,WHITE_PNL_LYM_N,WHITE_PNL_MON_N,WHITE_PNL_BAS_N };
	vector<int> white_panel_precs = { WHITE_PNL_EOS_P,WHITE_PNL_NEU_P,WHITE_PNL_LYM_P,WHITE_PNL_MON_P,WHITE_PNL_BAS_P };
	vector<int> chol_types1 = { LIPIDS_PNL_NON_HDL_CHOL,LIPIDS_PNL_HDL };
	vector<int> chol_types2 = { LIPIDS_PNL_LDL, LIPIDS_PNL_HDL, LIPIDS_PNL_VLDL };
	vector<int> gcs_panel_parts = { GCS_PNL_EYE,GCS_PNL_MOTOR,GCS_PNL_VERBAL };

	//Convertion map for GCS:
	unordered_map<int, int> eye_vals, verbal_vals, motor_vals;
	void convert_gcs_signals(vector<float> &panel);
};

//.......................................................................................


//.......................................................................................
/** RepCalcSimpleSignals is a rep processor containing several calculators to calculate new
	signals. It supports an internal list of calculators, and the user can select one of them.

	Each calculator can create one or more new virtual signals. Each of these has a specific type.
	The user can configure the virtual signal names, and can also pass a list of float parameters to
	the calculator, making it parametric.

	When adding a new calculator make sure to :
	(1) fill in the calc2defs map (as explained below), to define the calculator name, type, req signals,
		default virual names and their types, and default parameters.
	(2) add the new calculator type to the enum
	(3) write the matching _apply function for the specific calculator and make sure the general _apply calls it .

	NOTE: in RepCalcSimpleSignals there is NO learning. Calculated signals that have a learning stage should
		  be implmented in a separate class that will also have space to keep the learning process results.

	supported signals calculated (this will be also the virtual signal name):

	calc_eGFR : calculating EGFR (CKD_EPI formula) at each point in which Creatinine is available

*/
//.......................................................................................
/**
* Abstract class for calculator - has do_calc which recieves vector for values to calculate
*/
class SimpleCalculator : public SerializableObject {
public:
	float missing_value = (float)MED_MAT_MISSING_VALUE; ///< missing value 
	string calculator_name = ""; ///< just for debuging
	int work_channel = 0; ///< the working channel

	///init function of calculator
	virtual int init(map<string, string>& mapper) { return 0; };
	///validates correctness of inputs
	virtual void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const {};
	virtual float do_calc(const vector<float> &vals) const = 0; ///< the calc option
	virtual void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals) = 0; ///< list output signals with default naming
	/// init operator based on repo if needed
	virtual void init_tables(MedDictionarySections& dict, MedSignals& sigs, const vector<string> &input_signals) {};

	/// @snippet RepProcess.cpp SimpleCalculator::make_calculator
	static SimpleCalculator *make_calculator(const string &calc_type);

};

/**
* Calcs ratio between 2 inputs signals. has ability to power each signal before dividing and multiply by factor
* Calc is when we have V = { V1, V2 } as inputs. res := factor * V1^power_mone / V2^power_base
*/
class RatioCalculator : public SimpleCalculator {
public:
	float factor = 1; ///< factor multiply
	float power_base = 1; ///< power base input
	float power_mone = 1; ///< power mone input

	RatioCalculator() { calculator_name = "ratio"; };
	/// @snippet RepCalculators.cpp RatioCalculator::init
	int init(map<string, string>& mapper);

	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);
	float do_calc(const vector<float> &vals) const;
};

/**
* eGFR calculator based on Creatinine, Gender and Age.
* the signals input order is: Creatinine, Gender, Age
*/
class eGFRCalculator : public SimpleCalculator {
public:
	float ethnicity = 0; ///< ethnicity, for now only support 0

	eGFRCalculator() { calculator_name = "eGFR"; };
	/// @snippet RepCalculators.cpp eGFRCalculator::init
	int init(map<string, string>& mapper);
	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);
	float do_calc(const vector<float> &vals) const;
};

/**
* does log operation
*/
class logCalculator : public SimpleCalculator {
public:
	logCalculator() { calculator_name = "log"; };

	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);

	float do_calc(const vector<float> &vals) const;
};

/**
* does linear sum with factors on vector of input signals, has b0 as constant
* res := b0 + sum_sigma(i=1..N){ factor[i] * input[i]}
*/
class SumCalculator : public SimpleCalculator {
public:
	vector<float> factors; ///< the factors given by ","
	float b0 = 0; ///< a constant

	SumCalculator() { calculator_name = "sum"; };
	/// @snippet RepCalculators.cpp SumCalculator::init
	int init(map<string, string>& mapper);
	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);
	float do_calc(const vector<float> &vals) const;
};

/**
* A simple Range check that return in_range_val if within range and returns out_range_val
* if outside range.
*/
class RangeCalculator : public SimpleCalculator {
public:
	float min_range; ///< min range check
	float max_range; ///< max range check
	float in_range_val = 1; ///< return value when within range
	float out_range_val = 0; ///< return value when not within range

	RangeCalculator() { calculator_name = "range"; min_range = MED_MAT_MISSING_VALUE; max_range = MED_MAT_MISSING_VALUE; };
	/// @snippet RepCalculators.cpp RangeCalculator::init
	int init(map<string, string>& mapper);
	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);
	float do_calc(const vector<float> &vals) const;
};

/**
* A multiply operation with power on both arguments. V = { V1, V2 }
* res := V1^power_a * V2^power_b
*/
class MultiplyCalculator : public SimpleCalculator {
public:
	vector<float> powers; ///< power for args
	float b0 = 1; ///< init value

	MultiplyCalculator() { calculator_name = "multiply"; };
	/// @snippet RepCalculators.cpp MultiplyCalculator::init
	int init(map<string, string>& mapper);

	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);

	float do_calc(const vector<float> &vals) const;
};

/**
* A is in set operation which return binary output
* res := in_range_val if is in set otherwise out_range_val
*/
class SetCalculator : public SimpleCalculator {
public:
	vector<string> sets;
	float in_range_val = 1; ///< return value when within range
	float out_range_val = 0; ///< return value when not within range

	SetCalculator() { calculator_name = "set"; };
	/// @snippet RepCalculators.cpp SetCalculator::init
	int init(map<string, string>& mapper);

	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);
	void init_tables(MedDictionarySections& dict, MedSignals& sigs, const vector<string> &input_signals);

	float do_calc(const vector<float> &vals) const;
private:
	vector<char> Flags;
};

/**
* A simple class for calculating virtual signals. please reffer to SimpleCalculator to see which
* calculation are supported right now
*/
class RepCalcSimpleSignals : public RepProcessor {

public:
	vector<string> V_names; ///< names of signals created by the calculator (a calculator can create more than a single signal at a time)

	string calculator; ///< calculator asked for by user
	int work_channel = 0; ///< the channel to work on all singals - and save results to

	float missing_value = (float)MED_MAT_MISSING_VALUE;

	//vector<float> coeff; ///< it is possible to transfer a vector of params to the calculator, to enable parametric calculators.

	vector<string> signals; ///< it is possible to transfer a vector of required signals, to override default ones.
	//string timer_signal; ///< if given, used to detrmine time-points when virtual signal(s) are calculated
	//int timer_signal_id = -1; ///< id of timer-signal (if given)
	//string time_step_str; ///< string to describe time step (if given), and translate to time_step
	//int time_step = -1; ///< add times every time_step starting from the first time (timer or union), if given. must be positive
	int signals_time_unit = MedTime::Undefined; ///< Time unit of timer and all signals 

	int max_time_search_range = 0; ///< how much time we are allowed to look backward to calculate. to look forward we need to fix the function
	string calculator_init_params = ""; ///< string init params for calculator

	RepCalcSimpleSignals() { processor_type = REP_PROCESS_CALC_SIGNALS; }
	~RepCalcSimpleSignals();

	/// @snippet RepProcess.cpp RepCalcSimpleSignals::init
	int init(map<string, string>& mapper);

	// making sure V_ids and sigs_ids are initialized
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	void add_virtual_signals(map<string, int> &_virtual_signals);


	// Learning
	/// <summary> In this class there's never learning - we return 0 immediately </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { init_tables(rep.dict, rep.sigs); return 0; };

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();

	// serialization
	ADD_CLASS_NAME(RepCalcSimpleSignals)
	ADD_SERIALIZATION_FUNCS(processor_type, calculator, calculator_init_params, max_time_search_range, signals_time_unit,
		signals, V_names, req_signals, aff_signals, virtual_signals, work_channel)

private:
	// definitions and defaults for each calculator - all must be filled in for a new calculator

	/// from a calculator name to the list of required signals
	const map<string, vector<string>> calc2req_sigs = {
		//--------- level 1 - calculated from raw signals (level0)
		//the general hospital processor's signals must be overridden from outside
		{ "calc_eGFR", {"Creatinine", "GENDER", "BYEAR"}}
	};

	vector<int> V_ids; ///< ids of signals created by the calculator (for faster usage at run time: save name conversions)
	vector<int> sigs_ids; /// <ids of signals used as input by the calculator (for faster usage at run time: save name conversions)
	vector<bool> static_input_signals;

	int apply_calc_in_time(PidDynamicRec& rec, vector<int>& time_points);

	SimpleCalculator *calculator_logic = NULL;

};

/**
* Combines multiple signals to one signal. has ability to factorize each source signal
*/
class RepCombineSignals : public RepProcessor {
public:
	string output_name; ///< names of signal created by the processor
	vector<string> signals; ///< names of input signals used by the processor
	vector<float> factors; ///< factor for each signal

	RepCombineSignals() { processor_type = REP_PROCESS_COMBINE; output_name = ""; }

	void add_virtual_signals(map<string, int> &_virtual_signals);

	void register_virtual_section_name_id(MedDictionarySections& dict);

	/// @snippet RepProcess.cpp RepCombineSignals::init
	int init(map<string, string>& mapper);

	void init_tables(MedDictionarySections& dict, MedSignals& sigs);
	void set_required_signal_ids(MedDictionarySections& dict) {};
	void set_affected_signal_ids(MedDictionarySections& dict) {};

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();
	ADD_CLASS_NAME(RepCombineSignals)
	ADD_SERIALIZATION_FUNCS(processor_type, output_name, signals, factors, unconditional, req_signals, aff_signals, virtual_signals)
private:
	int v_out_sid = -1;
	vector<int> sigs_ids;
};

/**
* split signal based on set of values. supports only 2 channel for value, first is used
* for search in sets (and keeps the same value) 2 is being factorized
* output signal is haveing 1 time channel and 2 value channels
*/
class RepSplitSignal : public RepProcessor {
public:
	string input_name; ///< names of input signal used by the processor
	vector<string> names; ///< names of signal created by the processor
	vector<float> factors; ///< factor for each output signal
	vector<string> sets; ///< the sets to check if signal value is in set

	RepSplitSignal() { processor_type = REP_PROCESS_SPLIT; input_name = ""; }

	void add_virtual_signals(map<string, int> &_virtual_signals);
	void register_virtual_section_name_id(MedDictionarySections& dict);

	/// initialize signal ids
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);
	void set_required_signal_ids(MedDictionarySections& dict) {};
	void set_affected_signal_ids(MedDictionarySections& dict) {};

	/// @snippet RepProcess.cpp RepSplitSignal::init
	int init(map<string, string>& mapper);

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();
	ADD_CLASS_NAME(RepSplitSignal)
	ADD_SERIALIZATION_FUNCS(processor_type, input_name, names, factors, sets, unconditional, req_signals, aff_signals, virtual_signals)
private:
	int in_sid = -1;
	vector<int> V_ids;
	vector<char> Flags;
};

/**
* Normalize Signal Values by time - divide by time to calculate rate
*/
class RepSignalRate : public RepProcessor {
public:
	string output_name; ///< names of signals created by the completer
	string input_name; ///< names of input signals used by the completer
	int work_channel; ///< which channel to change and divide by time
	float factor; ///< additional constant factor 

	RepSignalRate() {
		processor_type = REP_PROCESS_SIGNAL_RATE; output_name = { "calc_drug_rate" };
		work_channel = 0;  factor = 1;
	}

	/// @snippet RepProcess.cpp RepSignalRate::init
	int init(map<string, string>& mapper);
	void add_virtual_signals(map<string, int> &_virtual_signals);
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);
	void register_virtual_section_name_id(MedDictionarySections& dict);
	void set_required_signal_ids(MedDictionarySections& dict) {};
	void set_affected_signal_ids(MedDictionarySections& dict) {};

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();
	ADD_CLASS_NAME(RepSignalRate)
	ADD_SERIALIZATION_FUNCS(processor_type, input_name, output_name, work_channel, factor, unconditional, req_signals, aff_signals, virtual_signals)
private:
	int v_out_sid = -1;
	int in_sid = -1;
};

/**
* An Aggregator for signal in sliding time window
*/
class RepAggregateSignal : public RepProcessor {
public:
	string signalName; ///< the name of inout signal
	string output_name; ///< the name of virtual signal
	int work_channel; ///< channel for value
	int start_time_channel;; ///< time channel for start time
	int end_time_channel; ///< time channel for end time
	float factor; ///< final factor to multiply
	int time_window; ///< back time window to search for
	int time_unit; ///< time unit
	float drop_missing_rate; ///< If missing time points beyond this threshold will drop measurement
	bool buffer_first; ///< If true will wait for first buffer to complete

	RepAggregateSignal() {
		processor_type = REP_PROCESS_AGGREGATE;
		work_channel = 0;
		start_time_channel = 0;
		end_time_channel = 0;
		factor = 1;
		time_unit = global_default_windows_time_unit;
		drop_missing_rate = 1;

		output_name = "calc_aggregate";
		time_window = 0;
		buffer_first = true;
	}

	/// @snippet RepProcess.cpp RepAggregateSignal::init
	int init(map<string, string>& mapper);
	void add_virtual_signals(map<string, int> &_virtual_signals);
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);
	void register_virtual_section_name_id(MedDictionarySections& dict);
	void set_required_signal_ids(MedDictionarySections& dict) {};
	void set_affected_signal_ids(MedDictionarySections& dict) {};

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be 
	/// implemented for all inheriting classes 
	/// </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();
	ADD_CLASS_NAME(RepAggregateSignal)
	ADD_SERIALIZATION_FUNCS(processor_type, signalName, output_name, work_channel, factor, time_window, time_unit,
		start_time_channel, end_time_channel, drop_missing_rate, buffer_first, unconditional, req_signals, aff_signals, virtual_signals)
private:
	int v_out_sid = -1;
	int in_sid = -1;
};

//.......................................................................................
/** RepCheckReq does not actually process the repository but rather check each
	sample for compliance with some requirment, and adjust the sample's corresponding
	attribute.
	Currently, possible minimal requirements are -
	1.	Given a set of signals and a time window, return how many signals
		do not appear within the window prior to the sample time
*/
//.......................................................................................

class RepCheckReq : public RepProcessor {

public:
	vector<string> signalNames; ///< Required signals
	vector<int> signalIds; ///< Required signals ids

	vector<int> time_channels; ///< signals' time channels
	int win_from = 0, win_to = 0; ///< window to consider ;
	int window_time_unit = MedTime::Days; ///< window time-unit

	string attrName = "MissingReq"; ///< attribute name (set to 1 if compliant)

	// Helper
	vector<int> sig_time_units;

	/// <summary> constructor </summary>
	RepCheckReq() { processor_type = REP_PROCESS_CHECK_REQ; unconditional = true; }

	/// @snippet RepProcess.cpp RepCheckReq::init
	int init(map<string, string>& mapper);

	/// <summary> Set signal id </summary>
	void set_signal_ids(MedDictionarySections& dict);

	/// <summary> Fill req- and aff-signals vectors </summary>
	void init_lists();

	/// <summary> initialize time-nits </summary>
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes() { attributes = { attrName }; }

	// Learning - none done

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	// serialization.
	ADD_CLASS_NAME(RepCheckReq)
	ADD_SERIALIZATION_FUNCS(processor_type, signalNames, time_channels, win_from, win_to, window_time_unit, attrName, req_signals)
};

//.......................................................................................
//.......................................................................................
// Utility Functions
//.......................................................................................
//.......................................................................................

/// <summary> Get values of a signal from a set of samples applying a set of preceeding cleaners </summary>
int get_values(MedRepository& rep, MedSamples& samples, int signalId, int time_channel, int val_channel, float range_min, float range_max, vector<float>& values,
	vector<RepProcessor *>& prev_cleaners);
/// <summary> Get values of a signal from a set of samples </summary>
int get_values(MedRepository& rep, MedSamples& samples, int signalId, int time_channel, int val_channel, float range_min, float range_max, vector<float>& values);

//=======================================
// Joining the MedSerialze wagon
//=======================================
MEDSERIALIZE_SUPPORT(RepProcessor)
MEDSERIALIZE_SUPPORT(RepMultiProcessor)
MEDSERIALIZE_SUPPORT(RepBasicOutlierCleaner)
MEDSERIALIZE_SUPPORT(RepRuleBasedOutlierCleaner)
MEDSERIALIZE_SUPPORT(RepConfiguredOutlierCleaner)
MEDSERIALIZE_SUPPORT(RepNbrsOutlierCleaner)
MEDSERIALIZE_SUPPORT(RepCalcSimpleSignals)
MEDSERIALIZE_SUPPORT(RepSimValHandler)
MEDSERIALIZE_SUPPORT(RepPanelCompleter)
MEDSERIALIZE_SUPPORT(RepCombineSignals)
MEDSERIALIZE_SUPPORT(RepSplitSignal)
MEDSERIALIZE_SUPPORT(RepSignalRate)
MEDSERIALIZE_SUPPORT(RepAggregateSignal)
MEDSERIALIZE_SUPPORT(RepCheckReq)
#endif
