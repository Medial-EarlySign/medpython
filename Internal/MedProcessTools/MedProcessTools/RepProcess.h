#ifndef _REP_PROCESS_H_
#define _REP_PROCESS_H_

#include "InfraMed/InfraMed/InfraMed.h"
#include "InfraMed/InfraMed/MedPidRepository.h"
#include "MedProcessTools/MedProcessTools/MedSamples.h"
#include "MedProcessTools/MedProcessTools/MedProcessUtils.h"
#include <SerializableObject/SerializableObject/SerializableObject.h>
#include "MedProcessTools/MedProcessTools/MedValueCleaner.h"
#include <MedMat/MedMat/MedMat.h>


#define DEFAULT_REP_CLNR_NTHREADS 8

//.......................................................................................
/** Define types of repository processors
*/
//.......................................................................................
/// Define types of repository processors
typedef enum {
	REP_PROCESS_MULTI, ///<"multi_processor" or "multi" to activate RepMultiProcessor
	REP_PROCESS_BASIC_OUTLIER_CLEANER,///<"basic_outlier_cleaner" or "basic_cln" to activate RepBasicOutlierCleaner
	REP_PROCESS_NBRS_OUTLIER_CLEANER,///<"nbrs_outlier_cleaner" or "nbrs_cln" to activate RepNbrsOutlierCleaner
	REP_PROCESS_CONFIGURED_OUTLIER_CLEANER,///<"configured_outlier_cleaner" or "conf_cln" to activate RepConfiguredOutlierCleaner
	REP_PROCESS_RULEBASED_OUTLIER_CLEANER,///<"rulebased_outlier_cleaner" or "rule_cln" to activate RepRuleBasedOutlierCleaner
	REP_PROCESS_CALC_SIGNALS,///<"calc_signals" or "calculator" to activate RepCalcSimpleSignals
	REP_PROCESS_COMPLETE, ///<"complete" to activate RepPanelCompleter
	REP_PROCESS_CHECK_REQ, ///<"req" or "requirements" check compliance with minimal requirement to activate RepCheckReq
	REP_PROCESS_SIM_VAL, ///<"sim_val" or "sim_val_handler" handle multiple simultanous values to activate RepSimValHandler
	REP_PROCESS_SIGNAL_RATE, ///<"signal_rate" combine complition for Drug rate based on Drug amount to actiate RepSignalRate
	REP_PROCESS_COMBINE, ///<"combine" flatten signals to 1 signal by dates. if conflict chooses based on order given. to actiate RepCombineSignals
	REP_PROCESS_SPLIT, ///<"split" split signal to two signals based on set of values - usefull for example to give diffrent rule\factor to diffrent drug units.  to actiate RepSplitSignal
	REP_PROCESS_AGGREGATION_PERIOD, ///<"aggregation_period"
	REP_PROCESS_BASIC_RANGE_CLEANER,///<"basic_range_cleaner" or "range_cln" to activate RepBasicRangeCleaner
	REP_PROCESS_AGGREGATE, ///<"aggregate" aggregate signal in sliding time window to calc some aggregation function. to actiate RepAggregateSignal
	REP_PROCESS_HISTORY_LIMIT, ///<"history_limit" chomps the history for a signal to be at a certain given time window relative to the prediction point. creates RepHistoryLimit
	REP_PROCESS_CREATE_REGISTRY, ///<"create_registry" creates a registry signal (TimeRange to values). creates RepCreateRegistry
	REP_PROCESS_LAST
} RepProcessorTypes;

/** @file
* RepProcessor is the parent class for processing a MedRepository or PidDynamicRec\n
* Basic functionalities:\n
*		learn : learn the processoring parameters from a given list of ids and a rpository \n
*		apply : process a dynamic PidDynamicRec\n
*/
class RepProcessor : public SerializableObject {
public:

	RepProcessorTypes processor_type = REP_PROCESS_LAST; ///< type of repository processor

	unordered_set<string> req_signals; ///< names of signals required for processsing
	unordered_set<int> req_signal_ids; ///< ids of signals required for processing

	unordered_set<string> aff_signals; ///< names of signals affected by processing
	unordered_set<int> aff_signal_ids; ///< ids of signals affected by processing
	bool unconditional = false; ///< indicated that processor should ALWAYS be applied

	vector<string> attributes; ///< attributes generated by the processor (optional)

	virtual ~RepProcessor() { clear(); }
	virtual void clear() {  };

	/// <summary> 
	/// virtual signals are created only in rep processors but can be used by any rep processor that comes after
	/// or any feture generator as a regular signal.
	/// a virtual signal can be defined as one only once - in the rep processor that actually creates it.
	/// The other rep processors and feature generators using it are simply blind to the fact that it is virtual 
	/// and use it by name as a regular signal.
	/// </summary>
	vector<pair<string, int>> virtual_signals; ///< list of all virtual signals CREATED by this rep processor

	// create a new rep_processor
	/// <summary> create a new repository processor from name </summary>
	static RepProcessor *make_processor(string name);
	/// <summary> create a new repository processor from name and a parameters string</summary>
	static RepProcessor *make_processor(string type, string params);
	/// <summary> create a new repository processor from type </summary>
	static RepProcessor *make_processor(RepProcessorTypes type);
	/// <summary> create a new repository processor from type and a parameters string</summary>
	static RepProcessor *make_processor(RepProcessorTypes type, string params);

	/// <summary> create a new repository processor from parameters string which contains rp_type </summary>
	static RepProcessor *create_processor(string &params);

	/// <summary> initialize from a params object :  Should be implemented for inheriting classes that have parameters </summary>
	virtual int init(void *params) { return 0; };
	/// <summary> initialize from a map :  Should be implemented for inheriting classes that have parameters </summary>
	virtual int init(map<string, string>& mapper) { return 0; };
	/// <summary> initialize to default values :  Should be implemented for inheriting classes that have parameters </summary>
	virtual void init_defaults() {};

	/// <summary> set signal-name :  Should be implemented for inheriting classes that have signalName </summary>
	virtual void set_signal(const string& _signalName) { return; };

	/// <summary> set signal-name :  Should be implemented for inheriting classes that have signalId  </summary>
	virtual void set_signal_ids(MedSignals& sigs) { return; }

	// Required Signals functions : get all signals that are required by the processor
	/// <summary> Append required signal names to set : parent function just uses req_signals  </summary>
	virtual void get_required_signal_names(unordered_set<string>& signalNames);
	// Required Signals functions : get all signals that are required by the processor
	/// <summary> Append required signal names to set only if processor is actually required to produce any of preReqSignals : parent function just uses req_signals  </summary>
	virtual void get_required_signal_names(unordered_set<string>& signalNames, unordered_set<string> preReqSignals);

	/// <summary> Fill req_signal_ids : parent function just fills from req_signals </summary>
	virtual void set_required_signal_ids(MedDictionarySections& dict);

	/// <summary> rep processors CREATING virtual signals need to implement this: adding their signals to the pile </summary>
	virtual void add_virtual_signals(map<string, int> &_virtual_signals) { for (auto &v : virtual_signals) _virtual_signals[v.first] = v.second; };

	// Required Signals functions : get all signals that are required by the processor
	/// <summary> Append required signal names to set : parent function just uses req_signals  </summary>
	virtual void get_required_signal_ids(unordered_set<int>& signalIds);
	// Required Signals functions : get all signals that are required by the processor
	/// <summary> Append required signal names to set only if processor is actually required to produce any of preReqSignals : parent function just uses req_signals  </summary>
	virtual void get_required_signal_ids(unordered_set<int>& signalIds, unordered_set<int> preReqSignals);

	// Affected Signals functions;
	/// <summary> Fill aff_signal_ids : parent function just fills from aff_signals </summary>
	virtual void set_affected_signal_ids(MedDictionarySections& dict);
	/// <summary>  Check if a signal is affected by processor </summray>
	/// <returns> true if affected, false if not </returns>
	inline bool is_signal_affected(int signalId) { return (aff_signal_ids.find(signalId) != aff_signal_ids.end()); }
	inline bool is_signal_affected(string& signalName) { return (aff_signals.find(signalName) != aff_signals.end()); }

	/// <summary> make changes to RepProcessor according to available signals in Repository </summary>
	virtual void fit_for_repository(MedPidRepository& rep) {};

	///Register section id to section name of new virtual signals
	virtual void register_virtual_section_name_id(MedDictionarySections& dict) { };

	// check filtering
	/// <summary> Check if processor (and 'sub'-processors within) should be applied according to set of required signals  </summray>
	/// <returns> true if processor is not required and can be filtered, false otherwise </returns>
	virtual bool filter(unordered_set<string>& reqSignals);

	/// <summary> Init required tables : Should be implemented for inheriting classes that have such tables </summary>
	virtual void init_tables(MedDictionarySections& dict, MedSignals& sigs) { return; }

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	virtual void init_attributes() { return; }

	// Learning
	/// <summary> learn processing model on a subset of samples. Apply set of preceeding processors on DynamicPidRec before learning : 
	// Should be implemented for inheriting classes that require learning </summary>
	virtual int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { return 0; };
	/// <summary> learn processing model on a subset of samples only if required. Apply set of preceeding processors on DynamicPidRec before learning : 
	// May be implemented for inheriting classes that require learning </summary>
	virtual int _conditional_learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors, unordered_set<int>& neededSignalIds);

	// Learning envelopes - Here because of issues with overloading and inheritance
	/// <summary> learn processing model on a subset of ids. Apply set of preceeding processors on DynamicPidRec before learning </summary>
	int learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { return _learn(rep, samples, prev_processors); };
	/// <summary> learn on all pids in repository, using fake samples - works only for repProcessors that ignore sample dates</summary>
	int learn(MedPidRepository& rep);
	/// <summary> learn on subset of samples without preceesing processors  </summary>
	int learn(MedPidRepository& rep, MedSamples& samples) { vector<RepProcessor *> temp;  return _learn(rep, samples, temp); }
	/// <summary> learn processing model on a subset of samples only if required. Apply set of preceeding processors on DynamicPidRec before learning : 
	virtual int conditional_learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors, unordered_set<int>& neededSignalIds) {
		return _conditional_learn(rep, samples, prev_processors, neededSignalIds);
	}
	/// <summary> learn processing model on a subset of ids only if required without preceesing processors </summary>
	int conditional_learn(MedPidRepository& rep, MedSamples& samples, unordered_set<int>& neededSignalIds) { vector<RepProcessor *> temp;  return _conditional_learn(rep, samples, temp, neededSignalIds); }

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes.
	/// <summary> if time_points is empty, processinng is done for each version for all times </summary>
	virtual int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_vals) { return -1; };
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points only if required : May be implemented for inheriting classes </summary>
	virtual int _conditional_apply(PidDynamicRec& rec, vector<int>& time_points, unordered_set<int>& neededSignalIds, vector<vector<float>>& attributes_vals);

	// next is needed for efficient applying of a single records
	virtual int _apply_simple(PidDynamicRec& rec, vector<int>& time_points) {
		vector<vector<float>> attributes_vals;
		return _apply(rec, time_points, attributes_vals);
	}

	// Applying envelopes - Here because of issues with overloading and inheritance
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points</summary>
	int apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_vals) { return _apply(rec, time_points, attributes_vals); }
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points only if required : if any of the signals in neededSignalIds is actually affected by processor </summary>
	int conditional_apply(PidDynamicRec& rec, vector<int>& time_points, unordered_set<int>& neededSignalIds, vector<vector<float>>& attributes_vals) {
		return _conditional_apply(rec, time_points, neededSignalIds, attributes_vals);
	}
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points given by samples </summary>
	int apply(PidDynamicRec& rec, MedIdSamples& samples);
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points given by samples only if required </summary>
	int conditional_apply(PidDynamicRec& rec, MedIdSamples& samples, unordered_set<int>& neededSignalIds);
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points given by samples only if required, not affecting attributes</summary>
	int conditional_apply_without_attributes(PidDynamicRec& rec, const MedIdSamples& samples, unordered_set<int>& neededSignalIds);


	// debug prints
	/// used for debug prints, each inheriting class can overload this one to get a more precise debug print. rp_flag can be used to transfer verbosity levels.
	/// the default print just prints the basic type, etc.
	virtual void dprint(const string &pref, int rp_flag);

	///<summary>
	/// prints summary of rep_processor job. optional, called after apply.
	/// for example - prints how many values were cleaned
	///</summary>
	virtual void make_summary() {};

	// Serialization (including type)
	ADD_CLASS_NAME(RepProcessor)
		ADD_SERIALIZATION_FUNCS(processor_type, req_signals, aff_signals, unconditional)
		void *new_polymorphic(string derived_class_name);

	/// <summary> get size of processor + processor_type </summary>
	size_t get_processor_size();
	/// <summary> seialize processor + processor_type </summary>
	size_t processor_serialize(unsigned char *blob);

	/// <summary> optional printing of processor </summary>
	virtual void print() { fprintf(stderr, "No implementation for print()\n"); }
};

// Utilities
/// <summary> get RepProcessorTypes from name </summary>
RepProcessorTypes rep_processor_name_to_type(const string& procesor_name);

//.......................................................................................
/** RepMultiProcessor is a repository processor which contains a vector of simpler processors that can be
* learned/applied  in parallel. Useful for applying same cleaners on a set of signals, for example
*/
//.......................................................................................
class RepMultiProcessor : public RepProcessor {
public:
	vector<RepProcessor *> processors; ///< Set of processors

	vector<vector<int>> attributes_map; ///< A map from the index of an attribute in the list of attributes of each processor to the index in the list of attributes of the multi-processor

	/// <summary> Constructor </summary>
	RepMultiProcessor() { processor_type = REP_PROCESS_MULTI; };
	~RepMultiProcessor() { clear(); };

	void clear();


	/// <summary> Add processors to set  </summary>
	void add_processors_set(RepProcessorTypes type, vector<string>& signals);
	/// <summary> Add processors to set with initialization string  </summary>
	void add_processors_set(RepProcessorTypes type, vector<string>& signals, string init_string);
	/// <summary> Required Signals ids : Fill the member vector - req_signal_ids </summary>
	void set_required_signal_ids(MedDictionarySections& dict);
	/// <summary> Reporting back virtual signals if there are any </summary>
	void add_virtual_signals(map<string, int> &_virtual_signals);

	/// <summary> Required Signals names : Fill the unordered set signalNames </summary>
	void get_required_signal_names(unordered_set<string>& signalNames);
	/// <summary> Append required signal names to set only if processor is actually required to produce any of preReqSignals </summary>
	virtual void get_required_signal_names(unordered_set<string>& signalNames, unordered_set<string> preReqSignals);

	/// <summary> Required Signals ids : Fill the unordered set signalNames </summary>
	void get_required_signal_ids(unordered_set<int>& signalIds);
	/// <summary> Append required signal names to set only if processor is actually required to produce any of preReqSignals </summary>
	virtual void get_required_signal_ids(unordered_set<int>& signalIds, unordered_set<int> preReqSignals);

	/// <summary> Affected Signals : Fill the member set aff_signal_ids </summary>
	void set_affected_signal_ids(MedDictionarySections& dict);


	void register_virtual_section_name_id(MedDictionarySections& dict);
	// check filtering
	/// <summary> Check if processor (and 'sub'-processors within) should be applied according to set of required signals  </summray>
	/// <returns> true if processor is not required and can be filtered, false otherwise </returns>
	bool filter(unordered_set<string>& reqSignals);

	/// <summary> Set signal-ids for all linked signals </summary>
	void set_signal_ids(MedSignals& sigs);

	/// <summary> Init required tables : Should be implemented for inheriting classes that have such tables </summary>
	void init_tables(MedDictionarySections& dict, MedSignals& sigs) { for (RepProcessor * proc : processors) { proc->init_tables(dict, sigs); } }

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes();

	/// <summary> learn processors </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors);
	int _conditional_learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors, unordered_set<int>& neededSignalIds);

	/// <summary> Apply processors </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_vals);
	int _apply_simple(PidDynamicRec& rec, vector<int>& time_points);
	/// <summary> Apply processors that affect any of the needed signals </summary>
	int _conditional_apply(PidDynamicRec& rec, vector<int>& time_points, unordered_set<int>& neededSignals, vector<vector<float>>& attributes_mat);

	/// <summary> make changes to RepProcessor according to available signals in Repository </summary>
	void fit_for_repository(MedPidRepository& rep);

	/// debug prints
	void dprint(const string &pref, int rp_flag);

	void make_summary();

	/// serialization
	ADD_CLASS_NAME(RepMultiProcessor)
		ADD_SERIALIZATION_FUNCS(processor_type, processors)

		/// <summary> Print processors information </summary>
		void print() { for (auto& processor : processors) processor->print(); }
};

#define DEF_REP_TRIMMING_SD_NUM 7
#define DEF_REP_REMOVING_SD_NUM 14

class remove_stats {
public:
	int total_removed = 0, total_pids_touched = 0;
	int total_records = 0, total_pids = 0;

	/// restarts stats for new apply
	void restart();

	/// prints stats to screen for cleaner
	void print_summary(const string &cleaner_info, const string &signal_name,
		int minimal_pid_cnt, float print_summary_critical_cleaned, bool prnt_flg) const;
};

//.......................................................................................
/**
* A simple cleaner considering each value of a certain signal separatley
*/
//.......................................................................................
class RepBasicOutlierCleaner : public RepProcessor, public MedValueCleaner {
private:
	ofstream log_file;
	remove_stats _stats;
	bool is_categ = false;
public:

	string signalName; 	///< name of signal to clean
	int signalId;	///< id of signal to clean
	int time_channel = 0; ///< time channel to consider in cleaning
	int val_channel = 0; ///< value cahnnel to consider in cleaning

	string nRem_attr = ""; ///< Attribute name (in sample) for number of removed. not recorded if empty
	string nTrim_attr = ""; ///< Attribute name (in sample) for number of trimmed. not recorded if empty
	string nRem_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of removed. not recorded if empty
	string nTrim_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of trimmed. not recorded if empty
	string verbose_file; ///< cleaning output_file for debuging

	bool print_summary = false; ///< If true will always print clean summary
	float print_summary_critical_cleaned = (float)0.05; ///< beyond this value will print summary

	/// <summary> default constructor </summary>
	RepBasicOutlierCleaner() { init_defaults(); }
	/// <summary> default constructor + setting signal name </summary>
	RepBasicOutlierCleaner(const string& _signalName) { init_defaults(); signalId = -1; signalName = _signalName; init_lists(); }
	/// <summary> default constructor + setting signal name + initialize from string </summary>
	RepBasicOutlierCleaner(const string& _signalName, string init_string) { init_defaults(); signalId = -1; signalName = _signalName; init_from_string(init_string); }
	/// <summary> default constructor + setting signal name + initialize from parameters </summary>
	RepBasicOutlierCleaner(const string& _signalName, ValueCleanerParams *_params) { signalId = -1; signalName = _signalName; init_lists(); MedValueCleaner::init(_params); }

	/// <summary> Initialize to default values </summary>
	void init_defaults() {
		processor_type = REP_PROCESS_BASIC_OUTLIER_CLEANER;
		params.trimming_sd_num = DEF_REP_TRIMMING_SD_NUM; params.removing_sd_num = DEF_REP_REMOVING_SD_NUM; params.nbrs_sd_num = 0;
		params.take_log = 0;
		params.doTrim = params.doRemove = true;
		signalId = -1;
		params.type = VAL_CLNR_ITERATIVE;
		params.missing_value = MED_MAT_MISSING_VALUE;
		verbose_file = "";
	};

	/// <summary> Set signal name and fill affected and required signals sets </summary> 
	void set_signal(const string& _signalName) { signalId = -1; signalName = _signalName; init_lists(); }

	/// <summary> Set signal id </summary>
	virtual void set_signal_ids(MedSignals& sigs);

	/// <summary> Fill required- and affected-signals sets </summary>
	int init(void *processor_params) { return MedValueCleaner::init(processor_params); };
	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepBasicOutlierCleaner::init
	virtual int init(map<string, string>& mapper);
	/// Fill req- and aff-signals vectors
	void init_lists();

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes();

	/// <summary> learn cleaning boundaries </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);
	/// <summary> Learning : learn cleaning boundaries using MedValueCleaner's iterative approximation of moments </summary>
	int iterativeLearn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);
	/// <summary> Learning : learn cleaning boundaries using MedValueCleaner's quantile approximation of moments </summary>
	int quantileLearn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);

	/// <summary> Apply cleaning model </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	virtual ~RepBasicOutlierCleaner() { if (!verbose_file.empty() && log_file.is_open()) log_file.close(); };

	/// <summary> Debug printing </summary>
	void print() { dprint("", 1); }
	void dprint(const string &pref, int rp_flag);

	void make_summary();

	/// Serialization
	ADD_CLASS_NAME(RepBasicOutlierCleaner)
		ADD_SERIALIZATION_FUNCS(processor_type, signalName, time_channel, val_channel, req_signals, aff_signals, params.take_log, params.missing_value, params.doTrim, params.doRemove,
			trimMax, trimMin, removeMax, removeMin, nRem_attr, nTrim_attr, nRem_attr_suffix, nTrim_attr_suffix, verbose_file,
			print_summary, print_summary_critical_cleaned)
};

/** Parameters for configured outliers cleaner
*/
//.......................................................................................
class confRecord : public SerializableObject {
public:
	double logicalLow, logicalHigh, confirmedLow, confirmedHigh;
	string distLow, distHigh; //"none" "norm" or "log" 
	int val_channel = 0;
	ADD_CLASS_NAME(confRecord)
		ADD_SERIALIZATION_FUNCS(logicalLow, logicalHigh, confirmedLow, confirmedHigh, distLow, distHigh)
};
MEDSERIALIZE_SUPPORT(confRecord)

//.......................................................................................
/** RepConfiguredOutlierCleaner is a simple cleaner considering each value of a certain signal separatley,
* but this time use configuration file that holds for each signal the logical values, statistically confirmed
* values  and distribution for relearning statistical values
*/
//.......................................................................................
class RepConfiguredOutlierCleaner : public  RepBasicOutlierCleaner {
private:
	string confFileName; ///< configuration file and mapping
	confRecord outlierParam; ///< a map from signal name to outliers parameters
public:
	string cleanMethod; ///< cleaning method :  "logical" "confirmed" or "learned"

	RepConfiguredOutlierCleaner() { init_defaults(); }

	/// <summary> Initialize to default values </summary>
	void init_defaults() {
		processor_type = REP_PROCESS_CONFIGURED_OUTLIER_CLEANER;
		params.trimming_sd_num = DEF_REP_TRIMMING_SD_NUM; params.removing_sd_num = DEF_REP_REMOVING_SD_NUM; params.nbrs_sd_num = 0;
		params.take_log = 0;
		params.doTrim = params.doRemove = true;
		signalId = -1;
		params.type = VAL_CLNR_ITERATIVE;
		params.missing_value = MED_MAT_MISSING_VALUE;
		verbose_file = "";
	};

	/// <summary> learn cleaning boundaries </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);

	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepConfiguredOutlierCleaner::init
	int init(map<string, string>& mapper);

	// Apply cleaning model -inheritted
	void set_signal_ids(MedSignals& sigs);

	/// Serialization
	ADD_CLASS_NAME(RepConfiguredOutlierCleaner)
		ADD_SERIALIZATION_FUNCS(processor_type, signalName, time_channel, val_channel, req_signals, aff_signals, params.take_log, params.missing_value, params.doTrim, params.doRemove,
			trimMax, trimMin, removeMax, removeMin, confFileName, cleanMethod, outlierParam, nRem_attr, nTrim_attr, nRem_attr_suffix, nTrim_attr_suffix)

		void print();
};

void learnDistributionBorders(float& borderHi, float& borderLo, vector<float> filteredValues);
// a function that takes sorted vector of filtered values and estimates the +- 7 sd borders based on the center of distribution
// predefined calibration constants are used for estimation of the borders. 


/**
* A cleaner that is based on rules that describe relations of signal values to each other.\n
* This is a static cleaner ( no learning involved).\n
\n
Rules:\n
Rule1: BMI = Weight / Height ^ 2 * 1e4\n
Rule2:MCH = Hemoglobin / RBC\n
Rule3:MCV = Hematocrit / RBC\n
Rule4:MCHC - M = MCH / MCV\n
Rule5:Eosinophils# + Monocytes# + Basophils# + Lymphocytes# + Neutrophils# <= WBC\n
Rule6:MPV = Platelets_Hematocrit / Platelets\n
Rule7:UrineAlbumin <= UrineTotalProtein\n
Rule8:UrineAlbumin_over_Creatinine = UrineAlbumin / UrineCreatinine\n
Rule9:LDL + HDL <= Cholesterol\n
Rule10:NonHDLCholesterol + HDL = Cholesterol\n
Rule11:HDL_over_nonHDL = HDL / NonHDLCholesterol\n
Rule12:HDL_over_Cholesterol = HDL / Cholesterol\n
Rule13:HDL_over_LDL = HDL / LDL\n
Rule14:HDL_over_LDL = 1 / LDL_over_HDL\n
Rule15:Cholesterol_over_HDL = Cholesterol / HDL\n
Rule16:---------------------\n
Rule17:Cholesterol_over_HDL = 1 / HDL_over_Cholestrol\n
Rule18:LDL_over_HDL = LDL / HDL\n
Rule19:Albumin <= Protein_Total\n
Rule20:FreeT4 <= T4\n
Rule21:NRBC <= RBC\n
Rule22:CHADS2_VASC >= CHADS2\n
*/
class RepRuleBasedOutlierCleaner : public RepProcessor {
	// get multiple signals and clean them according to consistency  with other signals from same date
public:

	/// Signals to clean
	vector <int> signalIds;
	vector<int> consideredRules;///< only rules in this list will be considered in this cleaner (read list from jason)
								/// rule number 0 means apply all rules. Empty vector: do nothing in this cleaner.

	string nRem_attr = ""; ///< Attribute name (in sample) for number of removed. not recorded if empty
	string nRem_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of removed. not recorded if empty

	float tolerance = 0.1F;
	int time_window = 0; ///< the size of time window to search for signals
	string verbose_file; ///< cleaning output_file for debuging
	float calc_res = 0; ///< signal resolution calc, 0 no resolution

	bool print_summary = false; ///< If true will always print clean summary
	float print_summary_critical_cleaned = (float)0.05; ///< beyond this value will print summary

	/// static map from rule to participating signals
	map <int, vector<string>>rules2Signals = {
	{1,{"BMI","Weight","Height"}},
	{2,{"MCH", "Hemoglobin","RBC"}},
	{3,{"MCV","Hematocrit","RBC"} },
	{4,{"MCHC-M","MCH","MCV"}},
	{5,{"Eosinophils#","Monocytes#","Basophils#","Lymphocytes#","Neutrophils#","WBC" }},
	{6,{ "MPV","Platelets_Hematocrit","Platelets" }},
	{7,{"UrineAlbumin","UrineTotalProtein" }},
	{8,{"UrineAlbumin_over_Creatinine","UrineAlbumin","UrineCreatinine" }},
	{9,{"LDL","HDL","Cholesterol"}},
	{10,{"NonHDLCholesterol","HDL","Cholesterol"}},
	{11,{"HDL_over_nonHDL","HDL","NonHDLCholesterol"}},
	{12,{"HDL_over_Cholesterol","HDL","Cholesterol"}},
	{13,{"HDL_over_LDL","HDL","LDL"}},
	{14,{"HDL_over_LDL","LDL_over_HDL"}},
	{15,{"Cholesterol_over_HDL","Cholesterol","HDL"}},
	{17,{"Cholesterol_over_HDL","HDL_over_Cholesterol"}}, //rule 16 canceled
	{18,{"LDL_over_HDL","LDL","HDL"}},
	{19,{"Albumin","Protein_Total"}},
	{20,{"FreeT4","T4"}},
	{21,{"NRBC","RBC"}},
	{22,{"CHADS2","CHADS2_VASC"}}
	};

	map<int, string> rules2RemoveSignal; ///< which signal to remove if contradiction found. If not exists default to remove all

	vector <int> rulesToApply;
	unordered_map<string, pair<int, int>> signal_channels; ///< signal channels (if exists). first is time, second is for val
	unordered_map<int, pair<int, int>> signal_id_channels; ///< signal channels (if exists). first is time, second is for val

	/// Helpers
	set <int> reqSignalIds, affSignalIds;
	unordered_map<int, vector<int>> rules_sids;
	unordered_map<int, vector<bool>> affected_by_rules;

	// Constructors 
	RepRuleBasedOutlierCleaner() : RepProcessor() { init_defaults(); }

	void init_defaults();

	void parse_rules_signals(const string &path);
	void parse_sig_channels(const string &path);


	// Init
	int init(void *processor_params) { return 0; };

	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepRuleBasedOutlierCleaner::init
	int init(map<string, string>& mapper);

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes();

	///set signals
	void set_signal_ids(MedSignals& sigs);

	/// <summary> Init required tables : Should be implemented for inheriting classes that have such tables </summary>
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	// Learning
	/// <summary> In this class there's never learning - we init tables and return 0 immediately </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { init_tables(rep.dict, rep.sigs); return 0; };

	/// Apply cleaning model 
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	~RepRuleBasedOutlierCleaner() { if (!verbose_file.empty() && log_file.is_open()) log_file.close(); };

	// Check if some required signals are missing and remove corresponding rules
	void fit_for_repository(MedPidRepository& rep);

	// set affected and required signals lists according to rules
	void init_lists();

	void make_summary();

	/// Serialization
	ADD_CLASS_NAME(RepRuleBasedOutlierCleaner)
		ADD_SERIALIZATION_FUNCS(processor_type, time_window, calc_res, rules2Signals, rulesToApply, rules2RemoveSignal, signal_channels, consideredRules, tolerance, req_signals, aff_signals, nRem_attr,
			nRem_attr_suffix, verbose_file, print_summary, print_summary_critical_cleaned)

private:
	///ruleUsvs hold the signals in the order they appear in the rule in the rules2Signals above
	/// apply the rule and return true if data is consistent with the rule
	bool  applyRule(int rule, const  vector<UniversalSigVec> &ruleUsvs,
		const vector<int> &val_channels, const vector<int> &sPointer);
	unordered_map<int, string> affected_ids_to_name;
	ofstream log_file;
	unordered_map<string, remove_stats> _rmv_stats;

	/// select which rules to apply according to consideredRules
	void select_rules_to_apply();

};

#define DEF_REP_NBRS_NBRS_SD_NUM 5
#define DEF_REP_NBRS_TRIM_SD_NUM 7
#define DEF_REP_NBRS_REMOVING_SD_NUM 14
//.......................................................................................
/** RepNbrsOutlierCleaner is cleaner that looks at the neighbourhood of a certain signal value
*/
//.......................................................................................
class RepNbrsOutlierCleaner : public RepProcessor, public MedValueCleaner {
public:

	string signalName; ///< name of signal to clean
	int signalId; ///< id of signal to clean
	int time_channel = 0; ///< time channel to consider in cleaning
	int val_channel = 0; ///< value cahnnel to consider in cleaning

	int nbr_time_width = 7; ///< size of neighborhood for defining neighboring values
	int nbr_time_unit = MedTime::Days; ///< time unit for defining neighboring values

	string nRem_attr = ""; ///< Attribute name (in sample) for number of removed. not recorded if empty
	string nTrim_attr = ""; ///< Attribute name (in sample) for number of trimmed. not recorded if empty
	string nRem_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of removed. not recorded if empty
	string nTrim_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of trimmed. not recorded if empty

	/// <summary> default constructor </summary>
	RepNbrsOutlierCleaner() { init_defaults(); }
	/// <summary> default constructor + setting signal name </summary>
	RepNbrsOutlierCleaner(const string& _signalName) { init_defaults(); signalId = -1; signalName = _signalName; init_lists(); }
	/// <summary> default constructor + setting signal name + initialize from string </summary>
	RepNbrsOutlierCleaner(const string& _signalName, string init_string) { init_defaults(); signalId = -1; signalName = _signalName; init_from_string(init_string); }
	/// <summary> default constructor + setting signal name + initialize from parameters </summary>
	RepNbrsOutlierCleaner(const string& _signalName, ValueCleanerParams *_params) { signalId = -1; signalName = _signalName; init_lists(); MedValueCleaner::init(_params); }

	/// <summary> Initialize to default values </summary>
	void init_defaults() {
		processor_type = REP_PROCESS_NBRS_OUTLIER_CLEANER;
		params.trimming_sd_num = DEF_REP_NBRS_TRIM_SD_NUM; params.removing_sd_num = DEF_REP_NBRS_REMOVING_SD_NUM; params.nbrs_sd_num = DEF_REP_NBRS_NBRS_SD_NUM;
		params.take_log = 0;
		params.doTrim = params.doRemove = true;
		signalId = -1;
		params.type = VAL_CLNR_ITERATIVE;
		params.missing_value = MED_MAT_MISSING_VALUE;
	};

	/// <summary> Set signal name and fill affected and required signals sets </summary> 
	void set_signal(const string& _signalName) { signalId = -1; signalName = _signalName; init_lists(); }

	/// <summary> Set signal id </summary>
	void set_signal_ids(MedSignals& sigs) { signalId = sigs.sid(signalName); }

	/// <summary> Fill required- and affected-signals sets </summary>
	int init(void *processor_params) { return MedValueCleaner::init(processor_params); };
	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepNbrsOutlierCleaner::init
	int init(map<string, string>& mapper);
	void init_lists();
	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes();

	/// <summary> learn cleaning boundaries </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);
	/// <summary> Learning : learn cleaning boundaries using MedValueCleaner's iterative approximation of moments </summary>
	int iterativeLearn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);
	/// <summary> Learning : learn cleaning boundaries using MedValueCleaner's quantile approximation of moments </summary>
	int quantileLearn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor);

	/// <summary> Apply cleaning model </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	// Serialization
	ADD_CLASS_NAME(RepNbrsOutlierCleaner)
		ADD_SERIALIZATION_FUNCS(processor_type, signalName, time_channel, val_channel, req_signals, aff_signals, params.take_log, params.missing_value, params.doTrim, params.doRemove,
			trimMax, trimMin, removeMax, removeMin, nbr_time_unit, nbr_time_width, nbrsMax, nbrsMin, nRem_attr, nTrim_attr, nRem_attr_suffix, nTrim_attr_suffix)

		/// <summary> Print processors information </summary>
		void print();
};

//.......................................................................................
/** SimValHandler handles multiple values at the same time **/
//.......................................................................................

// Modes of handling multiple values at the same time
typedef enum {
	SIM_VAL_FIRST_VAL,
	SIM_VAL_LAST_VAL,
	SIM_VAL_MEAN,
	SIM_VAL_REM,
	SIM_VAL_REM_DIFF,
	SIM_VAL_MIN,
	SIM_VAL_MAX,
	MULT_VAL_LAST
} SimValHandleTypes;

class RepSimValHandler : public RepProcessor {
public:
	string signalName; 	///< name of signal to handle
	int signalId;	///< id of signal to handle
	vector<int> time_channels; ///< time channels to consider. All if empty
	SimValHandleTypes handler_type; ///< type of handling multiple-values

	int nValChannels; ///< number of value-channels, important for rem-diff and mean modes

	string nHandle_attr = ""; ///< Attribute name (in sample) for number of multiple-values handled. not recorded if empty
	string nHandle_attr_suffix = ""; ///< Attribute suffix (name is sample is signalName_suffix) for number of multiple-values handled. not recorded if empty
	bool debug = false; ///<If True will print out till 3 examples for samples have been changed

	/// <summary> default constructor </summary>
	RepSimValHandler() { processor_type = REP_PROCESS_SIM_VAL; }
	/// <summary> default constructor + setting signal name </summary>
	RepSimValHandler(const string& _signalName) { processor_type = REP_PROCESS_SIM_VAL;; signalId = -1; signalName = _signalName; init_lists(); }
	/// <summary> default constructor + setting signal name + initialize from string </summary>
	RepSimValHandler(const string& _signalName, string init_string) { processor_type = REP_PROCESS_SIM_VAL; signalId = -1; signalName = _signalName; init_from_string(init_string); }

	/// <summary> Set signal name and fill affected and required signals sets </summary> 
	void set_signal(const string& _signalName) { signalId = -1; signalName = _signalName; init_lists(); }

	/// <summary> Set signal id </summary>
	void set_signal_ids(MedSignals& sigs) { signalId = sigs.sid(signalName); }

	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepSimValHandler::init
	virtual int init(map<string, string>& mapper);

	/// Fill req- and aff-signals vectors
	void init_lists();

	/// init tables - get time-channels
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes();

	/// <summary> Apply multiple-value handling </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	/// <summary> get SimHandleType from name </summary>
	/// @snippet RepProcess.cpp RepSimValHandler::get_sim_val_handle_type
	static SimValHandleTypes get_sim_val_handle_type(string& name);

	/// Serialization
	ADD_CLASS_NAME(RepSimValHandler)
		ADD_SERIALIZATION_FUNCS(processor_type, signalName, time_channels, req_signals, aff_signals, nHandle_attr, nHandle_attr_suffix, handler_type)
private:
	void handle_block(int start, int end, UniversalSigVec& usv, vector<int>& remove, int& nRemove, vector<pair<int, vector<float>>>& change, int& nChange, int& nTimes);
	int verbose_cnt = 0;
};

//.......................................................................................
/** RepPanelCompleter fills-in calculatable signal values. Enriching existing signals

	The available completions are currently -
		1. RedLineCompleter : MCV,HCT,RBC,MCH,MCHC,HGB
		2. WhiteLineCompleter : WBC,Eosonophils#,Eosonophils%,Neutrophils#,Neutrophils%,Lymphocytes#,Lymphocytes%,Monocytes#,Monocytes%,Basophils#,Basophils%
		3. PlateletsCompleter : Platelets, Platelets_Hematocrit and MPV
		4. LipidsCompleter : Cholesterol,LDL,HDL,HDL_over_Cholesterol,Cholesterol_over_HDL,HDL_over_LDL,LDL_over_HDL,NonHDLCholesterol,HDL_over_nonHDL,Tryglicerids
		5. eGFRCompleter : Creatinine, eGFR_CKD_EPI,eGFR_MDRD
		6. BMICompleter : BMI,Weight,Height

	Signals above are the default values. They can be changed, keeping the order, or set to NULL, in which case the completion is not-performed

*/
//.......................................................................................

typedef enum {
	REP_CMPLT_RED_LINE_PANEL, ///< complete values of the red blood line
	REP_CMPLT_WHITE_LINE_PANEL, ///< complete values of the white blood line
	REP_CMPLT_PLATELETS_PANEL, ///< complete values of platelets measurements
	REP_CMPLT_LIPIDS_PANEL, ///< complete lipd values
	REP_CMPLT_EGFR_PANEL, ///< complete eGFR values
	REP_CMPLT_BMI_PANEL, ///< complete BMI/HIGHT/WEIGHT values
	REP_CMPLT_GCS, ///< complete Glasgow Coma Score
	REP_CMPLT_LAST ///< Last not in use
} PanelCompleterTypes;

typedef enum {
	RED_PNL_MCV,
	RED_PNL_HCT,
	RED_PNL_RBC,
	RED_PNL_MCH,
	RED_PNL_MCHC,
	RED_PNL_HGB,
	RED_PNL_LAST
} RedPanelSignals;

typedef enum {
	WHITE_PNL_WBC,
	WHITE_PNL_EOS_N, WHITE_PNL_EOS_P,
	WHITE_PNL_NEU_N, WHITE_PNL_NEU_P,
	WHITE_PNL_LYM_N, WHITE_PNL_LYM_P,
	WHITE_PNL_MON_N, WHITE_PNL_MON_P,
	WHITE_PNL_BAS_N, WHITE_PNL_BAS_P,
	WHITE_PNL_LAST
} WhitePanelSignals;

typedef enum {
	PLT_PNL_PLTS,
	PLT_PNL_PLT_HCT,
	PLT_PNL_MPV,
	PLT_PNL_LAST
} PltsPanelSignals;

typedef enum {
	LIPIDS_PNL_CHOL,
	LIPIDS_PNL_LDL,
	LIPIDS_PNL_HDL,
	LIPIDS_PNL_HDL_OVER_CHOL,
	LIPIDS_PNL_CHOL_OVER_HDL,
	LIPIDS_PNL_HDL_OVER_LDL,
	LIPIDS_PNL_LDL_OVER_HDL,
	LIPIDS_PNL_NON_HDL_CHOL,
	LIPIDS_PNL_HDL_OVER_NON_HDL,
	LIPIDS_PNL_TRGS,
	LIPIDS_PNL_VLDL,
	LIPIDS_PNL_LAST
} LipidsPanelSignals;

typedef enum {
	EGFR_PNL_CRT,
	EGFR_PNL_CKD_EPI,
	EGFR_PNL_MDRD,
	EGFR_PNL_LAST
} eGFRPanelSignals;

typedef enum {
	BMI_PNL_BMI,
	BMI_PNL_WGT,
	BMI_PNL_HGT,
	BMI_PNL_HGT_SQR,
	BMI_PNL_LAST
} BMIPanelSignals;

typedef enum {
	GCS_PNL,
	GCS_PNL_EYE,
	GCS_PNL_MOTOR,
	GCS_PNL_VERBAL,
	GCS_PNL_LAST
} GCSPanelSignals;

/**
* A Repository panel completer for a complete panel of signals that are dependent and given on same time.
* TODO: add support for look in the past threshold
*/
class RepPanelCompleter : public RepProcessor {
public:
	// Signals for completions
	vector<vector<string> > panel_signal_names;
	vector<vector<int> > panel_signal_ids;

	// Extra signal ids
	int byearId, genderId;
	string genderSignalName;

	// Missing value indication
	float missing_val = MED_MAT_MISSING_VALUE;

	// Handling multiple values
	SimValHandleTypes sim_val_handler = SIM_VAL_LAST_VAL;

	// Signals meta-data : original and final resolution and factors
	string metadata_file;
	vector<vector<float> > original_sig_res, final_sig_res, sig_conversion_factors;

	RepPanelCompleter() { processor_type = REP_PROCESS_COMPLETE; init_defaults(); }

	/// @snippet PanelCompleter.cpp RepPanelCompleter::init
	int init(map<string, string>& mapper);

	/// <summary> initialize to default values :  Should be implemented for inheriting classes that have parameters </summary>
	void init_defaults();

	// Change signal names from defualt
	int update_signal_names(string panel, string& names);

	// Change panels to handle
	int update_panels(string& panels);

	// initialize signal ids
	void set_signal_ids(MedSignals& sigs);

	// Check if some required signals are missing and make them virtual or remove relevant panel completer
	void fit_for_repository(MedPidRepository& rep);

	// dictionary based initializations
	void init_tables(MedDictionarySections &dict, MedSignals& sigs);

	/// Fill req- and aff-signals vectors
	void init_lists();

	// Read conversion and resolution info
	void read_metadata();

	// Learning
	/// <summary> In this class there's never learning - we init tables and return 0 immediately </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { init_tables(rep.dict, rep.sigs); read_metadata(); return 0; };

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	// calculators implementations
	int apply_red_line_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_white_line_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_platelets_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_lipids_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_eGFR_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_BMI_completer(PidDynamicRec& rec, vector<int>& time_points);
	int apply_GCS_completer(PidDynamicRec& rec, vector<int>& time_points);

	// Utilities
	// Age/Gender
	int perpare_for_age_and_gender(PidDynamicRec& rec, int& age, int& bYear, int& gender);

	// Rounding - take care of resolution both in original and final units 
	inline float completer_round(float value, float orig_res, float final_res, float factor) { return  set_resolution(set_resolution(value / factor, orig_res) * factor, final_res); }
	inline float set_resolution(float value, float res) { return res * (int)(value / res + 0.5); }

	// Generating panels from usvs
	void get_panels(vector<UniversalSigVec>& usvs, vector<int>& panel_times, vector<vector<float>>& panels, int time_limit, int panel_size);

	// Applying formulas
	int triplet_complete(vector<float>& panel, float factor, int x_idx, int y_idx, int z_idx, vector<float>& orig_res, vector<float>& final_res, vector<float>& conv, vector<int>& changed);
	int sum_complete(vector<float>& panel, int sum, vector<int>& summands, vector<float>& orig_res, vector<float>& final_res, vector<float>& conv, vector<int>& changed);
	int reciprocal_complete(vector<float>& panel, float factor, int x_idx, int y_idx, vector<float>& orig_res, vector<float>& final_res, vector<float>& conv, vector<int>& changed);
	int egfr_complete(vector<float>& panel, float age, int gender, vector<float>& orig_res, vector<float>& final_res, vector<float>& conv, vector<int>& changed);

	// Updating signals in dynamic-rec
	int update_signals(PidDynamicRec& rec, int iver, vector<vector<float>>& panels, vector<int>& panel_times, vector<int>& sigs_ids, vector<int>& changed);

	// serialization. meta-data file is kept for information but not used in apply
	void print();
	ADD_CLASS_NAME(RepPanelCompleter)
		ADD_SERIALIZATION_FUNCS(processor_type, panel_signal_names, missing_val, sim_val_handler, original_sig_res, final_sig_res, sig_conversion_factors, metadata_file, req_signals, aff_signals, virtual_signals)

private:

	map<string, PanelCompleterTypes> panel2type = {
		{ "red_line",REP_CMPLT_RED_LINE_PANEL },
		{ "white_line",REP_CMPLT_WHITE_LINE_PANEL },
		{ "platelets",REP_CMPLT_PLATELETS_PANEL },
		{ "lipids",REP_CMPLT_LIPIDS_PANEL },
		{ "egfr",REP_CMPLT_EGFR_PANEL },
		{ "bmi",REP_CMPLT_BMI_PANEL },
		{ "gcs", REP_CMPLT_GCS }
	};

	// definitions and defaults for each panel-completer
	map<string, vector<string> > panel2signals = {
		{ "red_line", {"MCV","Hematocrit","RBC","MCH","MCHC-M","Hemoglobin"}},
		{ "white_line", {"WBC", "Eosinophils#", "Eosinophils%", "Neutrophils#", "Neutrophils%", "Lymphocytes#", "Lymphocytes%", "Monocytes#", "Monocytes%", "Basophils#", "Basophils%"}},
		{ "platelets", {"Platelets", "Platelets_Hematocrit","MPV"}},
		{ "lipids",{"Cholesterol", "LDL", "HDL", "HDL_over_Cholesterol", "Cholesterol_over_HDL", "HDL_over_LDL", "LDL_over_HDL", "NonHDLCholesterol", "HDL_over_nonHDL", "Triglycerides"}},
		{ "egfr", {"Creatinine","eGFR_CKD_EPI","eGFR_MDRD"}},
		{ "bmi", {"BMI","Weight","Height"}},
		{"gcs", {"GCS", "GCS_Eye", "GCS_Motor", "GCS_Verbal"}}
	};

	vector<int> white_panel_nums = { WHITE_PNL_EOS_N,WHITE_PNL_NEU_N,WHITE_PNL_LYM_N,WHITE_PNL_MON_N,WHITE_PNL_BAS_N };
	vector<int> white_panel_precs = { WHITE_PNL_EOS_P,WHITE_PNL_NEU_P,WHITE_PNL_LYM_P,WHITE_PNL_MON_P,WHITE_PNL_BAS_P };
	vector<int> chol_types1 = { LIPIDS_PNL_NON_HDL_CHOL,LIPIDS_PNL_HDL };
	vector<int> chol_types2 = { LIPIDS_PNL_LDL, LIPIDS_PNL_HDL, LIPIDS_PNL_VLDL };
	vector<int> gcs_panel_parts = { GCS_PNL_EYE,GCS_PNL_MOTOR,GCS_PNL_VERBAL };

	//Convertion map for GCS:
	unordered_map<int, int> eye_vals, verbal_vals, motor_vals;
	void convert_gcs_signals(vector<float> &panel);
};

//.......................................................................................


//.......................................................................................
/** RepCalcSimpleSignals is a rep processor containing several calculators to calculate new
	signals. It supports an internal list of calculators, and the user can select one of them.

	Each calculator can create one or more new virtual signals. Each of these has a specific type.
	The user can configure the virtual signal names, and can also pass a list of float parameters to
	the calculator, making it parametric.

	When adding a new calculator make sure to :
	(1) fill in the calc2defs map (as explained below), to define the calculator name, type, req signals,
		default virual names and their types, and default parameters.
	(2) add the new calculator type to the enum
	(3) write the matching _apply function for the specific calculator and make sure the general _apply calls it .

	NOTE: in RepCalcSimpleSignals there is NO learning. Calculated signals that have a learning stage should
		  be implmented in a separate class that will also have space to keep the learning process results.

	supported signals calculated (this will be also the virtual signal name):

	calc_eGFR : calculating EGFR (CKD_EPI formula) at each point in which Creatinine is available

*/
//.......................................................................................
/**
* Abstract class for calculator - has do_calc which recieves vector for values to calculate
*/
class SimpleCalculator : public SerializableObject {
public:
	float missing_value = (float)MED_MAT_MISSING_VALUE; ///< missing value 
	string calculator_name = ""; ///< just for debuging
	int work_channel = 0; ///< the working channel
	bool need_time = false; ///< if needed time
	bool keep_only_in_range = false; ///< keeps only in range values

	///init function of calculator
	virtual int init(map<string, string>& mapper) { return 0; };
	///validates correctness of inputs
	virtual void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const {};
	virtual bool do_calc(const vector<float> &vals, float &res) const = 0; ///< the calc option
	virtual void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals) = 0; ///< list output signals with default naming
	/// init operator based on repo if needed
	virtual void init_tables(MedDictionarySections& dict, MedSignals& sigs, const vector<string> &input_signals) {};

	/// @snippet RepProcess.cpp SimpleCalculator::make_calculator
	static SimpleCalculator *make_calculator(const string &calc_type);

	virtual ~SimpleCalculator() {};

};

/**
* Calcs ratio between 2 inputs signals. has ability to power each signal before dividing and multiply by factor
* Calc is when we have V = { V1, V2 } as inputs. res := factor * V1^power_mone / V2^power_base
*/
class RatioCalculator : public SimpleCalculator {
public:
	float factor = 1; ///< factor multiply
	float power_base = 1; ///< power base input
	float power_mone = 1; ///< power mone input

	RatioCalculator() { calculator_name = "ratio"; keep_only_in_range = false; };
	/// @snippet RepCalculators.cpp RatioCalculator::init
	int init(map<string, string>& mapper);

	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);
	bool do_calc(const vector<float> &vals, float &res) const;
};

/**
* eGFR calculator based on Creatinine, Gender and Age.
* the signals input order is: Creatinine, Gender, Age
*/
class eGFRCalculator : public SimpleCalculator {
public:
	float ethnicity = 0; ///< ethnicity, for now only support 0
	bool mdrd = false; ///< If true will use MDRD calculation

	eGFRCalculator() { calculator_name = "eGFR_CKD_EPI"; need_time = true; keep_only_in_range = true; };
	/// @snippet RepCalculators.cpp eGFRCalculator::init
	int init(map<string, string>& mapper);
	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);
	bool do_calc(const vector<float> &vals, float &res) const;
};

/**
* does log operation
*/
class logCalculator : public SimpleCalculator {
public:
	logCalculator() { calculator_name = "log"; keep_only_in_range = false; };

	/// @snippet RepCalculators.cpp logCalculator::init
	int init(map<string, string>& mapper);
	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);

	bool do_calc(const vector<float> &vals, float &res) const;
};

/**
* does linear sum with factors on vector of input signals, has b0 as constant
* res := b0 + sum_sigma(i=1..N){ factor[i] * input[i]}
*/
class SumCalculator : public SimpleCalculator {
public:
	vector<float> factors; ///< the factors given by ","
	float b0 = 0; ///< a constant

	SumCalculator() { calculator_name = "sum"; };
	/// @snippet RepCalculators.cpp SumCalculator::init
	int init(map<string, string>& mapper);
	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);
	bool do_calc(const vector<float> &vals, float &res) const;
};

/**
* A simple Range check that return in_range_val if within range and returns out_range_val
* if outside range.
*/
class RangeCalculator : public SimpleCalculator {
public:
	float min_range; ///< min range check
	float max_range; ///< max range check
	float in_range_val = 1; ///< return value when within range
	float out_range_val = 0; ///< return value when not within range

	RangeCalculator() { calculator_name = "range"; min_range = MED_MAT_MISSING_VALUE; max_range = MED_MAT_MISSING_VALUE; };
	/// @snippet RepCalculators.cpp RangeCalculator::init
	int init(map<string, string>& mapper);
	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);
	bool do_calc(const vector<float> &vals, float &res) const;
};

/**
* A multiply operation with power on both arguments. V = { V1, V2 }
* res := V1^power_a * V2^power_b
*/
class MultiplyCalculator : public SimpleCalculator {
public:
	vector<float> powers; ///< power for args
	float b0 = 1; ///< init value

	MultiplyCalculator() { calculator_name = "multiply"; };
	/// @snippet RepCalculators.cpp MultiplyCalculator::init
	int init(map<string, string>& mapper);

	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);

	bool do_calc(const vector<float> &vals, float &res) const;
};

/**
* A is in set operation which return binary output
* res := in_range_val if is in set otherwise out_range_val
*/
class SetCalculator : public SimpleCalculator {
public:
	vector<string> sets;
	float in_range_val = 1; ///< return value when within range
	float out_range_val = 0; ///< return value when not within range

	SetCalculator() { calculator_name = "set"; };
	/// @snippet RepCalculators.cpp SetCalculator::init
	int init(map<string, string>& mapper);

	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);
	void init_tables(MedDictionarySections& dict, MedSignals& sigs, const vector<string> &input_signals);

	bool do_calc(const vector<float> &vals, float &res) const;
private:
	vector<char> Flags;
};

/**
* A is in as exists operation which return binary output
* res := in_range_val if signal exists otherwise out_range_val
*/
class ExistsCalculator : public SimpleCalculator {
public:
	float in_range_val = 1; ///< return value when within range
	float out_range_val = 0; ///< return value when not within range

	ExistsCalculator() { calculator_name = "exists"; keep_only_in_range = true; need_time = true; };
	/// @snippet RepCalculators.cpp ExistsCalculator::init
	int init(map<string, string>& mapper);

	void validate_arguments(const vector<string> &input_signals, const vector<string> &output_signals) const;
	void list_output_signals(const vector<string> &input_signals, vector<pair<string, int>> &_virtual_signals);

	bool do_calc(const vector<float> &vals, float &res) const;
};

/**
* A simple class for calculating virtual signals. please reffer to SimpleCalculator to see which
* calculation are supported right now
*/
class RepCalcSimpleSignals : public RepProcessor {

public:
	vector<string> V_names; ///< names of signals created by the calculator (a calculator can create more than a single signal at a time)

	string calculator; ///< calculator asked for by user
	int work_channel = 0; ///< the channel to work on all singals - and save results to
	int time_channel = 0; ///<the time channel

	float missing_value = (float)MED_MAT_MISSING_VALUE;

	//vector<float> coeff; ///< it is possible to transfer a vector of params to the calculator, to enable parametric calculators.

	vector<string> signals; ///< it is possible to transfer a vector of required signals, to override default ones.
	int signals_time_unit = MedTime::Undefined; ///< Time unit of timer and all signals 

	int max_time_search_range = 0; ///< how much time we are allowed to look backward to calculate. to look forward we need to fix the function
	string calculator_init_params = ""; ///< string init params for calculator

	RepCalcSimpleSignals() { processor_type = REP_PROCESS_CALC_SIGNALS; }
	~RepCalcSimpleSignals();

	/// @snippet RepProcess.cpp RepCalcSimpleSignals::init
	int init(map<string, string>& mapper);

	// making sure V_ids and sigs_ids are initialized
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	// Learning
	/// <summary> In this class there's never learning - we return 0 immediately </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { init_tables(rep.dict, rep.sigs); return 0; };

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();

	// serialization
	ADD_CLASS_NAME(RepCalcSimpleSignals)
		ADD_SERIALIZATION_FUNCS(processor_type, calculator, calculator_init_params, max_time_search_range, signals_time_unit,
			signals, V_names, req_signals, aff_signals, virtual_signals, work_channel, time_channel)
		void post_deserialization() {
		SimpleCalculator *p = SimpleCalculator::make_calculator(calculator);
		pass_time_last = p->need_time; delete p;
	}

private:
	// definitions and defaults for each calculator - all must be filled in for a new calculator
	bool pass_time_last = false; ///< pass last signal as time
	/// from a calculator name to the list of required signals
	const map<string, vector<string>> calc2req_sigs = {
		//--------- level 1 - calculated from raw signals (level0)
		//the general hospital processor's signals must be overridden from outside
		{ "calc_eGFR", {"Creatinine", "GENDER", "BYEAR"}}
	};

	vector<int> V_ids; ///< ids of signals created by the calculator (for faster usage at run time: save name conversions)
	vector<int> sigs_ids; /// <ids of signals used as input by the calculator (for faster usage at run time: save name conversions)
	vector<bool> static_input_signals;

	int apply_calc_in_time(PidDynamicRec& rec, vector<int>& time_points);

	SimpleCalculator *calculator_logic = NULL;

};

/**
* RepCreateReigsty creates registries (e.g. Diabetes, HyperTension, CKD, etc) as virtual signals
*/

typedef enum {
	REP_REGISTRY_DM,
	REP_REGISTRY_HT,
	REP_REGISTRY_PROTEINURIA,
	REP_REGISTRY_CKD,
	REP_REGISTRY_LAST
} RegistryTypes;

// helper class 
typedef enum {
	REG_EVENT_DM_GLUCOSE,
	REG_EVENT_DM_HBA1C,
	REG_EVENT_DM_DRUG,
	REG_EVENT_DM_DIAGNOSES
} DMEventsTypes;

class RegistryEvent {
public:
	int time = -1;
	int event_type;
	float event_val;
	int event_severity;

	RegistryEvent() {};
	RegistryEvent(int _time, int _type, float _val, int _severity) { time = _time; event_type = _type; event_val = _val; event_severity = _severity; }

};

class RegistryDecisionRanges {
public:
	string sig_name;
	int sig_id;
	int usv_idx;
	int is_numeric;
	vector<vector<string>> categories;
	vector<vector<int>> categories_i;
	vector<pair<float, float>> ranges;
};

class RepCreateRegistry : public RepProcessor {
public:

	RegistryTypes registry; ///< type of registry to create
	vector<string> names; ///< name(s) of registry signal(s) to create

	vector<string> signals; ///< Vector of required signals, to override default ones.
	vector<string> registry_values; ///< values of registry (to appear in relevant section of dictionary)
	int time_unit = -1; ///< time-unit of registry

	bool verbose = false; ///< verbosity

	// Registry specific parameters
	// Hypertension
	vector<string> ht_identifiers; ///< identifiers (ReadCodes) of HT
	vector<string> chf_identifiers; ///< identifiers (ReadCodes) of CHF
	vector<string> mi_identifiers; ///< identifiers (ReadCodes) of MI
	vector<string> af_identifiers; ///< identifiers (ReadCodes) of AF
	bool ht_identifiers_given = false, chf_identifiers_given = false, mi_identifiers_given = false, af_identifiers_given = false;

	vector<string> ht_drugs = { "ATC_C08C____","ATC_C07B____","ATC_C07C____","ATC_C07D____","ATC_C07F____","ATC_C07A_G__","ATC_C09B____","ATC_C09D____", "ATC_C02D_A01" }; ///< drugs indicative of HT
	vector<string> ht_chf_drugs = { "ATC_C03_____" }; ///< drugs indicative of HT, unless CHF
	vector<string> ht_dm_drugs = { "ATC_C09A____", "ATC_C09C____" }; ///< drugs indicative of HT, unless DM
	vector<string> ht_extra_drugs = { "ATC_C07A_A__", "ATC_C07A_B__" }; ///< drugs indicative of HT, unless CHF/MI/AF.

	int ht_drugs_gap = 90; ///< Gap (in days) from drug input to following indication

	RepCreateRegistry() { processor_type = REP_PROCESS_CREATE_REGISTRY; }
	~RepCreateRegistry() {};

	// dm registry related parameters
	string dm_drug_sig = "Drug";
	vector<string> dm_drug_sets = { "ATC_A10_____" };
	string dm_diagnoses_sig = "RC";
	vector<string> dm_diagnoses_sets;
	string dm_glucose_sig = "Glucose";
	string dm_hba1c_sig = "HbA1C";
	int dm_diagnoses_severity = 4; // 3: need supporting evidence as well, 4: single code is enough
	int dm_bio_mode = 0; // bio mode - takes the FIRST suggestive test for a condition 


	// proteinuria related parameters
	// <name>:<0/1: is_numeric (numerics are 1)>:<categs or ranges for normal>:<categs or ranges for medium>:<categs or ranges for severe>
	// / is the separator between signals in a real input
	vector<string> urine_tests_categories = {
		"Urine_Microalbumin:1:0,30:30,300:300,1000000",
		"UrineTotalProtein:1:0,0.15:0.15,0.60:0.60,1000000",
		"UrineAlbumin:1:0,30:30,300:300,1000000",
		"Urine_dipstick_for_protein:0:Urine_dipstick_for_protein_normal:Urine_dipstick_for_protein_medium:Urine_dipstick_for_protein_severe",
		"Urinalysis_Protein:0:Urinalysis_Protein_normal:Urinalysis_Protein_medium:Urinalysis_Protein_severe",
		"Urine_Protein_Creatinine:1:0,15:15,100:100,1000000",
		"UrineAlbumin_over_Creatinine:1:0,3.5:3.5,27:27,1000000" };


	// ckd related
	string ckd_egfr_sig = "eGFR_CKD_EPI";
	string ckd_proteinuria_sig = "Proteinuria_State";


	/// @snippet RepCreateRegistry.cpp RepCreateRegistry::init
	int init(map<string, string>& mapper);
	void init_lists();

	// making sure V_ids and sigs_ids are initialized
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	// Learning
	/// <summary> In this class there's never learning - we return 0 immediately </summary>
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processors) { init_tables(rep.dict, rep.sigs); return 0; };

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	// serialization
	ADD_CLASS_NAME(RepCreateRegistry)
		ADD_SERIALIZATION_FUNCS(processor_type, registry, names, signals, time_unit, req_signals, aff_signals, virtual_signals, registry_values,
			ht_identifiers, chf_identifiers, mi_identifiers, af_identifiers, ht_identifiers_given, chf_identifiers_given, mi_identifiers_given, af_identifiers_given,
			ht_drugs, ht_chf_drugs, ht_dm_drugs, ht_extra_drugs, ht_drugs_gap,
			dm_drug_sig, dm_drug_sets, dm_diagnoses_sig, dm_diagnoses_sets, dm_glucose_sig, dm_hba1c_sig, dm_diagnoses_severity,
			urine_tests_categories,
			ckd_egfr_sig, ckd_proteinuria_sig)

private:
	string registry_name;

	/// registry name to type
	const map<string, RegistryTypes> name2type = { { "dm" , REP_REGISTRY_DM }, {"ht", REP_REGISTRY_HT }, {"proteinuria", REP_REGISTRY_PROTEINURIA}, {"ckd", REP_REGISTRY_CKD} };

	// output signal name + type
	const map<RegistryTypes, vector<pair<string, int>>> type2Virtuals = { { REP_REGISTRY_DM,{{"DM_Registry",T_TimeRangeVal}}},
																		  { REP_REGISTRY_HT,{{"HT_Registry",T_TimeRangeVal}}},
																		  { REP_REGISTRY_PROTEINURIA, {{"Proteinuria_State", T_DateVal}}} ,
																		  { REP_REGISTRY_CKD, {{"CKD_Registry", T_DateVal}}} };

	// required signals
	const map<RegistryTypes, vector<string>> type2reqSigs = { { REP_REGISTRY_DM,{"Glucose","HbA1C","Drug","RC"}},
															  { REP_REGISTRY_HT, {"BP","RC","Drug","BYEAR","DM_Registry"}},
															  { REP_REGISTRY_PROTEINURIA , { "Urine_Microalbumin", "UrineTotalProtein" , "UrineAlbumin" , "Urine_dipstick_for_protein" , "Urinalysis_Protein" , "Urine_Protein_Creatinine" , "UrineAlbumin_over_Creatinine" }},
															  { REP_REGISTRY_CKD, {"Proteinuria_State", "eGFR_CKD_EPI"}} };

	set<int> sig_ids_s;
	vector<int> sig_ids; ///< ids of signals used as input by the calculator (for faster usage at run time: save name conversions)
	vector<int> virtual_ids; ///< ids of signals created by the calculator (for faster usage at run time: save name conversions)

	// dm related privates
	int dm_drug_idx = -1; // idx for drug signal in usvs, sig_ids, etc...
	int dm_diagnoses_idx = -1;
	vector<char> dm_drug_lut;
	vector<char> dm_diagnoses_lut;
	int dm_glucose_idx = -1;
	int dm_hba1c_idx = -1;
	//DEF     0       DM_Registry_Non_diabetic
	//DEF     1       DM_Registry_Pre_diabetic
	//DEF     2       DM_Registry_Diabetic
	vector<string> dm_reg_values = { "DM_Registry_Non_diabetic", "DM_Registry_Pre_diabetic", "DM_Registry_Diabetic" };


	// proteinuria related privates
	vector<string> proteinuria_reg_values = { "Proteinuria_Normal", "Proteinuria_Medium" , "Proteinuria_Severe" };
	vector<RegistryDecisionRanges> proteinuria_ranges;

	// CKD related states
	vector<string> ckd_reg_values = { "CKD_State_Normal" , "CKD_State_Level_1", "CKD_State_Level_2", "CKD_State_Level_3", "CKD_State_Level_4" };
	int ckd_egfr_idx = -1;
	int ckd_proteinuria_idx = -1;


	vector<int> signal_time_units; ///< time-units of all signals

	// Registry specific functions and parameters
	// HT
	void init_ht_registry_tables(MedDictionarySections& dict, MedSignals& sigs);
	void ht_registry_apply(PidDynamicRec& rec, vector<int>& time_points, int iver, vector<UniversalSigVec>& usvs, vector<vector<float>>& all_v_vals, vector<vector<int>>& all_v_times, vector<int>& final_sizes);
	void ht_init_defaults();
	void fillLookupTableForHTDrugs(MedDictionary& dict, vector<char>& lut, vector<string>& sets, char val);
	void buildLookupTableForHTDrugs(MedDictionary& dict, vector<char>& lut);

	vector<string> ht_def_values = { "HT_Registry_Non_Hypertensive","HT_Registry_Hypertensive" };
	int bp_idx = 0, rc_idx = 1, drug_idx = 2, byear_idx = 3, dm_registry_idx = 4;
	vector<char> htLut, chfLut, miLut, afLut;
	vector<char> htDrugLut;

	// DM
	void init_dm_registry_tables(MedDictionarySections& dict, MedSignals& sigs);
	void dm_registry_apply(PidDynamicRec& rec, vector<int>& time_points, int iver, vector<UniversalSigVec>& usvs, vector<vector<float>>& all_v_vals, vector<vector<int>>& all_v_times, vector<int>& final_sizes);

	// Proteinuria
	void init_proteinuria_registry_tables(MedDictionarySections& dict, MedSignals& sigs);
	void proteinuria_registry_apply(PidDynamicRec& rec, vector<int>& time_points, int iver, vector<UniversalSigVec>& usvs, vector<vector<float>>& all_v_vals, vector<vector<int>>& all_v_times, vector<int>& final_sizes);

	// ckd
	void init_ckd_registry_tables(MedDictionarySections& dict, MedSignals& sigs);
	void ckd_registry_apply(PidDynamicRec& rec, vector<int>& time_points, int iver, vector<UniversalSigVec>& usvs, vector<vector<float>>& all_v_vals, vector<vector<int>>& all_v_times, vector<int>& final_sizes);


};

/**
* Combines multiple signals to one signal. has ability to factorize each source signal
*/
class RepCombineSignals : public RepProcessor {
public:
	string output_name; ///< names of signal created by the processor
	vector<string> signals; ///< names of input signals used by the processor
	vector<float> factors; ///< factor for each signal
	int num_val_channels; ///< number of val channels

	RepCombineSignals() {
		processor_type = REP_PROCESS_COMBINE; output_name = ""; num_val_channels = 2;
	}

	void register_virtual_section_name_id(MedDictionarySections& dict);

	/// @snippet RepProcess.cpp RepCombineSignals::init
	int init(map<string, string>& mapper);

	void init_tables(MedDictionarySections& dict, MedSignals& sigs);
	void set_required_signal_ids(MedDictionarySections& dict) {};
	void set_affected_signal_ids(MedDictionarySections& dict) {};

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();
	ADD_CLASS_NAME(RepCombineSignals)
		ADD_SERIALIZATION_FUNCS(processor_type, output_name, signals, factors, unconditional, req_signals, aff_signals, virtual_signals)
private:
	int v_out_sid = -1;
	vector<int> sigs_ids;
};

/**
* split signal based on set of values. supports only 2 channel for value, first is used
* for search in sets (and keeps the same value) 2 is being factorized
* output signal is haveing 1 time channel and 2 value channels
*/
class RepSplitSignal : public RepProcessor {
public:
	string input_name; ///< names of input signal used by the processor
	vector<string> names; ///< names of signal created by the processor
	vector<float> factors; ///< factor for each output signal
	vector<string> sets; ///< the sets to check if signal value is in set

	RepSplitSignal() { processor_type = REP_PROCESS_SPLIT; input_name = ""; }

	void add_virtual_signals(map<string, int> &_virtual_signals);
	void register_virtual_section_name_id(MedDictionarySections& dict);

	/// initialize signal ids
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);
	void set_required_signal_ids(MedDictionarySections& dict) {};
	void set_affected_signal_ids(MedDictionarySections& dict) {};

	/// @snippet RepProcess.cpp RepSplitSignal::init
	int init(map<string, string>& mapper);

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();
	ADD_CLASS_NAME(RepSplitSignal)
		ADD_SERIALIZATION_FUNCS(processor_type, input_name, names, factors, sets, unconditional, req_signals, aff_signals, virtual_signals)
private:
	int in_sid = -1;
	vector<int> V_ids;
	vector<char> Flags;
};


/**
* creates a signal of time ranges in which the input signal (usually medication) was active
* ranges are combined based on the period parameter
* the signal value is not transfered to the output signal
*/
class RepAggregationPeriod : public RepProcessor {
public:
	string input_name; ///< name of input signal used by the processor
	string output_name; ///< name of signal created by the processor
	vector<string> sets; ///< the sets to check if signal value is in set
	int period; ///< period to consider active after signal in win time units

	int time_unit_win = MedTime::Undefined;		///< the time unit in which the period is given. Default: Undefined
	int time_unit_sig = MedTime::Undefined;		///< the time init in which the signal is given. Default: Undefined

private:
	int in_sid;
	vector<int> V_ids;
	vector<char> lut;

public:
	RepAggregationPeriod() :
		input_name(""), output_name(""), period(0), time_unit_sig(global_default_windows_time_unit), time_unit_win(global_default_windows_time_unit), in_sid(-1) {
		processor_type = REP_PROCESS_AGGREGATION_PERIOD;
	}

	void add_virtual_signals(map<string, int> &_virtual_signals);

	/// initialize signal ids
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	/// @snippet RepProcess.cpp RepAggregationPeriod::init
	int init(map<string, string>& mapper);

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();

	ADD_CLASS_NAME(RepAggregationPeriod)
		ADD_SERIALIZATION_FUNCS(processor_type, input_name, output_name, sets, period, req_signals, aff_signals, virtual_signals, time_unit_win, time_unit_sig, in_sid, V_ids, lut)

};

/**
* A simple cleaner considering each value of a certain signal separatley
*/
class RepBasicRangeCleaner : public RepProcessor {
public:

	string signal_name; 	///< name of signal to clean
	string ranges_name; ///< name of signal that defines ranges
	string output_name; ///< name of output virtual signal - defaults to signal_name + "_" + ranges_name
	int signal_id;	///< id of signal to clean
	int ranges_id; ///< id of signal the defines ranges
	int output_id; ///< id of output signal
	int time_channel; ///< time channel to consider in cleaning
	int output_type; ///< output signal type - should be identical to input signal type default to range + val type
	int get_values_in_range = 1; ///< if 1 (default) : stay with the values in range, if 0 : stay with the values out of range

	/// <summary> default constructor </summary>
	RepBasicRangeCleaner() :
		signal_name(""), ranges_name(""), output_name(""), signal_id(-1), ranges_id(-1), output_id(-1), time_channel(0), output_type(3) {
		processor_type = REP_PROCESS_BASIC_RANGE_CLEANER;
	}

	void add_virtual_signals(map<string, int> &_virtual_signals);

	/// initialize signal ids
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	/// <summary> Fill required- and affected-signals sets </summary>
	/// The parsed fields from init command.
	/// @snippet RepProcess.cpp RepBasicRangeCleaner::init
	virtual int init(map<string, string>& mapper);

	/// <summary> Apply cleaning model </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	/// Serialization
	ADD_CLASS_NAME(RepBasicRangeCleaner)
		ADD_SERIALIZATION_FUNCS(processor_type, signal_name, ranges_name, output_name, time_channel, req_signals, aff_signals, signal_id, ranges_id, output_id, virtual_signals, output_type, get_values_in_range)

		/// <summary> Print processors information </summary>
		void print();
};

/**
* Normalize Signal Values by time - divide by time to calculate rate
*/
class RepSignalRate : public RepProcessor {
public:
	string output_name; ///< names of signals created by the completer
	string input_name; ///< names of input signals used by the completer
	int work_channel; ///< which channel to change and divide by time
	float factor; ///< additional constant factor 

	RepSignalRate() {
		processor_type = REP_PROCESS_SIGNAL_RATE; output_name = { "calc_drug_rate" };
		work_channel = 0;  factor = 1;
	}

	/// @snippet RepProcess.cpp RepSignalRate::init
	int init(map<string, string>& mapper);
	void add_virtual_signals(map<string, int> &_virtual_signals);
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);
	void register_virtual_section_name_id(MedDictionarySections& dict);
	void set_required_signal_ids(MedDictionarySections& dict) {};
	void set_affected_signal_ids(MedDictionarySections& dict) {};

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();
	ADD_CLASS_NAME(RepSignalRate)
		ADD_SERIALIZATION_FUNCS(processor_type, input_name, output_name, work_channel, factor, unconditional, req_signals, aff_signals, virtual_signals)
private:
	int v_out_sid = -1;
	int in_sid = -1;
};

/**
* An Aggregator for signal in sliding time window
*/
class RepAggregateSignal : public RepProcessor {
public:
	string signalName; ///< the name of inout signal
	string output_name; ///< the name of virtual signal
	int work_channel; ///< channel for value
	int start_time_channel;; ///< time channel for start time
	int end_time_channel; ///< time channel for end time
	float factor; ///< final factor to multiply
	int time_window; ///< back time window to search for
	int time_unit; ///< time unit
	float drop_missing_rate; ///< If missing time points beyond this threshold will drop measurement
	bool buffer_first; ///< If true will wait for first buffer to complete

	RepAggregateSignal() {
		processor_type = REP_PROCESS_AGGREGATE;
		work_channel = 0;
		start_time_channel = 0;
		end_time_channel = 0;
		factor = 1;
		time_unit = global_default_windows_time_unit;
		drop_missing_rate = 1;

		output_name = "calc_aggregate";
		time_window = 0;
		buffer_first = true;
	}

	/// @snippet RepProcess.cpp RepAggregateSignal::init
	int init(map<string, string>& mapper);
	void add_virtual_signals(map<string, int> &_virtual_signals);
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);
	void register_virtual_section_name_id(MedDictionarySections& dict);
	void set_required_signal_ids(MedDictionarySections& dict) {};
	void set_affected_signal_ids(MedDictionarySections& dict) {};

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be 
	/// implemented for all inheriting classes 
	/// </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	void print();
	ADD_CLASS_NAME(RepAggregateSignal)
		ADD_SERIALIZATION_FUNCS(processor_type, signalName, output_name, work_channel, factor, time_window, time_unit,
			start_time_channel, end_time_channel, drop_missing_rate, buffer_first, unconditional, req_signals, aff_signals, virtual_signals)
private:
	int v_out_sid = -1;
	int in_sid = -1;
};

//.......................................................................................
/** RepCheckReq does not actually process the repository but rather check each
	sample for compliance with some requirment, and adjust the sample's corresponding
	attribute.
	Currently, possible minimal requirements are -
	1.	Given a set of signals and a time window, return how many signals
		do not appear within the window prior to the sample time
*/
//.......................................................................................

class RepCheckReq : public RepProcessor {

public:
	vector<string> signalNames; ///< Required signals
	vector<int> signalIds; ///< Required signals ids

	vector<int> time_channels; ///< signals' time channels
	int win_from = 0, win_to = 0; ///< window to consider ;
	int window_time_unit = MedTime::Days; ///< window time-unit

	string attrName = "MissingReq"; ///< attribute name (set to 1 if compliant)

	// Helper
	vector<int> sig_time_units;

	/// <summary> constructor </summary>
	RepCheckReq() { processor_type = REP_PROCESS_CHECK_REQ; unconditional = true; }

	/// @snippet RepProcess.cpp RepCheckReq::init
	int init(map<string, string>& mapper);

	/// <summary> Set signal id </summary>
	void set_signal_ids(MedSignals& sigs);

	/// <summary> Fill req- and aff-signals vectors </summary>
	void init_lists();

	/// <summary> initialize time-nits </summary>
	void init_tables(MedDictionarySections& dict, MedSignals& sigs);

	/// <summary> Init attributes information : Should be implemented for inheriting classes that have attributes </summary>
	void init_attributes() { attributes = { attrName }; }

	// Learning - none done

	// Applying
	/// <summary> apply processing on a single PidDynamicRec at a set of time-points : Should be implemented for all inheriting classes </summary>
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	// serialization.
	ADD_CLASS_NAME(RepCheckReq)
		ADD_SERIALIZATION_FUNCS(processor_type, signalNames, time_channels, win_from, win_to, window_time_unit, attrName, req_signals)
};

//----------------------------------------------------------------------------------------
// RepHistoryLimit : given a signal : chomps history to be at a given window relative
//                   to prediction points
//----------------------------------------------------------------------------------------
class RepHistoryLimit : public RepProcessor {
public:
	string signalName; 	///< name of signal to clean
	int signalId;	///< id of signal to clean
	int time_channel = 0; ///< time channel to consider in cleaning
	int win_time_unit = global_default_windows_time_unit;
	int rep_time_unit = global_default_time_unit; // we assume this is also the samples time unit
	int win_from;
	int win_to;
	int delete_sig = 0; /// simply delete the signal (set it's len to 0).

	// default init
	void init_defaults() { processor_type = REP_PROCESS_HISTORY_LIMIT; }

	// preparations
	void set_signal_ids(MedSignals& sigs) { signalId = sigs.sid(signalName); }

	// learn - nothing to do
	int _learn(MedPidRepository& rep, MedSamples& samples, vector<RepProcessor *>& prev_processor) { return 0; }

	// apply
	int _apply(PidDynamicRec& rec, vector<int>& time_points, vector<vector<float>>& attributes_mat);

	// params parser
	int init(map<string, string>& mapper);

	// helper
	int get_sub_usv_data(UniversalSigVec &usv, int from_time, int to_time, vector<char> &data, int &len);

	/// Fill req- and aff-signals vectors
	void init_lists();

	ADD_CLASS_NAME(RepHistoryLimit)
		ADD_SERIALIZATION_FUNCS(signalName, time_channel, win_time_unit, rep_time_unit, win_from, win_to)

};

//.......................................................................................
//.......................................................................................
// Utility Functions
//.......................................................................................
//.......................................................................................

/// <summary> Get values of a signal from a set of samples applying a set of preceeding cleaners </summary>
int get_values(MedRepository& rep, MedSamples& samples, int signalId, int time_channel, int val_channel, float range_min, float range_max, vector<float>& values,
	vector<RepProcessor *>& prev_cleaners);
/// <summary> Get values of a signal from a set of samples </summary>
int get_values(MedRepository& rep, MedSamples& samples, int signalId, int time_channel, int val_channel, float range_min, float range_max, vector<float>& values);

//=======================================
// Joining the MedSerialze wagon
//=======================================
MEDSERIALIZE_SUPPORT(RepProcessor)
MEDSERIALIZE_SUPPORT(RepMultiProcessor)
MEDSERIALIZE_SUPPORT(RepBasicOutlierCleaner)
MEDSERIALIZE_SUPPORT(RepRuleBasedOutlierCleaner)
MEDSERIALIZE_SUPPORT(RepConfiguredOutlierCleaner)
MEDSERIALIZE_SUPPORT(RepNbrsOutlierCleaner)
MEDSERIALIZE_SUPPORT(RepCalcSimpleSignals)
MEDSERIALIZE_SUPPORT(RepSimValHandler)
MEDSERIALIZE_SUPPORT(RepPanelCompleter)
MEDSERIALIZE_SUPPORT(RepCombineSignals)
MEDSERIALIZE_SUPPORT(RepSplitSignal)
MEDSERIALIZE_SUPPORT(RepAggregationPeriod)
MEDSERIALIZE_SUPPORT(RepBasicRangeCleaner)
MEDSERIALIZE_SUPPORT(RepSignalRate)
MEDSERIALIZE_SUPPORT(RepAggregateSignal)
MEDSERIALIZE_SUPPORT(RepCheckReq)
MEDSERIALIZE_SUPPORT(RepHistoryLimit)
MEDSERIALIZE_SUPPORT(RepCreateRegistry)
#endif
