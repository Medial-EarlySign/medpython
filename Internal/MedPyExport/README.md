# Medial Python Binding

## Basic usage and HOWTO

For basic usage and howto please refer to __HOWTO.md__ file.
The following document contains c++-low-level details needed to further develop the binding.

## Objectives

__Allow us to__
1. Utilize our API from Python.
2. Using Python as a "Glue Language".
3. Be able to use python for prototyping, exploration, discovery.
4. Interoperability with other frameworks.
5. Minimal maintenance overhead when updating code.

## Implementation

For easy maintenance I think __SWIG__ is the best solution.

Other solutions exist, but...
1. Cython - A Python/C hybrid language - downside: adding another "language" to the process.
2. Boost::python - seem to have poor support and resource online. Requires maintening special definitions for each exported member.
3.  ctypes â€” A foreign function library for Python - calls C functions directly but requires correctly defining the parameters, might not be binary compatible when moving to other platforms.

__So SWIG was chosen__

1. It's an old binding generator project but has a lot of online resources.
2. Managing memory and ownership of python objects is complicated. SWIG takes care of that.
3. NumPy support seems good.

__Our implementation - Presenting "MedPyExport"__

* A library that will be added to  current Libs/Internal tree.
* It'll wrap our classes and export only the functions that we need and are usable under Python.
* All of us know C++ so this will require minimal learning curve to start contributing code to the python export lib.
* SWIG requires some definition files in a non-C++ format ( a single .i file that should be updated to enable NumPy typemaps). These can and will will be automatically generated from the code using scripts that are run during the building process.


__Notes and current pitfalls__:
1. vector<> should always be defined as std::vector.
2. After adding a new function or class it's best to 'shutdown' the jupyter notebook to fully relaod wrapper files.
3. Should use different names for numpy parameter of different types
4. No method overloading (but might be possible to implement)
5. No "big-data" looping - all actions should be implemented using a functional vectoric way using NumPy and Pandas
6. Buid system is seprate from the "create_cmake_files".
7. didn't find a way to convery data to a pandas DataFrame yet.
8. SWIG scanner can only deal with a very "simple c++ variant". We'll let it scan only the .h files and keep actual code separated in .cpp files. keep the scanner away from Medial libs and the standard libs using macros.
9. Compilation works both on Windows and Linus using separate build systems - a solution file for Windows and a cmake file for Linux. Execution was tested only on Linux(Node1) and on Jupyter.


__Build System__

The binding is aimed to be compiled and used on Linux nodes, however a VS soulution file was composed as well to provide the IDE support and ability to find compilation errors. So compilation on Windows+VS works but it will not produce a binary loadable by (the Windows Version of) Python. Since the binding needs special directives in the CMake file for SWIG, it doesn't use the create_cmake_files output but a different specialized cmake file.


__directory structure__

The binding is placed in MR/Libs/Internal/ :
* MedPyExport - contains VS solution and project files and the following subdirectories:
* * MedPyExport - contains source files for the project.
* * generate_binding  - cmake files and other files related to the binding generation.
* * * MedPython - contains SWIG interface files
* * * * scripts - Some helper scripts used during compilation

__Important Files__

In MR/Libs/Internal/MedPyExport/generate_binding/ you would find the following files:

* *make.sh* - bash script to start cmake building
* *MedPython/MedPython.i* - Main SWIG interface file for the binding
* *MedPython/medial-numpy.i* - Numpy SWIG interface file - to be able to use numpy's ndarrays
* *MedPython/MedPython.h* - Entry point for all .h files to be scanned by SWIG proccessor 
* *MedPython/MedPython.c* - Entry point for all .c files to be scanned by SWIG proccessor 
* *MedPython/pythoncode.i* - This is where we may add Python code to the binding.
* *MedPython/scripts/make_apply.py* - This is a script to scan and generate apply directives used for Numpy arrays.
* *MedPython/apply_directives.i* - A generated file, created by make_apply.py, containing apply autogenerated SWIG directives.

__Extending the Code__
```cpp
// .h file for the class 'PidRepository'

#include "MedPyCommon.h"

class MedPidRepository;

class MPPidRepository {
public:
	MedPidRepository* o;
    /*  
    ...
    */
};
```
* Include MedPyCommon.h which contains some utilities and helper macros.
* Exported class name starts with 'MP' (for "Medial Python") to avoid name conflicts in the c++ code. The exported class is renamed to 'PidRepository' in the above example.
* MedPidRepository\* o - pointer to the object instance we wrap. Note the class declaration - required so we can maintain simple header file and include the actual MedPidRepository only in implementation.
* Total seperation between code and headers - because SWIG need 'Simple' cpp files. Processing complex files with templates and C++11 code generated syntax errors during SWIG scan and should be avoided.

All .h files to be exported should have an include line in MedPyExport.h:

```cpp
#ifndef __MED_PY_EXPORT_H
#define __MED_PY_EXPORT_H

#include "MedPyExportExample.h"
#include "MPPidRepository.h"
#include "MPDictionary.h"
/* ... */
```
This file is the entry point for the SWIG parser.

To use the class we would write in Python:
```python
import medpython as med
rep = med.PidRepository()
```


__Adding a new class__
Writing wrapper code for a class in the API :
```cpp
class MPPidRepository {
public:
	MedPidRepository* o;

	MPPidRepository();
	~MPPidRepository();
    
    int read_all(const string &conf_fname);
    string dict_name(int section_id, int id);
    std::vector<bool> dict_prep_sets_lookup_table(int section_id, const std::vector<std::string> &set_names);
/* ... */
```

* Basic types are automatically mapped to Python maps: ```int, float, double, string, std::vector```. The mapped symbol for vector is '```std::vector```'. using the imported namespace symbol without the 'std::' prefix fails in case of vector, I wasn't able to fix this issue yet. For now use '```std::vector```'.

Implementation code in the .cpp file will look like this
```cpp
#include "MPPidRepository.h"
#include "InfraMed/InfraMed/MedPidRepository.h"

MPPidRepository::MPPidRepository() : o(new MedPidRepository()) {};
MPPidRepository::~MPPidRepository() { delete o; };
/* ... */
int MPPidRepository::read_all(const std::string &conf_fname){ return o->read_all(conf_fname); }
string MPPidRepository::dict_name(int section_id, int id) { return o->dict.name(section_id, id); }
/* ... */
```

__properties__
```cpp
class MPSamples {
    /* ... */
	int MEDPY_GET_time_unit();
	void MEDPY_SET_time_unit(int new_time_unit);
    /* ... */
```
* The property name in the above example will be 'time_unit':
```python
>>> s = med.Samples()
>>> s.time_unit
1
```
* You may implement object properties by implemennting a function with the prefix ```MEDPY_GET_``` or ```MEDPY_SET_``` or both.
* You may create a read only property by ommiting the ```MEDPY_SET_``` function.


__Static const variables__
Static variable are converted to class variables in Python:
```cpp
class MPTime {
public:
	// names for timing options
	 static const int Undefined;
	 static const int Date;
	 static const int Years;
/* ... */
```
Implementation in C++ file:
```cpp
#include "MPTime.h"
#include "MedTime/MedTime/MedTime.h"

const int MPTime::Undefined = MedTime::Undefined;
const int MPTime::Date = MedTime::Date;
```
This will output "1":
```python 
print med.Time.Date 
```

__Iterators__
Example for implementing an array iterator:
```cpp
class MPSigVectorAdaptor {
public:
    /* ... */
	int __len__();
	MPSig __getitem__(int i);
    /* ... */
```
* Array iterator - index is always int
* Class name must end with "VectorAdaptor" suffix.
* Class must implement ```__len__()``` and ```__getitem__(int i)```
* Python code in ```MedPyExport/generate_binding/MedPython/pythoncode.i``` creates the iterator type for this class. look at ```___fix_vecmap_iter()```

Example implementing a map iterator:
```cpp
class MPStringFeatureAttrMapAdaptor {
	std::map<std::string, FeatureAttr>* o;
public:
    /* ... */
    int __len__();
	MPFeatureAttr __getitem__(std::string key);
	void __setitem__(std::string key, MPFeatureAttr& val);
	std::vector<std::string> keys();
    /* ... */
```
* Map iterator - index is usually of string type.
* Class name must end with "MapAdaptor" suffix.
* Class must implement ```std::vector<string> keys()``` and ```__getitem__(string key)```
* Other Python special functions may be implemented as well, i.e. ```__len__()``` and ```__setitem__()```
* Python code in ```MedPyExport/generate_binding/MedPython/pythoncode.i``` creates the iterator type for this class. look at ```___fix_vecmap_iter()```


__NumPy Arrays__

Input arrays are defined as arrays of data that are passed into a routine but are not altered or returned to the user.The Python input array is therefore allowed to be almost any Python sequence(such as a list) that can be converted to the requested type of array. Example:
```cpp
class MPPidRepository {
    /* ... */
	int read_all(string conf_fname, MEDPY_NP_INPUT(int* pids_to_take, int num_pids_to_take) ...)

```


Inplace arrays are defined as arrays that are modified in-place.The input values may or may not be used, but the values at the time the function returns are significant.The provided Python argument must therefore be a NumPy array of the required type. Example:
```cpp
void MedPyExportExample::numpy_vec_in_out(MEDPY_NP_INPLACE(double* vec, int m))
```

Output arrays (Memory Managed Argout View Arrays) are arrays that appear in the input arguments in C++, but are in fact output arrays. If a wrapped function that uses these argout typemaps has more than one return argument, they are packed into a tuple or list. The Python user does not pass these arrays in, they simply get returned. Additinal parameter in the c++ code sets length of the allocated memory. The array should be allocated using malloc() call. Python will issue the free() call when it's time to dispose the associated python object using the GC or Python's del call. Example:
```cpp
class MPFeatures {
    /* ... */
    void MEDPY_GET_weights(MEDPY_NP_OUTPUT(float** float_out_buf, int* float_out_buf_len));
    /* ... */
```

Variant output - allows you to specify the output type of the array you return. Example:
```cpp
void getitem(string key, MEDPY_NP_VARIANT_OUTPUT(void** var_arr, int* var_arr_sz, int* var_arr_type)) {
	*var_arr_sz = 0;
	if (key == "i")
	{
		*var_arr = (void*)malloc(sizeof(int) * 10);
		*var_arr_sz = 10;
		*var_arr_type = (int)MED_NPY_TYPES::NPY_INT;
		for (int i = 0; i < 10; i++)
			((*(int**)var_arr))[i] = i * 5;
	}
	else if (key == "d")
	{
		*var_arr = (void*)malloc(sizeof(double) * 20);
		*var_arr_sz = 20;
		*var_arr_type = (int)MED_NPY_TYPES::NPY_DOUBLE;
		for (int i = 0; i < 20; i++)
			((*(double**)var_arr))[i] = i * 2.5;
	}
	else if (key == "f")
	{
		*var_arr = (void*)malloc(sizeof(float) * 15);
		*var_arr_sz = 15;
		*var_arr_type = (int)MED_NPY_TYPES::NPY_FLOAT;
		for (int i = 0; i < 15; i++)
			((*(float**)var_arr))[i] = i * 0.33333f;
	}
	else if (key == "n")
	{
		*var_arr = nullptr;
	}
}
```
You should pack a the binary array the way NumPy would expect it. Avalable types are:
```cpp
    NPY_BOOL = 0,
	NPY_BYTE, NPY_UBYTE,
	NPY_SHORT, NPY_USHORT,
	NPY_INT, NPY_UINT,
	NPY_LONG, NPY_ULONG,
	NPY_LONGLONG, NPY_ULONGLONG,
	NPY_FLOAT, NPY_DOUBLE, NPY_LONGDOUBLE,
	NPY_CFLOAT, NPY_CDOUBLE, NPY_CLONGDOUBLE,
	NPY_OBJECT = 17,
	NPY_STRING, NPY_UNICODE,
	NPY_VOID,
	NPY_DATETIME, NPY_TIMEDELTA, NPY_HALF,
	NPY_NTYPES,
	NPY_NOTYPE,
	NPY_CHAR,
	NPY_USERDEF = 256,
	NPY_NTYPES_ABI_COMPATIBLE = 21
```

__Other Tools and helper functions__

* Use MEDPY_DOC macro to add docstrings. These will be displayed when python help() is used:
```
MEDPY_DOC(function_or_class_name, docstring)
```
* Use MEDPY_IGNORE() macro to make swig skip the enclosed text.
```
MEDPY_IGNORE(...)
// same as:
#ifdef SWIG
// ...
#endif
```

* Use buf_to_vector() to convert an input buffer to a vector

```cpp
void MPFeatures::get_as_matrix(MPMat& mat, const vector<string> names, MEDPY_NP_INPUT(int* int_in_buf, int int_in_buf_len)) const {
	vector<int> idx;
	buf_to_vector(int_in_buf, int_in_buf_len, idx);
	o->get_as_matrix(*(mat.o), names, idx);
}
```

* Use vector_to_buf() to convert a vector into an output buffer:

```cpp
void MPFeatures::MEDPY_GET_weights(MEDPY_NP_OUTPUT(float** float_out_buf, int* float_out_buf_len)) {
	vector_to_buf(o->weights, float_out_buf, float_out_buf_len);
}
```

## Installation

To make the extension available for all Jupyter users on Node-2, Put 
```
medpython.py
_medpython.so
```
in directory
```
/home/python/.ipython
```
and the lib should be available using
```python
import medpython as med
```