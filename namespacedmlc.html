<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medial Code Documentation: dmlc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Medial Code Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">dmlc Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>namespace for dmlc  
<a href="namespacedmlc.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedmlc_1_1data" id="r_namespacedmlc_1_1data"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc_1_1data.html">data</a></td></tr>
<tr class="memdesc:namespacedmlc_1_1data"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for useful input data structure <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedmlc_1_1serializer" id="r_namespacedmlc_1_1serializer"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc_1_1serializer.html">serializer</a></td></tr>
<tr class="memdesc:namespacedmlc_1_1serializer"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal namespace for serializers <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1array__view.html">array_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read only data structure to reference continuous memory region of array. Provide unified view for vector, array and C style array. This data structure do not guarantee aliveness of referenced array.  <a href="classdmlc_1_1array__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1BlockingQueueThread.html">BlockingQueueThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking queue thread class.  <a href="classdmlc_1_1BlockingQueueThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Config.html">Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for config parser  <a href="classdmlc_1_1Config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1CustomLogMessage.html">CustomLogMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1DataIter.html">DataIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data iterator interface this is not a C++ style iterator, but nice for data pulling:) This interface is used to pull in the data The system can do some useful tricks for you like pre-fetching from disk and pre-computation.  <a href="classdmlc_1_1DataIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1DateLogger.html">DateLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1Error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception class that will be thrown by default logger if DMLC_LOG_FATAL_THROW == 1  <a href="structdmlc_1_1Error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1FunctionRegEntryBase.html">FunctionRegEntryBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for function registry.  <a href="classdmlc_1_1FunctionRegEntryBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1has__saveload.html">has_saveload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether a type have save/load function  <a href="structdmlc_1_1has__saveload.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1IfThenElseType.html">IfThenElseType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template to select type based on condition For example, IfThenElseType&lt;true, int, float&gt;::Type will give int  <a href="structdmlc_1_1IfThenElseType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">disambiguation tags that can be passed to the constructors of <a class="el" href="classdmlc_1_1optional.html" title="Is not constructible or convertible from any expression of type (possibly const) dmlc::optional&lt;U&gt;,...">dmlc::optional</a>. A tag type to tell constructor to construct its value in-place  <a href="structdmlc_1_1in__place__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html">InputSplit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">input split creates that allows reading of records from split of data, independent part that covers all the dataset  <a href="classdmlc_1_1InputSplit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplitShuffle.html">InputSplitShuffle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to construct input split with global shuffling  <a href="classdmlc_1_1InputSplitShuffle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether a type is arithemetic type  <a href="structdmlc_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether a type is floating point type  <a href="structdmlc_1_1is__floating__point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__integral.html">is_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether a type is integer type  <a href="structdmlc_1_1is__integral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__pod.html">is_pod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether a type is pod type  <a href="structdmlc_1_1is__pod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1istream.html">istream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a std::istream class that can can wrap <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization">Stream</a> objects, can use istream with that output to underlying <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization">Stream</a>  <a href="classdmlc_1_1istream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1JSONObjectReadHelper.html">JSONObjectReadHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to read JSON into a class or struct object.  <a href="classdmlc_1_1JSONObjectReadHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1JSONReader.html">JSONReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight JSON Reader to read any STL compositions and structs. The user need to know the schema of the.  <a href="classdmlc_1_1JSONReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1JSONWriter.html">JSONWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight json to write any STL compositions.  <a href="classdmlc_1_1JSONWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1LogMessage.html">LogMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1LogMessageFatal.html">LogMessageFatal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1LogMessageVoidify.html">LogMessageVoidify</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1LuaRef.html">LuaRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an reference to lua object  <a href="classdmlc_1_1LuaRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1LuaState.html">LuaState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lua state.  <a href="classdmlc_1_1LuaState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ManualEvent.html">ManualEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple manual-reset event gate which remains open after signalled.  <a href="classdmlc_1_1ManualEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1MemoryFixedSizeStream.html">MemoryFixedSizeStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization">Stream</a> that operates on fixed region of memory This class allows us to read/write from/to a fixed memory region.  <a href="structdmlc_1_1MemoryFixedSizeStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1MemoryPool.html">MemoryPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory pool that allocate memory of fixed size and alignment.  <a href="classdmlc_1_1MemoryPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1MemoryStringStream.html">MemoryStringStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A in memory stream that is backed by std::string. This class allows us to read/write from/to a std::string.  <a href="structdmlc_1_1MemoryStringStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dummy type for assign null to optional  <a href="structdmlc_1_1nullopt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1OMPException.html">OMPException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">OMP Exception class catches, saves and rethrows exception from OMP blocks.  <a href="classdmlc_1_1OMPException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is not constructible or convertible from any expression of type (possibly const) dmlc::optional&lt;U&gt;, i.e., the following 8 type traits are all false: Link: <a href="https://en.cppreference.com/w/cpp/utility/optional/optional">https://en.cppreference.com/w/cpp/utility/optional/optional</a>.  <a href="classdmlc_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ostream.html">ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a std::ostream class that can can wrap <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization">Stream</a> objects, can use ostream with that output to underlying <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization">Stream</a>  <a href="classdmlc_1_1ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser interface that parses input data used to load dmlc data format into your own data format Difference between <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> and <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a>: <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> caches the data internally that can be used to iterate the dataset multiple times, <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a> holds very limited internal state and was usually used to read data only once  <a href="classdmlc_1_1Parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1ParserFactoryReg.html">ParserFactoryReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">registry entry of parser factory  <a href="structdmlc_1_1ParserFactoryReg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RecordIOChunkReader.html">RecordIOChunkReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reader of binary recordio from Blob returned by <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> This class divides the blob into several independent parts specified by caller, and read from one segment. The part reading can be used together with <a class="el" href="classdmlc_1_1InputSplit.html#a2e835c07ce77d8d873592e006c242156" title="get a chunk of memory that can contain multiple records, the caller needs to parse the content of the...">InputSplit::NextChunk</a> for multi-threaded parsing(each thread take a RecordIOChunkReader)  <a href="classdmlc_1_1RecordIOChunkReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RecordIOReader.html">RecordIOReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reader of binary recordio to reads in record from stream  <a href="classdmlc_1_1RecordIOReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RecordIOWriter.html">RecordIOWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">writer of binary recordio binary format for recordio recordio format: magic lrecord data pad  <a href="classdmlc_1_1RecordIOWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdmlc_1_1Registry.html" title="Registry class. Registry can be used to register global singletons. The most commonly use case are fa...">Registry</a> class. <a class="el" href="classdmlc_1_1Registry.html" title="Registry class. Registry can be used to register global singletons. The most commonly use case are fa...">Registry</a> can be used to register global singletons. The most commonly use case are factory functions.  <a href="classdmlc_1_1Registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Row.html">Row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">one row of training instance  <a href="classdmlc_1_1Row.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1RowBlock.html">RowBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a block of data, containing several rows in sparse matrix This is useful for (streaming-sxtyle) algorithms that scans through rows of data examples include: <a class="el" href="classSGD.html">SGD</a>, GD, L-BFGS, kmeans  <a href="structdmlc_1_1RowBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RowBlockIter.html">RowBlockIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that holds the data <a class="el" href="classdmlc_1_1Row.html" title="one row of training instance">Row</a> block iterator interface that gets RowBlocks Difference between <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> and <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a>: <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> caches the data internally that can be used to iterate the dataset multiple times, <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a> holds very limited internal state and was usually used to read data only once.  <a href="classdmlc_1_1RowBlockIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1SeekStream.html">SeekStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface of i/o stream that support seek  <a href="classdmlc_1_1SeekStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Serializable.html">Serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for serializable objects  <a href="classdmlc_1_1Serializable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T.html">Str2T</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class that defines a single method <a class="el" href="classdmlc_1_1Str2T.html#ac648af3bae83e0e82e16cbfbd76d45c5" title="Convert a string into type T.">get()</a> to convert a string into type T. Define template specialization of this class to define the conversion method for a particular type.  <a href="classdmlc_1_1Str2T.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01double_01_4.html">Str2T&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for double type.  <a href="classdmlc_1_1Str2T_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01float_01_4.html">Str2T&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for float type.  <a href="classdmlc_1_1Str2T_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01int32__t_01_4.html">Str2T&lt; int32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for signed 32-bit integer.  <a href="classdmlc_1_1Str2T_3_01int32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01int64__t_01_4.html">Str2T&lt; int64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for signed 64-bit integer.  <a href="classdmlc_1_1Str2T_3_01int64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01uint32__t_01_4.html">Str2T&lt; uint32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for unsigned 32-bit integer.  <a href="classdmlc_1_1Str2T_3_01uint32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01uint64__t_01_4.html">Str2T&lt; uint64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for unsigned 64-bit integer.  <a href="classdmlc_1_1Str2T_3_01uint64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface of stream I/O for serialization  <a href="classdmlc_1_1Stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1TemporaryDirectory.html">TemporaryDirectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager class for temporary directories. Whenever a new <a class="el" href="classdmlc_1_1TemporaryDirectory.html" title="Manager class for temporary directories. Whenever a new TemporaryDirectory object is constructed,...">TemporaryDirectory</a> object is constructed, a temporary directory is created. The directory is deleted when the object is deleted or goes out of scope. Note: no symbolic links are allowed inside the temporary directory.  <a href="classdmlc_1_1TemporaryDirectory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadGroup.html">ThreadGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdmlc_1_1ThreadGroup_1_1Thread.html" title="Lifecycle-managed thread (used by ThreadGroup)">Thread</a> lifecycle management group.  <a href="classdmlc_1_1ThreadGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadlocalAllocator.html">ThreadlocalAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread local allocator that get memory from a threadlocal memory pool. This is suitable to allocate objects that do not cross thread.  <a href="classdmlc_1_1ThreadlocalAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1ThreadlocalSharedPtr.html">ThreadlocalSharedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a shared pointer like type that allocate object from a threadlocal object pool. This object is not thread-safe but can be faster than shared_ptr in certain usecases.  <a href="structdmlc_1_1ThreadlocalSharedPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadLocalStore.html">ThreadLocalStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A threadlocal store to store threadlocal variables. Will return a thread local singleton of type T.  <a href="classdmlc_1_1ThreadLocalStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1TimerThread.html">TimerThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed timer thread.  <a href="classdmlc_1_1TimerThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1Token.html">Token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1TokenizeError.html">TokenizeError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Tokenizer.html">Tokenizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1type__name__helper.html">type_name_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class to construct a string that represents type name  <a href="structdmlc_1_1type__name__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab23d78846b42ebd3a436e3bc295b73f4" id="r_ab23d78846b42ebd3a436e3bc295b73f4"><td class="memItemLeft" align="right" valign="top"><a id="ab23d78846b42ebd3a436e3bc295b73f4" name="ab23d78846b42ebd3a436e3bc295b73f4"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><b>real_t</b></td></tr>
<tr class="memdesc:ab23d78846b42ebd3a436e3bc295b73f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">this defines the float point that will be used to store feature values <br /></td></tr>
<tr class="separator:ab23d78846b42ebd3a436e3bc295b73f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a89c6e0909617034aa818dafe83a361" id="r_a7a89c6e0909617034aa818dafe83a361"><td class="memItemLeft" align="right" valign="top"><a id="a7a89c6e0909617034aa818dafe83a361" name="a7a89c6e0909617034aa818dafe83a361"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>index_t</b></td></tr>
<tr class="memdesc:a7a89c6e0909617034aa818dafe83a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">this defines the unsigned integer type that can normally be used to store feature index <br /></td></tr>
<tr class="separator:a7a89c6e0909617034aa818dafe83a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a0a94dbddd4d45858d7a53c1f63ea4" id="r_a74a0a94dbddd4d45858d7a53c1f63ea4"><td class="memTemplParams" colspan="2"><a id="a74a0a94dbddd4d45858d7a53c1f63ea4" name="a74a0a94dbddd4d45858d7a53c1f63ea4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74a0a94dbddd4d45858d7a53c1f63ea4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>decay_t</b> = typename std::decay&lt; T &gt;::type</td></tr>
<tr class="memdesc:a74a0a94dbddd4d45858d7a53c1f63ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++14 aliases. <br /></td></tr>
<tr class="separator:a74a0a94dbddd4d45858d7a53c1f63ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadcbab6f16a9a651194e896e60b2c44" id="r_aaadcbab6f16a9a651194e896e60b2c44"><td class="memTemplParams" colspan="2"><a id="aaadcbab6f16a9a651194e896e60b2c44" name="aaadcbab6f16a9a651194e896e60b2c44"></a>
template&lt;bool B, typename T  = void&gt; </td></tr>
<tr class="memitem:aaadcbab6f16a9a651194e896e60b2c44"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_t</b> = typename std::enable_if&lt; B, T &gt;::type</td></tr>
<tr class="separator:aaadcbab6f16a9a651194e896e60b2c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32108124663e1a58caf50f2435db8d46" id="r_a32108124663e1a58caf50f2435db8d46"><td class="memTemplParams" colspan="2"><a id="a32108124663e1a58caf50f2435db8d46" name="a32108124663e1a58caf50f2435db8d46"></a>
template&lt;typename T , typename U , typename Other &gt; </td></tr>
<tr class="memitem:a32108124663e1a58caf50f2435db8d46"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_constructor_from_other</b> = enable_if_t&lt; std::is_constructible&lt; T, Other &gt;::value &amp;&amp;!std::is_constructible&lt; T, <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; U &gt; &amp; &gt;::value &amp;&amp;!std::is_constructible&lt; T, <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp; &gt;::value &amp;&amp;!std::is_convertible&lt; <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; U &gt; &amp;, T &gt;::value &amp;&amp;!std::is_convertible&lt; <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp;, T &gt;::value &amp;&amp;!std::is_constructible&lt; T, const <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; U &gt; &amp; &gt;::value &amp;&amp;!std::is_constructible&lt; T, const <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp; &gt;::value &amp;&amp;!std::is_convertible&lt; const <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; U &gt; &amp;, T &gt;::value &amp;&amp;!std::is_convertible&lt; const <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp;, T &gt;::value &gt;</td></tr>
<tr class="separator:a32108124663e1a58caf50f2435db8d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5308ebafab161658e4c59e426fdd968c" id="r_a5308ebafab161658e4c59e426fdd968c"><td class="memTemplParams" colspan="2"><a id="a5308ebafab161658e4c59e426fdd968c" name="a5308ebafab161658e4c59e426fdd968c"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5308ebafab161658e4c59e426fdd968c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_constructor_from_value</b> = enable_if_t&lt; std::is_constructible&lt; T, U &amp;&amp; &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedmlc.html#a74a0a94dbddd4d45858d7a53c1f63ea4">decay_t</a>&lt; U &gt;, <a class="el" href="structdmlc_1_1in__place__t.html">in_place_t</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt;, <a class="el" href="namespacedmlc.html#a74a0a94dbddd4d45858d7a53c1f63ea4">decay_t</a>&lt; U &gt; &gt;::value &gt;</td></tr>
<tr class="separator:a5308ebafab161658e4c59e426fdd968c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fec5df74dfed6c51540a1fcf5bae54" id="r_a34fec5df74dfed6c51540a1fcf5bae54"><td class="memItemLeft" align="right" valign="top"><a id="a34fec5df74dfed6c51540a1fcf5bae54" name="a34fec5df74dfed6c51540a1fcf5bae54"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SharedMutex</b> = std::recursive_mutex</td></tr>
<tr class="memdesc:a34fec5df74dfed6c51540a1fcf5bae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard mutex for C++ &lt; 14. <br /></td></tr>
<tr class="separator:a34fec5df74dfed6c51540a1fcf5bae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad58a9dfecc6e970348c217de29bb916" id="r_aad58a9dfecc6e970348c217de29bb916"><td class="memItemLeft" align="right" valign="top"><a id="aad58a9dfecc6e970348c217de29bb916" name="aad58a9dfecc6e970348c217de29bb916"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>WriteLock</b> = std::unique_lock&lt; <a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a> &gt;</td></tr>
<tr class="memdesc:aad58a9dfecc6e970348c217de29bb916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard unique lock for C++ &lt; 14. <br /></td></tr>
<tr class="separator:aad58a9dfecc6e970348c217de29bb916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591cc4d1980f6074fbc450bcf9d40876" id="r_a591cc4d1980f6074fbc450bcf9d40876"><td class="memItemLeft" align="right" valign="top"><a id="a591cc4d1980f6074fbc450bcf9d40876" name="a591cc4d1980f6074fbc450bcf9d40876"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ReadLock</b> = std::unique_lock&lt; <a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a> &gt;</td></tr>
<tr class="memdesc:a591cc4d1980f6074fbc450bcf9d40876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard unique lock for C++ &lt; 14. <br /></td></tr>
<tr class="separator:a591cc4d1980f6074fbc450bcf9d40876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1499d14a38b1ebfa0f12120b941cab89" id="r_a1499d14a38b1ebfa0f12120b941cab89"><td class="memItemLeft" align="right" valign="top"><a id="a1499d14a38b1ebfa0f12120b941cab89" name="a1499d14a38b1ebfa0f12120b941cab89"></a>
typedef <a class="el" href="structdmlc_1_1ParserFactoryReg.html">ParserFactoryReg</a>&lt; uint32_t, <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Reg32flt</b></td></tr>
<tr class="separator:a1499d14a38b1ebfa0f12120b941cab89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38791a0054d9ae6d0b922b7aa5dadb9" id="r_ae38791a0054d9ae6d0b922b7aa5dadb9"><td class="memItemLeft" align="right" valign="top"><a id="ae38791a0054d9ae6d0b922b7aa5dadb9" name="ae38791a0054d9ae6d0b922b7aa5dadb9"></a>
typedef <a class="el" href="structdmlc_1_1ParserFactoryReg.html">ParserFactoryReg</a>&lt; uint32_t, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Reg32int32</b></td></tr>
<tr class="separator:ae38791a0054d9ae6d0b922b7aa5dadb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e975627c588ce278066bbbffc0cdb39" id="r_a2e975627c588ce278066bbbffc0cdb39"><td class="memItemLeft" align="right" valign="top"><a id="a2e975627c588ce278066bbbffc0cdb39" name="a2e975627c588ce278066bbbffc0cdb39"></a>
typedef <a class="el" href="structdmlc_1_1ParserFactoryReg.html">ParserFactoryReg</a>&lt; uint32_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Reg32int64</b></td></tr>
<tr class="separator:a2e975627c588ce278066bbbffc0cdb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eda68a297ecf9e19ad1aa1cc5ddd4c" id="r_ac4eda68a297ecf9e19ad1aa1cc5ddd4c"><td class="memItemLeft" align="right" valign="top"><a id="ac4eda68a297ecf9e19ad1aa1cc5ddd4c" name="ac4eda68a297ecf9e19ad1aa1cc5ddd4c"></a>
typedef <a class="el" href="structdmlc_1_1ParserFactoryReg.html">ParserFactoryReg</a>&lt; uint64_t, <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Reg64flt</b></td></tr>
<tr class="separator:ac4eda68a297ecf9e19ad1aa1cc5ddd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a60e8d7e97e09831c42b15c092b9a3" id="r_ad3a60e8d7e97e09831c42b15c092b9a3"><td class="memItemLeft" align="right" valign="top"><a id="ad3a60e8d7e97e09831c42b15c092b9a3" name="ad3a60e8d7e97e09831c42b15c092b9a3"></a>
typedef <a class="el" href="structdmlc_1_1ParserFactoryReg.html">ParserFactoryReg</a>&lt; uint64_t, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Reg64int32</b></td></tr>
<tr class="separator:ad3a60e8d7e97e09831c42b15c092b9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b509dd8e68b288802959e6291053aa4" id="r_a6b509dd8e68b288802959e6291053aa4"><td class="memItemLeft" align="right" valign="top"><a id="a6b509dd8e68b288802959e6291053aa4" name="a6b509dd8e68b288802959e6291053aa4"></a>
typedef <a class="el" href="structdmlc_1_1ParserFactoryReg.html">ParserFactoryReg</a>&lt; uint64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Reg64int64</b></td></tr>
<tr class="separator:a6b509dd8e68b288802959e6291053aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af40568bf088237205d2cd9e0a31ddf41" id="r_af40568bf088237205d2cd9e0a31ddf41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af40568bf088237205d2cd9e0a31ddf41"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#af40568bf088237205d2cd9e0a31ddf41">BeginPtr</a> (std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:af40568bf088237205d2cd9e0a31ddf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">safely get the beginning address of a vector  <br /></td></tr>
<tr class="separator:af40568bf088237205d2cd9e0a31ddf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b1692c4ad890ec97d517f7b003a0d4" id="r_a94b1692c4ad890ec97d517f7b003a0d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94b1692c4ad890ec97d517f7b003a0d4"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a94b1692c4ad890ec97d517f7b003a0d4">BeginPtr</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a94b1692c4ad890ec97d517f7b003a0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the beginning address of a const vector  <br /></td></tr>
<tr class="separator:a94b1692c4ad890ec97d517f7b003a0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95043d393d63392acb7755e53e2e494f" id="r_a95043d393d63392acb7755e53e2e494f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a95043d393d63392acb7755e53e2e494f">BeginPtr</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a95043d393d63392acb7755e53e2e494f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the beginning address of a string  <br /></td></tr>
<tr class="separator:a95043d393d63392acb7755e53e2e494f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbd11e398aee363da3d0f38eac86723" id="r_a4fbd11e398aee363da3d0f38eac86723"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a4fbd11e398aee363da3d0f38eac86723">BeginPtr</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a4fbd11e398aee363da3d0f38eac86723"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the beginning address of a const string  <br /></td></tr>
<tr class="separator:a4fbd11e398aee363da3d0f38eac86723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c199c2feea75fbf019a4f80831781e0" id="r_a2c199c2feea75fbf019a4f80831781e0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a2c199c2feea75fbf019a4f80831781e0">Split</a> (const std::string &amp;s, char delim)</td></tr>
<tr class="memdesc:a2c199c2feea75fbf019a4f80831781e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string by delimiter.  <br /></td></tr>
<tr class="separator:a2c199c2feea75fbf019a4f80831781e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8620a9c7572cd3aab1ed3135b7a8e137" id="r_a8620a9c7572cd3aab1ed3135b7a8e137"><td class="memTemplParams" colspan="2"><a id="a8620a9c7572cd3aab1ed3135b7a8e137" name="a8620a9c7572cd3aab1ed3135b7a8e137"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8620a9c7572cd3aab1ed3135b7a8e137"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HashCombine</b> (size_t key, const T &amp;value)</td></tr>
<tr class="memdesc:a8620a9c7572cd3aab1ed3135b7a8e137"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash an object and combines the key with previous keys <br /></td></tr>
<tr class="separator:a8620a9c7572cd3aab1ed3135b7a8e137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be2b34771107606d968712e54b25ce6" id="r_a0be2b34771107606d968712e54b25ce6"><td class="memItemLeft" align="right" valign="top"><a id="a0be2b34771107606d968712e54b25ce6" name="a0be2b34771107606d968712e54b25ce6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0be2b34771107606d968712e54b25ce6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HashCombine&lt; size_t &gt;</b> (size_t key, const size_t &amp;value)</td></tr>
<tr class="memdesc:a0be2b34771107606d968712e54b25ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialize for size_t <br /></td></tr>
<tr class="separator:a0be2b34771107606d968712e54b25ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe9d2411f71ee9f165b44bd0a6fbad1" id="r_adbe9d2411f71ee9f165b44bd0a6fbad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#adbe9d2411f71ee9f165b44bd0a6fbad1">ByteSwap</a> (void *data, size_t elem_bytes, size_t num_elems)</td></tr>
<tr class="memdesc:adbe9d2411f71ee9f165b44bd0a6fbad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic inplace byte swapping function.  <br /></td></tr>
<tr class="separator:adbe9d2411f71ee9f165b44bd0a6fbad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6792a114f65c6214d43b93b91f70c26a" id="r_a6792a114f65c6214d43b93b91f70c26a"><td class="memItemLeft" align="right" valign="top"><a id="a6792a114f65c6214d43b93b91f70c26a" name="a6792a114f65c6214d43b93b91f70c26a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>LogStackTraceLevel</b> ()</td></tr>
<tr class="separator:a6792a114f65c6214d43b93b91f70c26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34e80be7885c144bb9243287e828030" id="r_ad34e80be7885c144bb9243287e828030"><td class="memItemLeft" align="right" valign="top"><a id="ad34e80be7885c144bb9243287e828030" name="ad34e80be7885c144bb9243287e828030"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>demangle</b> (char const *msg_str)</td></tr>
<tr class="separator:ad34e80be7885c144bb9243287e828030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1e8afc13144690dac5852de917ac0c" id="r_abb1e8afc13144690dac5852de917ac0c"><td class="memItemLeft" align="right" valign="top"><a id="abb1e8afc13144690dac5852de917ac0c" name="abb1e8afc13144690dac5852de917ac0c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>StackTrace</b> (size_t start_frame=1, const size_t stack_size=0)</td></tr>
<tr class="separator:abb1e8afc13144690dac5852de917ac0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa794506260738bfd4b53688bfbee14" id="r_aaaa794506260738bfd4b53688bfbee14"><td class="memItemLeft" align="right" valign="top"><a id="aaaa794506260738bfd4b53688bfbee14" name="aaaa794506260738bfd4b53688bfbee14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitLogging</b> (const char *)</td></tr>
<tr class="separator:aaaa794506260738bfd4b53688bfbee14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34728bb01fd2b6254eca024c7fae079c" id="r_a34728bb01fd2b6254eca024c7fae079c"><td class="memItemLeft" align="right" valign="top"><a id="a34728bb01fd2b6254eca024c7fae079c" name="a34728bb01fd2b6254eca024c7fae079c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DebugLoggingEnabled</b> ()</td></tr>
<tr class="separator:a34728bb01fd2b6254eca024c7fae079c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecc53a4c2365543facf4a4d446d27e0" id="r_a0ecc53a4c2365543facf4a4d446d27e0"><td class="memTemplParams" colspan="2"><a id="a0ecc53a4c2365543facf4a4d446d27e0" name="a0ecc53a4c2365543facf4a4d446d27e0"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a0ecc53a4c2365543facf4a4d446d27e0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LogCheckFormat</b> (const X &amp;x, const Y &amp;y)</td></tr>
<tr class="separator:a0ecc53a4c2365543facf4a4d446d27e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a6131e0453b827073b39eeef55b98d" id="r_a77a6131e0453b827073b39eeef55b98d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77a6131e0453b827073b39eeef55b98d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a77a6131e0453b827073b39eeef55b98d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a77a6131e0453b827073b39eeef55b98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize an optional object to string.  <br /></td></tr>
<tr class="separator:a77a6131e0453b827073b39eeef55b98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff849eb74b4604e70e042dc681819e3d" id="r_aff849eb74b4604e70e042dc681819e3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff849eb74b4604e70e042dc681819e3d"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aff849eb74b4604e70e042dc681819e3d">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:aff849eb74b4604e70e042dc681819e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a string object into optional&lt;T&gt;  <br /></td></tr>
<tr class="separator:aff849eb74b4604e70e042dc681819e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a9751c06102127c75d4203ae6e29c" id="r_a4c5a9751c06102127c75d4203ae6e29c"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a4c5a9751c06102127c75d4203ae6e29c">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt; &amp;t)</td></tr>
<tr class="memdesc:a4c5a9751c06102127c75d4203ae6e29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of '&gt;&gt;' istream parsing for <a class="el" href="classdmlc_1_1optional.html">optional&lt;bool&gt;</a>  <br /></td></tr>
<tr class="separator:a4c5a9751c06102127c75d4203ae6e29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e0e4f86115e4c4e7f761de5c8a6797" id="r_ae0e0e4f86115e4c4e7f761de5c8a6797"><td class="memItemLeft" align="right" valign="top"><a id="ae0e0e4f86115e4c4e7f761de5c8a6797" name="ae0e0e4f86115e4c4e7f761de5c8a6797"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_DECLARE_TYPE_NAME</b> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; int &gt;, &quot;int or None&quot;)</td></tr>
<tr class="memdesc:ae0e0e4f86115e4c4e7f761de5c8a6797"><td class="mdescLeft">&#160;</td><td class="mdescRight">description for optional int <br /></td></tr>
<tr class="separator:ae0e0e4f86115e4c4e7f761de5c8a6797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45790e76c170593a12e9a31c2ca547a8" id="r_a45790e76c170593a12e9a31c2ca547a8"><td class="memItemLeft" align="right" valign="top"><a id="a45790e76c170593a12e9a31c2ca547a8" name="a45790e76c170593a12e9a31c2ca547a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_DECLARE_TYPE_NAME</b> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt;, &quot;boolean or None&quot;)</td></tr>
<tr class="memdesc:a45790e76c170593a12e9a31c2ca547a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">description for optional bool <br /></td></tr>
<tr class="separator:a45790e76c170593a12e9a31c2ca547a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d7950ad6b6392afa1ec41fa42bfbf6" id="r_aa8d7950ad6b6392afa1ec41fa42bfbf6"><td class="memItemLeft" align="right" valign="top"><a id="aa8d7950ad6b6392afa1ec41fa42bfbf6" name="aa8d7950ad6b6392afa1ec41fa42bfbf6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_DECLARE_TYPE_NAME</b> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; float &gt;, &quot;float or None&quot;)</td></tr>
<tr class="memdesc:aa8d7950ad6b6392afa1ec41fa42bfbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">description for optional float <br /></td></tr>
<tr class="separator:aa8d7950ad6b6392afa1ec41fa42bfbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24514e2baa4d33161ba4cde558e6245e" id="r_a24514e2baa4d33161ba4cde558e6245e"><td class="memItemLeft" align="right" valign="top"><a id="a24514e2baa4d33161ba4cde558e6245e" name="a24514e2baa4d33161ba4cde558e6245e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_DECLARE_TYPE_NAME</b> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; double &gt;, &quot;double or None&quot;)</td></tr>
<tr class="memdesc:a24514e2baa4d33161ba4cde558e6245e"><td class="mdescLeft">&#160;</td><td class="mdescRight">description for optional double <br /></td></tr>
<tr class="separator:a24514e2baa4d33161ba4cde558e6245e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dcf01c9ba22be9b08e455194fb2ab3" id="r_a52dcf01c9ba22be9b08e455194fb2ab3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a52dcf01c9ba22be9b08e455194fb2ab3">isspace</a> (char c)</td></tr>
<tr class="memdesc:a52dcf01c9ba22be9b08e455194fb2ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline implementation of <a class="el" href="namespacedmlc.html#a52dcf01c9ba22be9b08e455194fb2ab3" title="Inline implementation of isspace(). Tests whether the given character is a whitespace letter.">isspace()</a>. Tests whether the given character is a whitespace letter.  <br /></td></tr>
<tr class="separator:a52dcf01c9ba22be9b08e455194fb2ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382379acc79620379a9f7ee29ad5caaf" id="r_a382379acc79620379a9f7ee29ad5caaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a382379acc79620379a9f7ee29ad5caaf">isblank</a> (char c)</td></tr>
<tr class="memdesc:a382379acc79620379a9f7ee29ad5caaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline implementation of <a class="el" href="namespacedmlc.html#a382379acc79620379a9f7ee29ad5caaf" title="Inline implementation of isblank(). Tests whether the given character is a space or tab character.">isblank()</a>. Tests whether the given character is a space or tab character.  <br /></td></tr>
<tr class="separator:a382379acc79620379a9f7ee29ad5caaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dab1c816301d0261e96d002ab157d3a" id="r_a5dab1c816301d0261e96d002ab157d3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a5dab1c816301d0261e96d002ab157d3a">isdigit</a> (char c)</td></tr>
<tr class="memdesc:a5dab1c816301d0261e96d002ab157d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline implementation of <a class="el" href="namespacedmlc.html#a5dab1c816301d0261e96d002ab157d3a" title="Inline implementation of isdigit(). Tests whether the given character is a decimal digit.">isdigit()</a>. Tests whether the given character is a decimal digit.  <br /></td></tr>
<tr class="separator:a5dab1c816301d0261e96d002ab157d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8234006cb1d67dcba5f9f856fe805c19" id="r_a8234006cb1d67dcba5f9f856fe805c19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a8234006cb1d67dcba5f9f856fe805c19">isalpha</a> (char c)</td></tr>
<tr class="memdesc:a8234006cb1d67dcba5f9f856fe805c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline implementation of <a class="el" href="namespacedmlc.html#a8234006cb1d67dcba5f9f856fe805c19" title="Inline implementation of isalpha(). Tests whether the given character is an alphabet letter.">isalpha()</a>. Tests whether the given character is an alphabet letter.  <br /></td></tr>
<tr class="separator:a8234006cb1d67dcba5f9f856fe805c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc240ae898cb7f29bd88c5bd96bd3cb" id="r_aadc240ae898cb7f29bd88c5bd96bd3cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aadc240ae898cb7f29bd88c5bd96bd3cb">isdigitchars</a> (char c)</td></tr>
<tr class="memdesc:aadc240ae898cb7f29bd88c5bd96bd3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given character is a valid letter in the string representation of a floating-point value, i.e. decimal digits, signs (+/-), decimal point (.), or exponent marker (e/E).  <br /></td></tr>
<tr class="separator:aadc240ae898cb7f29bd88c5bd96bd3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade80237502ab5ae86b9c1454a09c66ee" id="r_ade80237502ab5ae86b9c1454a09c66ee"><td class="memTemplParams" colspan="2">template&lt;typename FloatType , bool CheckRange = false&gt; </td></tr>
<tr class="memitem:ade80237502ab5ae86b9c1454a09c66ee"><td class="memTemplItemLeft" align="right" valign="top">FloatType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ade80237502ab5ae86b9c1454a09c66ee">ParseFloat</a> (const char *nptr, char **endptr)</td></tr>
<tr class="memdesc:ade80237502ab5ae86b9c1454a09c66ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common implementation for <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information....">dmlc::strtof()</a> and <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information....">dmlc::strtod()</a> TODO: the current version does not support hex number.  <br /></td></tr>
<tr class="separator:ade80237502ab5ae86b9c1454a09c66ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c2c8f7859b02cecb9c094cddd91af9" id="r_a93c2c8f7859b02cecb9c094cddd91af9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9">strtof</a> (const char *nptr, char **endptr)</td></tr>
<tr class="memdesc:a93c2c8f7859b02cecb9c094cddd91af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information....">strtof()</a>. See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use <a class="el" href="namespacedmlc.html#a3717fca311a75301eedca7e77e744459" title="A faster implementation of strtof(). See documentation of std::strtof() for more information....">strtof_check_range()</a> to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <br /></td></tr>
<tr class="separator:a93c2c8f7859b02cecb9c094cddd91af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3717fca311a75301eedca7e77e744459" id="r_a3717fca311a75301eedca7e77e744459"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a3717fca311a75301eedca7e77e744459">strtof_check_range</a> (const char *nptr, char **endptr)</td></tr>
<tr class="memdesc:a3717fca311a75301eedca7e77e744459"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information....">strtof()</a>. See documentation of std::strtof() for more information. This function will check for overflow. If the converted value is outside the range for the float type, errno is set to ERANGE and HUGE_VALF is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <br /></td></tr>
<tr class="separator:a3717fca311a75301eedca7e77e744459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345b262c3cbb6d700c22c4d69d46db6e" id="r_a345b262c3cbb6d700c22c4d69d46db6e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e">strtod</a> (const char *nptr, char **endptr)</td></tr>
<tr class="memdesc:a345b262c3cbb6d700c22c4d69d46db6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information....">strtod()</a>. See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use <a class="el" href="namespacedmlc.html#abd212a404ead6ae94faa2b65b4af796d" title="A faster implementation of strtod(). See documentation of std::strtod() for more information....">strtod_check_range()</a> to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <br /></td></tr>
<tr class="separator:a345b262c3cbb6d700c22c4d69d46db6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd212a404ead6ae94faa2b65b4af796d" id="r_abd212a404ead6ae94faa2b65b4af796d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#abd212a404ead6ae94faa2b65b4af796d">strtod_check_range</a> (const char *nptr, char **endptr)</td></tr>
<tr class="memdesc:abd212a404ead6ae94faa2b65b4af796d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information....">strtod()</a>. See documentation of std::strtod() for more information. This function will check for overflow. If the converted value is outside the range for the double type, errno is set to ERANGE and HUGE_VAL is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <br /></td></tr>
<tr class="separator:abd212a404ead6ae94faa2b65b4af796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe766bbcae14a7ff2720bb248cca0db9" id="r_abe766bbcae14a7ff2720bb248cca0db9"><td class="memTemplParams" colspan="2">template&lt;typename SignedIntType &gt; </td></tr>
<tr class="memitem:abe766bbcae14a7ff2720bb248cca0db9"><td class="memTemplItemLeft" align="right" valign="top">SignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#abe766bbcae14a7ff2720bb248cca0db9">ParseSignedInt</a> (const char *nptr, char **endptr, int base)</td></tr>
<tr class="memdesc:abe766bbcae14a7ff2720bb248cca0db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast string-to-integer convertor, for signed integers TODO: the current version supports only base &lt;= 10.  <br /></td></tr>
<tr class="separator:abe766bbcae14a7ff2720bb248cca0db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d2f93a1b7b7683df3c674e0c3d1863" id="r_ae5d2f93a1b7b7683df3c674e0c3d1863"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType &gt; </td></tr>
<tr class="memitem:ae5d2f93a1b7b7683df3c674e0c3d1863"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ae5d2f93a1b7b7683df3c674e0c3d1863">ParseUnsignedInt</a> (const char *nptr, char **endptr, int base)</td></tr>
<tr class="memdesc:ae5d2f93a1b7b7683df3c674e0c3d1863"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast string-to-integer convertor, for unsigned integers TODO: the current version supports only base &lt;= 10.  <br /></td></tr>
<tr class="separator:ae5d2f93a1b7b7683df3c674e0c3d1863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63dcf48b6a8ec204720a121f01477e9" id="r_ac63dcf48b6a8ec204720a121f01477e9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ac63dcf48b6a8ec204720a121f01477e9">strtoull</a> (const char *nptr, char **endptr, int base)</td></tr>
<tr class="memdesc:ac63dcf48b6a8ec204720a121f01477e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#ac63dcf48b6a8ec204720a121f01477e9" title="A faster implementation of strtoull(). See documentation of std::strtoull() for more information....">strtoull()</a>. See documentation of std::strtoull() for more information. Note that this function does not check for overflow. TODO: the current version supports only base &lt;= 10.  <br /></td></tr>
<tr class="separator:ac63dcf48b6a8ec204720a121f01477e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a57f902842152f71261ab44e887017" id="r_a46a57f902842152f71261ab44e887017"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a46a57f902842152f71261ab44e887017">atol</a> (const char *p)</td></tr>
<tr class="memdesc:a46a57f902842152f71261ab44e887017"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a46a57f902842152f71261ab44e887017" title="A faster implementation of atol(). See documentation of std::atol() for more information....">atol()</a>. See documentation of std::atol() for more information. This function will use base 10. Note that this function does not check for overflow.  <br /></td></tr>
<tr class="separator:a46a57f902842152f71261ab44e887017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6820d1e6705361c263364b709d15a8" id="r_a4c6820d1e6705361c263364b709d15a8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a4c6820d1e6705361c263364b709d15a8">atof</a> (const char *nptr)</td></tr>
<tr class="memdesc:a4c6820d1e6705361c263364b709d15a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a4c6820d1e6705361c263364b709d15a8" title="A faster implementation of atof(). Unlike std::atof(), this function returns float type....">atof()</a>. Unlike std::atof(), this function returns float type. Note that this function does not check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <br /></td></tr>
<tr class="separator:a4c6820d1e6705361c263364b709d15a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a149fb880b527d393975a884255341" id="r_a43a149fb880b527d393975a884255341"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a43a149fb880b527d393975a884255341">stof</a> (const std::string &amp;value, size_t *pos=nullptr)</td></tr>
<tr class="memdesc:a43a149fb880b527d393975a884255341"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a43a149fb880b527d393975a884255341" title="A faster implementation of stof(). See documentation of std::stof() for more information....">stof()</a>. See documentation of std::stof() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <br /></td></tr>
<tr class="separator:a43a149fb880b527d393975a884255341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f49479b0736b8709986ead800e1bfdc" id="r_a5f49479b0736b8709986ead800e1bfdc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a5f49479b0736b8709986ead800e1bfdc">stod</a> (const std::string &amp;value, size_t *pos=nullptr)</td></tr>
<tr class="memdesc:a5f49479b0736b8709986ead800e1bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a5f49479b0736b8709986ead800e1bfdc" title="A faster implementation of stod(). See documentation of std::stod() for more information....">stod()</a>. See documentation of std::stod() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <br /></td></tr>
<tr class="separator:a5f49479b0736b8709986ead800e1bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1cfbbeeb3029867e8b8aa0278ac311" id="r_aad1cfbbeeb3029867e8b8aa0278ac311"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad1cfbbeeb3029867e8b8aa0278ac311"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aad1cfbbeeb3029867e8b8aa0278ac311">Str2Type</a> (const char *begin)</td></tr>
<tr class="memdesc:aad1cfbbeeb3029867e8b8aa0278ac311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for converting string into type T.  <br /></td></tr>
<tr class="separator:aad1cfbbeeb3029867e8b8aa0278ac311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bd2f744b450d3a7a06fd4e4276f667" id="r_ac1bd2f744b450d3a7a06fd4e4276f667"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac1bd2f744b450d3a7a06fd4e4276f667"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ac1bd2f744b450d3a7a06fd4e4276f667">ParsePair</a> (const char *begin, const char *end, const char **endptr, T1 &amp;v1, T2 &amp;v2)</td></tr>
<tr class="memdesc:ac1bd2f744b450d3a7a06fd4e4276f667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse colon seperated pair v1[:v2].  <br /></td></tr>
<tr class="separator:ac1bd2f744b450d3a7a06fd4e4276f667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade27d0fd3a6c3e57a64e225a78e56ced" id="r_ade27d0fd3a6c3e57a64e225a78e56ced"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ade27d0fd3a6c3e57a64e225a78e56ced"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ade27d0fd3a6c3e57a64e225a78e56ced">ParseTriple</a> (const char *begin, const char *end, const char **endptr, T1 &amp;v1, T2 &amp;v2, T3 &amp;v3)</td></tr>
<tr class="memdesc:ade27d0fd3a6c3e57a64e225a78e56ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse colon seperated triple v1:v2[:v3].  <br /></td></tr>
<tr class="separator:ade27d0fd3a6c3e57a64e225a78e56ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1c5a5f5dd3a6741693071f85d67ce" id="r_a3af1c5a5f5dd3a6741693071f85d67ce"><td class="memTemplParams" colspan="2">template&lt;typename Duration , typename TimerFunction &gt; </td></tr>
<tr class="memitem:a3af1c5a5f5dd3a6741693071f85d67ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a3af1c5a5f5dd3a6741693071f85d67ce">CreateTimer</a> (const std::string &amp;timer_name, const Duration &amp;duration, <a class="el" href="classdmlc_1_1ThreadGroup.html">ThreadGroup</a> *owner, TimerFunction timer_function)</td></tr>
<tr class="memdesc:a3af1c5a5f5dd3a6741693071f85d67ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to easily create a timer.  <br /></td></tr>
<tr class="separator:a3af1c5a5f5dd3a6741693071f85d67ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6607ababd562edcce61938343ae0db6" id="r_ac6607ababd562edcce61938343ae0db6"><td class="memItemLeft" align="right" valign="top"><a id="ac6607ababd562edcce61938343ae0db6" name="ac6607ababd562edcce61938343ae0db6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetTime</b> (void)</td></tr>
<tr class="memdesc:ac6607ababd562edcce61938343ae0db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return time in seconds <br /></td></tr>
<tr class="separator:ac6607ababd562edcce61938343ae0db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e731f276d3a3efa8e17f46ccf35f828" id="r_a1e731f276d3a3efa8e17f46ccf35f828"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e731f276d3a3efa8e17f46ccf35f828"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a1e731f276d3a3efa8e17f46ccf35f828">type_name</a> ()</td></tr>
<tr class="memdesc:a1e731f276d3a3efa8e17f46ccf35f828"><td class="mdescLeft">&#160;</td><td class="mdescRight">the string representation of type name  <br /></td></tr>
<tr class="separator:a1e731f276d3a3efa8e17f46ccf35f828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e6d3820ae1936bc8ad7ba710a622a5" id="r_a47e6d3820ae1936bc8ad7ba710a622a5"><td class="memItemLeft" align="right" valign="top"><a id="a47e6d3820ae1936bc8ad7ba710a622a5" name="a47e6d3820ae1936bc8ad7ba710a622a5"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>MakeProtoStringValue</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a47e6d3820ae1936bc8ad7ba710a622a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969737625f1d07f502072f74f696da5c" id="r_a969737625f1d07f502072f74f696da5c"><td class="memItemLeft" align="right" valign="top"><a id="a969737625f1d07f502072f74f696da5c" name="a969737625f1d07f502072f74f696da5c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structdmlc_1_1ParserFactoryReg.html">Reg32flt</a>)</td></tr>
<tr class="separator:a969737625f1d07f502072f74f696da5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d5e4c2a54d36f3631b509a56c782c3" id="r_a60d5e4c2a54d36f3631b509a56c782c3"><td class="memItemLeft" align="right" valign="top"><a id="a60d5e4c2a54d36f3631b509a56c782c3" name="a60d5e4c2a54d36f3631b509a56c782c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structdmlc_1_1ParserFactoryReg.html">Reg32int32</a>)</td></tr>
<tr class="separator:a60d5e4c2a54d36f3631b509a56c782c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfbb2bb7b64c92c50da1bb40fa44f9e" id="r_a4dfbb2bb7b64c92c50da1bb40fa44f9e"><td class="memItemLeft" align="right" valign="top"><a id="a4dfbb2bb7b64c92c50da1bb40fa44f9e" name="a4dfbb2bb7b64c92c50da1bb40fa44f9e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structdmlc_1_1ParserFactoryReg.html">Reg32int64</a>)</td></tr>
<tr class="separator:a4dfbb2bb7b64c92c50da1bb40fa44f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a45e6c7c53bbcbaa2d0bd4e51d8c49" id="r_a78a45e6c7c53bbcbaa2d0bd4e51d8c49"><td class="memItemLeft" align="right" valign="top"><a id="a78a45e6c7c53bbcbaa2d0bd4e51d8c49" name="a78a45e6c7c53bbcbaa2d0bd4e51d8c49"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structdmlc_1_1ParserFactoryReg.html">Reg64flt</a>)</td></tr>
<tr class="separator:a78a45e6c7c53bbcbaa2d0bd4e51d8c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27f96bcd02345038c1d37220af5a633" id="r_aa27f96bcd02345038c1d37220af5a633"><td class="memItemLeft" align="right" valign="top"><a id="aa27f96bcd02345038c1d37220af5a633" name="aa27f96bcd02345038c1d37220af5a633"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structdmlc_1_1ParserFactoryReg.html">Reg64int32</a>)</td></tr>
<tr class="separator:aa27f96bcd02345038c1d37220af5a633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee82e725d7ff625cbbe917e16829eb4" id="r_abee82e725d7ff625cbbe917e16829eb4"><td class="memItemLeft" align="right" valign="top"><a id="abee82e725d7ff625cbbe917e16829eb4" name="abee82e725d7ff625cbbe917e16829eb4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structdmlc_1_1ParserFactoryReg.html">Reg64int64</a>)</td></tr>
<tr class="separator:abee82e725d7ff625cbbe917e16829eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b31ada79e297f8333c5c53c8d0a26e" id="r_af5b31ada79e297f8333c5c53c8d0a26e"><td class="memItemLeft" align="right" valign="top"><a id="af5b31ada79e297f8333c5c53c8d0a26e" name="af5b31ada79e297f8333c5c53c8d0a26e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint32_t, <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a>, libsvm, data::CreateLibSVMParser&lt; uint32_t __DMLC_COMMA <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a> &gt;)</td></tr>
<tr class="separator:af5b31ada79e297f8333c5c53c8d0a26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7fa1b37ad7089cdf28713a60259045" id="r_a9b7fa1b37ad7089cdf28713a60259045"><td class="memItemLeft" align="right" valign="top"><a id="a9b7fa1b37ad7089cdf28713a60259045" name="a9b7fa1b37ad7089cdf28713a60259045"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint64_t, <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a>, libsvm, data::CreateLibSVMParser&lt; uint64_t __DMLC_COMMA <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a> &gt;)</td></tr>
<tr class="separator:a9b7fa1b37ad7089cdf28713a60259045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1a7e239c9a82fb685b4d373b060a12" id="r_a7a1a7e239c9a82fb685b4d373b060a12"><td class="memItemLeft" align="right" valign="top"><a id="a7a1a7e239c9a82fb685b4d373b060a12" name="a7a1a7e239c9a82fb685b4d373b060a12"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint32_t, <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a>, libfm, data::CreateLibFMParser&lt; uint32_t __DMLC_COMMA <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a> &gt;)</td></tr>
<tr class="separator:a7a1a7e239c9a82fb685b4d373b060a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2035b485c344df84dba56cada624d79" id="r_af2035b485c344df84dba56cada624d79"><td class="memItemLeft" align="right" valign="top"><a id="af2035b485c344df84dba56cada624d79" name="af2035b485c344df84dba56cada624d79"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint64_t, <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a>, libfm, data::CreateLibFMParser&lt; uint64_t __DMLC_COMMA <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a> &gt;)</td></tr>
<tr class="separator:af2035b485c344df84dba56cada624d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fa5f21e6b3c5005feda88dc997113d" id="r_a72fa5f21e6b3c5005feda88dc997113d"><td class="memItemLeft" align="right" valign="top"><a id="a72fa5f21e6b3c5005feda88dc997113d" name="a72fa5f21e6b3c5005feda88dc997113d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint32_t, <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a>, csv, data::CreateCSVParser&lt; uint32_t __DMLC_COMMA <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a> &gt;)</td></tr>
<tr class="separator:a72fa5f21e6b3c5005feda88dc997113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d5bd0050ba9394d4bd3cc5e54464b8" id="r_a51d5bd0050ba9394d4bd3cc5e54464b8"><td class="memItemLeft" align="right" valign="top"><a id="a51d5bd0050ba9394d4bd3cc5e54464b8" name="a51d5bd0050ba9394d4bd3cc5e54464b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint64_t, <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a>, csv, data::CreateCSVParser&lt; uint64_t __DMLC_COMMA <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a> &gt;)</td></tr>
<tr class="separator:a51d5bd0050ba9394d4bd3cc5e54464b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea5d8c8febfa13ed4d872d0ab63ce4c" id="r_a0ea5d8c8febfa13ed4d872d0ab63ce4c"><td class="memItemLeft" align="right" valign="top"><a id="a0ea5d8c8febfa13ed4d872d0ab63ce4c" name="a0ea5d8c8febfa13ed4d872d0ab63ce4c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint32_t, int32_t, csv, data::CreateCSVParser&lt; uint32_t __DMLC_COMMA int32_t &gt;)</td></tr>
<tr class="separator:a0ea5d8c8febfa13ed4d872d0ab63ce4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ea6f924169ad7bb1a89fa550aa51bc" id="r_ab6ea6f924169ad7bb1a89fa550aa51bc"><td class="memItemLeft" align="right" valign="top"><a id="ab6ea6f924169ad7bb1a89fa550aa51bc" name="ab6ea6f924169ad7bb1a89fa550aa51bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint64_t, int32_t, csv, data::CreateCSVParser&lt; uint64_t __DMLC_COMMA int32_t &gt;)</td></tr>
<tr class="separator:ab6ea6f924169ad7bb1a89fa550aa51bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e188fb1749962f92b859429cedc2b45" id="r_a9e188fb1749962f92b859429cedc2b45"><td class="memItemLeft" align="right" valign="top"><a id="a9e188fb1749962f92b859429cedc2b45" name="a9e188fb1749962f92b859429cedc2b45"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint32_t, int64_t, csv, data::CreateCSVParser&lt; uint32_t __DMLC_COMMA int64_t &gt;)</td></tr>
<tr class="separator:a9e188fb1749962f92b859429cedc2b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0907b9c33f300a8a81733ea2ea563a59" id="r_a0907b9c33f300a8a81733ea2ea563a59"><td class="memItemLeft" align="right" valign="top"><a id="a0907b9c33f300a8a81733ea2ea563a59" name="a0907b9c33f300a8a81733ea2ea563a59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint64_t, int64_t, csv, data::CreateCSVParser&lt; uint64_t __DMLC_COMMA int64_t &gt;)</td></tr>
<tr class="separator:a0907b9c33f300a8a81733ea2ea563a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f66704982a81caf9c74ddef4833391" id="r_a75f66704982a81caf9c74ddef4833391"><td class="memItemLeft" align="right" valign="top"><a id="a75f66704982a81caf9c74ddef4833391" name="a75f66704982a81caf9c74ddef4833391"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>FindNextRecordIOHead</b> (char *begin, char *end)</td></tr>
<tr class="separator:a75f66704982a81caf9c74ddef4833391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f94b7b25f204da01ee76bb3db491a8" id="r_af2f94b7b25f204da01ee76bb3db491a8"><td class="memItemLeft" align="right" valign="top"><a id="af2f94b7b25f204da01ee76bb3db491a8" name="af2f94b7b25f204da01ee76bb3db491a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structtree_1_1TreeFactory.html">tree::TreeFactory</a>)</td></tr>
<tr class="separator:af2f94b7b25f204da01ee76bb3db491a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fe4e8f7a92da05cfecd95a868fac21" id="r_a15fe4e8f7a92da05cfecd95a868fac21"><td class="memItemLeft" align="right" valign="top"><a id="a15fe4e8f7a92da05cfecd95a868fac21" name="a15fe4e8f7a92da05cfecd95a868fac21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_DECLARE_TRAITS</b> (<a class="el" href="structdmlc_1_1is__pod.html">is_pod</a>, <a class="el" href="structxgboost_1_1Entry.html">xgboost::Entry</a>, true)</td></tr>
<tr class="separator:a15fe4e8f7a92da05cfecd95a868fac21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa683a5fa9837bbde019b77137e32d4" id="r_a9fa683a5fa9837bbde019b77137e32d4"><td class="memItemLeft" align="right" valign="top"><a id="a9fa683a5fa9837bbde019b77137e32d4" name="a9fa683a5fa9837bbde019b77137e32d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTER_DATA_PARSER</b> (uint32_t, <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a>, dense_libsvm, data::CreateDenseLibSVMParser&lt; uint32_t __DMLC_COMMA <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a> &gt;)</td></tr>
<tr class="separator:a9fa683a5fa9837bbde019b77137e32d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5886cd0d9e6e208279a5649fe2db55ed" id="r_a5886cd0d9e6e208279a5649fe2db55ed"><td class="memItemLeft" align="right" valign="top"><a id="a5886cd0d9e6e208279a5649fe2db55ed" name="a5886cd0d9e6e208279a5649fe2db55ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1data_1_1SparsePageFormatReg.html">::xgboost::data::SparsePageFormatReg</a>&lt;<a class="el" href="classxgboost_1_1SparsePage.html">::xgboost::SparsePage</a> &gt;)</td></tr>
<tr class="separator:a5886cd0d9e6e208279a5649fe2db55ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2859a5a4f864203abae997a8f2936f2c" id="r_a2859a5a4f864203abae997a8f2936f2c"><td class="memItemLeft" align="right" valign="top"><a id="a2859a5a4f864203abae997a8f2936f2c" name="a2859a5a4f864203abae997a8f2936f2c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1data_1_1SparsePageFormatReg.html">::xgboost::data::SparsePageFormatReg</a>&lt;<a class="el" href="classxgboost_1_1CSCPage.html">::xgboost::CSCPage</a> &gt;)</td></tr>
<tr class="separator:a2859a5a4f864203abae997a8f2936f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97680cd3bd1c8144e2507cb143181ec" id="r_ad97680cd3bd1c8144e2507cb143181ec"><td class="memItemLeft" align="right" valign="top"><a id="ad97680cd3bd1c8144e2507cb143181ec" name="ad97680cd3bd1c8144e2507cb143181ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1data_1_1SparsePageFormatReg.html">::xgboost::data::SparsePageFormatReg</a>&lt;<a class="el" href="classxgboost_1_1SortedCSCPage.html">::xgboost::SortedCSCPage</a> &gt;)</td></tr>
<tr class="separator:ad97680cd3bd1c8144e2507cb143181ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347befe381bf2be1444e597dfa57e9d7" id="r_a347befe381bf2be1444e597dfa57e9d7"><td class="memItemLeft" align="right" valign="top"><a id="a347befe381bf2be1444e597dfa57e9d7" name="a347befe381bf2be1444e597dfa57e9d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1data_1_1SparsePageFormatReg.html">::xgboost::data::SparsePageFormatReg</a>&lt;<a class="el" href="classxgboost_1_1EllpackPage.html">::xgboost::EllpackPage</a> &gt;)</td></tr>
<tr class="separator:a347befe381bf2be1444e597dfa57e9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8310f91fb72f1f4cd3416fbdb3970370" id="r_a8310f91fb72f1f4cd3416fbdb3970370"><td class="memItemLeft" align="right" valign="top"><a id="a8310f91fb72f1f4cd3416fbdb3970370" name="a8310f91fb72f1f4cd3416fbdb3970370"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1data_1_1SparsePageFormatReg.html">::xgboost::data::SparsePageFormatReg</a>&lt;<a class="el" href="classxgboost_1_1GHistIndexMatrix.html">::xgboost::GHistIndexMatrix</a> &gt;)</td></tr>
<tr class="separator:a8310f91fb72f1f4cd3416fbdb3970370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcfe489a37b1276975b29948feab974" id="r_a6fcfe489a37b1276975b29948feab974"><td class="memItemLeft" align="right" valign="top"><a id="a6fcfe489a37b1276975b29948feab974" name="a6fcfe489a37b1276975b29948feab974"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1GradientBoosterReg.html">::xgboost::GradientBoosterReg</a>)</td></tr>
<tr class="separator:a6fcfe489a37b1276975b29948feab974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b003eb571fa7e7703710c550e74bd3" id="r_ae0b003eb571fa7e7703710c550e74bd3"><td class="memItemLeft" align="right" valign="top"><a id="ae0b003eb571fa7e7703710c550e74bd3" name="ae0b003eb571fa7e7703710c550e74bd3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1LinearUpdaterReg.html">::xgboost::LinearUpdaterReg</a>)</td></tr>
<tr class="separator:ae0b003eb571fa7e7703710c550e74bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60701446d11ba71a31ec122e4c927c1b" id="r_a60701446d11ba71a31ec122e4c927c1b"><td class="memItemLeft" align="right" valign="top"><a id="a60701446d11ba71a31ec122e4c927c1b" name="a60701446d11ba71a31ec122e4c927c1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1MetricReg.html">::xgboost::MetricReg</a>)</td></tr>
<tr class="separator:a60701446d11ba71a31ec122e4c927c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cb5dd835c73aa29d7df485f2b91041" id="r_ab9cb5dd835c73aa29d7df485f2b91041"><td class="memItemLeft" align="right" valign="top"><a id="ab9cb5dd835c73aa29d7df485f2b91041" name="ab9cb5dd835c73aa29d7df485f2b91041"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1ObjFunctionReg.html">::xgboost::ObjFunctionReg</a>)</td></tr>
<tr class="separator:ab9cb5dd835c73aa29d7df485f2b91041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51cdd60893c40e91052f21bde5e4671" id="r_ab51cdd60893c40e91052f21bde5e4671"><td class="memItemLeft" align="right" valign="top"><a id="ab51cdd60893c40e91052f21bde5e4671" name="ab51cdd60893c40e91052f21bde5e4671"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1PredictorReg.html">::xgboost::PredictorReg</a>)</td></tr>
<tr class="separator:ab51cdd60893c40e91052f21bde5e4671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9de326029e2864eb4924a133ebe2cab" id="r_ad9de326029e2864eb4924a133ebe2cab"><td class="memItemLeft" align="right" valign="top"><a id="ad9de326029e2864eb4924a133ebe2cab" name="ad9de326029e2864eb4924a133ebe2cab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1TreeGenReg.html">::xgboost::TreeGenReg</a>)</td></tr>
<tr class="separator:ad9de326029e2864eb4924a133ebe2cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfefc4841ca2f957a5ba9472530f5ab" id="r_a6dfefc4841ca2f957a5ba9472530f5ab"><td class="memItemLeft" align="right" valign="top"><a id="a6dfefc4841ca2f957a5ba9472530f5ab" name="a6dfefc4841ca2f957a5ba9472530f5ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DMLC_REGISTRY_ENABLE</b> (<a class="el" href="structxgboost_1_1TreeUpdaterReg.html">::xgboost::TreeUpdaterReg</a>)</td></tr>
<tr class="separator:a6dfefc4841ca2f957a5ba9472530f5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7e0f62af45e67c3b6fa22080e756b379" id="r_a7e0f62af45e67c3b6fa22080e756b379"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a7e0f62af45e67c3b6fa22080e756b379">nullopt</a> = <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a>(0)</td></tr>
<tr class="separator:a7e0f62af45e67c3b6fa22080e756b379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6f99de792eaca82bdf6189ba6e0d77" id="r_a7e6f99de792eaca82bdf6189ba6e0d77"><td class="memItemLeft" align="right" valign="top"><a id="a7e6f99de792eaca82bdf6189ba6e0d77" name="a7e6f99de792eaca82bdf6189ba6e0d77"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kStrtofMaxDigits</b> = 19</td></tr>
<tr class="memdesc:a7e6f99de792eaca82bdf6189ba6e0d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of decimal digits <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information....">dmlc::strtof()</a> / <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information....">dmlc::strtod()</a> will process. Trailing digits will be ignored. <br /></td></tr>
<tr class="separator:a7e6f99de792eaca82bdf6189ba6e0d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace for dmlc </p>
<p>Copyright 2017-2023 by Contributors.</p>
<p>Copyright 2018 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4c6820d1e6705361c263364b709d15a8" name="a4c6820d1e6705361c263364b709d15a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6820d1e6705361c263364b709d15a8">&#9670;&#160;</a></span>atof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float dmlc::atof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a4c6820d1e6705361c263364b709d15a8" title="A faster implementation of atof(). Unlike std::atof(), this function returns float type....">atof()</a>. Unlike std::atof(), this function returns float type. Note that this function does not check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in float type </dd></dl>

</div>
</div>
<a id="a46a57f902842152f71261ab44e887017" name="a46a57f902842152f71261ab44e887017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a57f902842152f71261ab44e887017">&#9670;&#160;</a></span>atol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long dmlc::atol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a46a57f902842152f71261ab44e887017" title="A faster implementation of atol(). See documentation of std::atol() for more information....">atol()</a>. See documentation of std::atol() for more information. This function will use base 10. Note that this function does not check for overflow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Beginning of the string that's to be converted into integer of type long </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, as long integer (width is system-dependent) </dd></dl>

</div>
</div>
<a id="a4fbd11e398aee363da3d0f38eac86723" name="a4fbd11e398aee363da3d0f38eac86723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbd11e398aee363da3d0f38eac86723">&#9670;&#160;</a></span>BeginPtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * dmlc::BeginPtr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the beginning address of a const string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a string </dd></dl>

</div>
</div>
<a id="a94b1692c4ad890ec97d517f7b003a0d4" name="a94b1692c4ad890ec97d517f7b003a0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b1692c4ad890ec97d517f7b003a0d4">&#9670;&#160;</a></span>BeginPtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * dmlc::BeginPtr </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the beginning address of a const vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a vector </dd></dl>

</div>
</div>
<a id="a95043d393d63392acb7755e53e2e494f" name="a95043d393d63392acb7755e53e2e494f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95043d393d63392acb7755e53e2e494f">&#9670;&#160;</a></span>BeginPtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * dmlc::BeginPtr </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the beginning address of a string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a string </dd></dl>

</div>
</div>
<a id="af40568bf088237205d2cd9e0a31ddf41" name="af40568bf088237205d2cd9e0a31ddf41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40568bf088237205d2cd9e0a31ddf41">&#9670;&#160;</a></span>BeginPtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * dmlc::BeginPtr </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>safely get the beginning address of a vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a vector </dd></dl>

</div>
</div>
<a id="adbe9d2411f71ee9f165b44bd0a6fbad1" name="adbe9d2411f71ee9f165b44bd0a6fbad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe9d2411f71ee9f165b44bd0a6fbad1">&#9670;&#160;</a></span>ByteSwap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dmlc::ByteSwap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A generic inplace byte swapping function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data pointer. </td></tr>
    <tr><td class="paramname">elem_bytes</td><td>The number of bytes of the data elements </td></tr>
    <tr><td class="paramname">num_elems</td><td>Number of elements in the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always try pass in constant elem_bytes to enable compiler optimization </dd></dl>

</div>
</div>
<a id="a3af1c5a5f5dd3a6741693071f85d67ce" name="a3af1c5a5f5dd3a6741693071f85d67ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af1c5a5f5dd3a6741693071f85d67ce">&#9670;&#160;</a></span>CreateTimer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Duration , typename TimerFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::CreateTimer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>timer_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Duration &amp;&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1ThreadGroup.html">ThreadGroup</a> *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimerFunction&#160;</td>
          <td class="paramname"><em>timer_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to easily create a timer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>Duration type (i.e. std::chrono::milliseconds) </td></tr>
    <tr><td class="paramname">TimerFunction</td><td>Function to call each time the timer expires </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_name</td><td>Name of the timer. Must be unique per <a class="el" href="classdmlc_1_1ThreadGroup.html" title="Thread lifecycle management group.">ThreadGroup</a> object </td></tr>
    <tr><td class="paramname">duration</td><td>Duration of the timer between calls to timer_function </td></tr>
    <tr><td class="paramname">owner</td><td><a class="el" href="classdmlc_1_1ThreadGroup.html" title="Thread lifecycle management group.">ThreadGroup</a> owner of the timer </td></tr>
    <tr><td class="paramname">timer_function</td><td>Function to call each time the timer expires </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the timer was successfully created </dd></dl>

</div>
</div>
<a id="a8234006cb1d67dcba5f9f856fe805c19" name="a8234006cb1d67dcba5f9f856fe805c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8234006cb1d67dcba5f9f856fe805c19">&#9670;&#160;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::isalpha </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline implementation of <a class="el" href="namespacedmlc.html#a8234006cb1d67dcba5f9f856fe805c19" title="Inline implementation of isalpha(). Tests whether the given character is an alphabet letter.">isalpha()</a>. Tests whether the given character is an alphabet letter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the test </dd></dl>

</div>
</div>
<a id="a382379acc79620379a9f7ee29ad5caaf" name="a382379acc79620379a9f7ee29ad5caaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382379acc79620379a9f7ee29ad5caaf">&#9670;&#160;</a></span>isblank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::isblank </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline implementation of <a class="el" href="namespacedmlc.html#a382379acc79620379a9f7ee29ad5caaf" title="Inline implementation of isblank(). Tests whether the given character is a space or tab character.">isblank()</a>. Tests whether the given character is a space or tab character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the test </dd></dl>

</div>
</div>
<a id="a5dab1c816301d0261e96d002ab157d3a" name="a5dab1c816301d0261e96d002ab157d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dab1c816301d0261e96d002ab157d3a">&#9670;&#160;</a></span>isdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::isdigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline implementation of <a class="el" href="namespacedmlc.html#a5dab1c816301d0261e96d002ab157d3a" title="Inline implementation of isdigit(). Tests whether the given character is a decimal digit.">isdigit()</a>. Tests whether the given character is a decimal digit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the test </dd></dl>

</div>
</div>
<a id="aadc240ae898cb7f29bd88c5bd96bd3cb" name="aadc240ae898cb7f29bd88c5bd96bd3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc240ae898cb7f29bd88c5bd96bd3cb">&#9670;&#160;</a></span>isdigitchars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::isdigitchars </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the given character is a valid letter in the string representation of a floating-point value, i.e. decimal digits, signs (+/-), decimal point (.), or exponent marker (e/E). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the test </dd></dl>

</div>
</div>
<a id="a52dcf01c9ba22be9b08e455194fb2ab3" name="a52dcf01c9ba22be9b08e455194fb2ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dcf01c9ba22be9b08e455194fb2ab3">&#9670;&#160;</a></span>isspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::isspace </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline implementation of <a class="el" href="namespacedmlc.html#a52dcf01c9ba22be9b08e455194fb2ab3" title="Inline implementation of isspace(). Tests whether the given character is a whitespace letter.">isspace()</a>. Tests whether the given character is a whitespace letter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the test </dd></dl>

</div>
</div>
<a id="a77a6131e0453b827073b39eeef55b98d" name="a77a6131e0453b827073b39eeef55b98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a6131e0453b827073b39eeef55b98d">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; dmlc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize an optional object to string. </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classdmlc_1_1optional.html">dmlc::optional&lt;int&gt;</a> x;</div>
<div class="line">std::cout &lt;&lt; x;  <span class="comment">// None</span></div>
<div class="line">x = 0;</div>
<div class="line">std::cout &lt;&lt; x;  <span class="comment">// 0</span></div>
<div class="ttc" id="aclassdmlc_1_1optional_html"><div class="ttname"><a href="classdmlc_1_1optional.html">dmlc::optional</a></div><div class="ttdoc">Is not constructible or convertible from any expression of type (possibly const) dmlc::optional&lt;U&gt;,...</div><div class="ttdef"><b>Definition</b> optional.h:76</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">t</td><td>source optional&lt;T&gt; object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream </dd></dl>

</div>
</div>
<a id="a4c5a9751c06102127c75d4203ae6e29c" name="a4c5a9751c06102127c75d4203ae6e29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5a9751c06102127c75d4203ae6e29c">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; dmlc::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specialization of '&gt;&gt;' istream parsing for <a class="el" href="classdmlc_1_1optional.html">optional&lt;bool&gt;</a> </p>
<p>Permits use of generic parameter FieldEntry&lt;DType&gt; class to create FieldEntry&lt;optional&lt;bool&gt;&gt; without explicit specialization.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classdmlc_1_1optional.html">dmlc::optional&lt;bool&gt;</a> x;</div>
<div class="line">std::string s1 = <span class="stringliteral">&quot;true&quot;</span>;</div>
<div class="line">std::istringstream is1(s1);</div>
<div class="line">s1 &gt;&gt; x;  <span class="comment">// x == optional&lt;bool&gt;(true)</span></div>
<div class="line"> </div>
<div class="line">std::string s2 = <span class="stringliteral">&quot;None&quot;</span>;</div>
<div class="line">std::istringstream is2(s2);</div>
<div class="line">s2 &gt;&gt; x;  <span class="comment">// x == optional&lt;bool&gt;()</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">t</td><td>target <a class="el" href="classdmlc_1_1optional.html">optional&lt;bool&gt;</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input stream </dd></dl>

</div>
</div>
<a id="aff849eb74b4604e70e042dc681819e3d" name="aff849eb74b4604e70e042dc681819e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff849eb74b4604e70e042dc681819e3d">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; dmlc::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parse a string object into optional&lt;T&gt; </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classdmlc_1_1optional.html">dmlc::optional&lt;int&gt;</a> x;</div>
<div class="line">std::string s1 = <span class="stringliteral">&quot;1&quot;</span>;</div>
<div class="line">std::istringstream is1(s1);</div>
<div class="line">s1 &gt;&gt; x;  <span class="comment">// x == optional&lt;int&gt;(1)</span></div>
<div class="line"> </div>
<div class="line">std::string s2 = <span class="stringliteral">&quot;None&quot;</span>;</div>
<div class="line">std::istringstream is2(s2);</div>
<div class="line">s2 &gt;&gt; x;  <span class="comment">// x == optional&lt;int&gt;()</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">t</td><td>target optional&lt;T&gt; object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input stream </dd></dl>

</div>
</div>
<a id="ade80237502ab5ae86b9c1454a09c66ee" name="ade80237502ab5ae86b9c1454a09c66ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade80237502ab5ae86b9c1454a09c66ee">&#9670;&#160;</a></span>ParseFloat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType , bool CheckRange = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatType dmlc::ParseFloat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common implementation for <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information....">dmlc::strtof()</a> and <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information....">dmlc::strtod()</a> TODO: the current version does not support hex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into a floating-point number </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted floating-point value, in FloatType </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FloatType</td><td>Type of floating-point number to be obtained. This must be either float or double. </td></tr>
    <tr><td class="paramname">CheckRange</td><td>Whether to check for overflow. If set to true, an out- of-range value will cause errno to be set to ERANGE and <a class="el" href="namespacedmlc.html#ade80237502ab5ae86b9c1454a09c66ee" title="Common implementation for dmlc::strtof() and dmlc::strtod() TODO: the current version does not suppor...">ParseFloat()</a> to return HUGE_VAL / HUGE_VALF; otherwise, all out-of-range vlaues will be silently clipped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1bd2f744b450d3a7a06fd4e4276f667" name="ac1bd2f744b450d3a7a06fd4e4276f667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bd2f744b450d3a7a06fd4e4276f667">&#9670;&#160;</a></span>ParsePair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dmlc::ParsePair </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse colon seperated pair v1[:v2]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>pointer to string </td></tr>
    <tr><td class="paramname">end</td><td>one past end of string </td></tr>
    <tr><td class="paramname">endptr</td><td>After conversion, will be set to one past of parsed string </td></tr>
    <tr><td class="paramname">v1</td><td>first value in the pair </td></tr>
    <tr><td class="paramname">v2</td><td>second value in the pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of values parsed </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of v1 </td></tr>
    <tr><td class="paramname">T2</td><td>type of v2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe766bbcae14a7ff2720bb248cca0db9" name="abe766bbcae14a7ff2720bb248cca0db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe766bbcae14a7ff2720bb248cca0db9">&#9670;&#160;</a></span>ParseSignedInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignedIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SignedIntType dmlc::ParseSignedInt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A fast string-to-integer convertor, for signed integers TODO: the current version supports only base &lt;= 10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into a signed integer </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use for integer conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in SignedIntType </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SignedIntType</td><td>Type of signed integer to be obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade27d0fd3a6c3e57a64e225a78e56ced" name="ade27d0fd3a6c3e57a64e225a78e56ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade27d0fd3a6c3e57a64e225a78e56ced">&#9670;&#160;</a></span>ParseTriple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dmlc::ParseTriple </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T3 &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse colon seperated triple v1:v2[:v3]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>pointer to string </td></tr>
    <tr><td class="paramname">end</td><td>one past end of string </td></tr>
    <tr><td class="paramname">endptr</td><td>After conversion, will be set to one past of parsed string </td></tr>
    <tr><td class="paramname">v1</td><td>first value in the triple </td></tr>
    <tr><td class="paramname">v2</td><td>second value in the triple </td></tr>
    <tr><td class="paramname">v3</td><td>third value in the triple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of values parsed </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of v1 </td></tr>
    <tr><td class="paramname">T2</td><td>type of v2 </td></tr>
    <tr><td class="paramname">T3</td><td>type of v3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5d2f93a1b7b7683df3c674e0c3d1863" name="ae5d2f93a1b7b7683df3c674e0c3d1863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d2f93a1b7b7683df3c674e0c3d1863">&#9670;&#160;</a></span>ParseUnsignedInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType dmlc::ParseUnsignedInt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A fast string-to-integer convertor, for unsigned integers TODO: the current version supports only base &lt;= 10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into an unsigned integer </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use for integer conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in UnsignedIntType </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnsignedIntType</td><td>Type of unsigned integer to be obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c199c2feea75fbf019a4f80831781e0" name="a2c199c2feea75fbf019a4f80831781e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c199c2feea75fbf019a4f80831781e0">&#9670;&#160;</a></span>Split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; dmlc::Split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string by delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to be splitted. </td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a splitted vector of strings. </dd></dl>

</div>
</div>
<a id="a5f49479b0736b8709986ead800e1bfdc" name="a5f49479b0736b8709986ead800e1bfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f49479b0736b8709986ead800e1bfdc">&#9670;&#160;</a></span>stod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double dmlc::stod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a5f49479b0736b8709986ead800e1bfdc" title="A faster implementation of stod(). See documentation of std::stod() for more information....">stod()</a>. See documentation of std::stod() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to convert into double </td></tr>
    <tr><td class="paramname">pos</td><td>If not null, it will store the number of characters processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in double type </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If the converted value would fall out of the range of the double type </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If no conversion could be performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43a149fb880b527d393975a884255341" name="a43a149fb880b527d393975a884255341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a149fb880b527d393975a884255341">&#9670;&#160;</a></span>stof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float dmlc::stof </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a43a149fb880b527d393975a884255341" title="A faster implementation of stof(). See documentation of std::stof() for more information....">stof()</a>. See documentation of std::stof() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to convert into float </td></tr>
    <tr><td class="paramname">pos</td><td>If not null, it will store the number of characters processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in float type </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If the converted value would fall out of the range of the double type </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If no conversion could be performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad1cfbbeeb3029867e8b8aa0278ac311" name="aad1cfbbeeb3029867e8b8aa0278ac311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1cfbbeeb3029867e8b8aa0278ac311">&#9670;&#160;</a></span>Str2Type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T dmlc::Str2Type </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function for converting string into type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Beginning of the string to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in type T </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of converted value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a345b262c3cbb6d700c22c4d69d46db6e" name="a345b262c3cbb6d700c22c4d69d46db6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345b262c3cbb6d700c22c4d69d46db6e">&#9670;&#160;</a></span>strtod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double dmlc::strtod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information....">strtod()</a>. See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use <a class="el" href="namespacedmlc.html#abd212a404ead6ae94faa2b65b4af796d" title="A faster implementation of strtod(). See documentation of std::strtod() for more information....">strtod_check_range()</a> to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into double </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted floating-point value, in double type </dd></dl>

</div>
</div>
<a id="abd212a404ead6ae94faa2b65b4af796d" name="abd212a404ead6ae94faa2b65b4af796d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd212a404ead6ae94faa2b65b4af796d">&#9670;&#160;</a></span>strtod_check_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double dmlc::strtod_check_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information....">strtod()</a>. See documentation of std::strtod() for more information. This function will check for overflow. If the converted value is outside the range for the double type, errno is set to ERANGE and HUGE_VAL is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into double </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted floating-point value, in float type </dd></dl>

</div>
</div>
<a id="a93c2c8f7859b02cecb9c094cddd91af9" name="a93c2c8f7859b02cecb9c094cddd91af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c2c8f7859b02cecb9c094cddd91af9">&#9670;&#160;</a></span>strtof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float dmlc::strtof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information....">strtof()</a>. See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use <a class="el" href="namespacedmlc.html#a3717fca311a75301eedca7e77e744459" title="A faster implementation of strtof(). See documentation of std::strtof() for more information....">strtof_check_range()</a> to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into float </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted floating-point value, in float type </dd></dl>

</div>
</div>
<a id="a3717fca311a75301eedca7e77e744459" name="a3717fca311a75301eedca7e77e744459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3717fca311a75301eedca7e77e744459">&#9670;&#160;</a></span>strtof_check_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float dmlc::strtof_check_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information....">strtof()</a>. See documentation of std::strtof() for more information. This function will check for overflow. If the converted value is outside the range for the float type, errno is set to ERANGE and HUGE_VALF is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into float </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted floating-point value, in float type </dd></dl>

</div>
</div>
<a id="ac63dcf48b6a8ec204720a121f01477e9" name="ac63dcf48b6a8ec204720a121f01477e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63dcf48b6a8ec204720a121f01477e9">&#9670;&#160;</a></span>strtoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t dmlc::strtoull </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#ac63dcf48b6a8ec204720a121f01477e9" title="A faster implementation of strtoull(). See documentation of std::strtoull() for more information....">strtoull()</a>. See documentation of std::strtoull() for more information. Note that this function does not check for overflow. TODO: the current version supports only base &lt;= 10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into integer of type unsigned long long </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use for integer conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, as unsigned 64-bit integer </dd></dl>

</div>
</div>
<a id="a1e731f276d3a3efa8e17f46ccf35f828" name="a1e731f276d3a3efa8e17f46ccf35f828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e731f276d3a3efa8e17f46ccf35f828">&#9670;&#160;</a></span>type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string dmlc::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the string representation of type name </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const string of typename. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7e0f62af45e67c3b6fa22080e756b379" name="a7e0f62af45e67c3b6fa22080e756b379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0f62af45e67c3b6fa22080e756b379">&#9670;&#160;</a></span>nullopt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a> dmlc::nullopt = <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a>(0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign null to optional: optional&lt;T&gt; x = nullopt; </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 14 2025 19:20:26 for Medial Code Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
