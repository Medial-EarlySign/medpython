<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medial Code Documentation: Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Medial Code Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="classEigen_1_1Transform.html">Transform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Geometry__Module.html">Geometry_Module</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>\geometry_module  
 <a href="classEigen_1_1Transform.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Transform_8h_source.html">Transform.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1c9323f9982e14162d4cf6d4739b0a51" id="r_a1c9323f9982e14162d4cf6d4739b0a51"><td class="memItemLeft" align="right" valign="top"><a id="a1c9323f9982e14162d4cf6d4739b0a51" name="a1c9323f9982e14162d4cf6d4739b0a51"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>TransformTimeDiagonalMode</b> = ((Mode==int(Isometry))?Affine:int(Mode))
 }</td></tr>
<tr class="separator:a1c9323f9982e14162d4cf6d4739b0a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e69ced9d651745b8ed4eda46f41795d" id="r_a4e69ced9d651745b8ed4eda46f41795d"><td class="memItemLeft" align="right" valign="top"><a id="a4e69ced9d651745b8ed4eda46f41795d" name="a4e69ced9d651745b8ed4eda46f41795d"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> _Scalar&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar</b></td></tr>
<tr class="memdesc:a4e69ced9d651745b8ed4eda46f41795d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the scalar type of the coefficients <br /></td></tr>
<tr class="separator:a4e69ced9d651745b8ed4eda46f41795d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76d83062ee15f941c3b78b2bc31eec4" id="r_ae76d83062ee15f941c3b78b2bc31eec4"><td class="memItemLeft" align="right" valign="top"><a id="ae76d83062ee15f941c3b78b2bc31eec4" name="ae76d83062ee15f941c3b78b2bc31eec4"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>StorageIndex</b></td></tr>
<tr class="separator:ae76d83062ee15f941c3b78b2bc31eec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49df3689ac2b736bcb564dec47d6486c" id="r_a49df3689ac2b736bcb564dec47d6486c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a></td></tr>
<tr class="separator:a49df3689ac2b736bcb564dec47d6486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f72ba46abc2bb3c7fa919c1078fc9c" id="r_a30f72ba46abc2bb3c7fa919c1078fc9c"><td class="memItemLeft" align="right" valign="top"><a id="a30f72ba46abc2bb3c7fa919c1078fc9c" name="a30f72ba46abc2bb3c7fa919c1078fc9c"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="classEigen_1_1internal_1_1make__proper__matrix__type.html">internal::make_proper_matrix_type</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Rows, HDim, Options &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="memdesc:a30f72ba46abc2bb3c7fa919c1078fc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the matrix used to represent the transformation <br /></td></tr>
<tr class="separator:a30f72ba46abc2bb3c7fa919c1078fc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed436d14b16bd862bac5367990085795" id="r_aed436d14b16bd862bac5367990085795"><td class="memItemLeft" align="right" valign="top"><a id="aed436d14b16bd862bac5367990085795" name="aed436d14b16bd862bac5367990085795"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConstMatrixType</b></td></tr>
<tr class="memdesc:aed436d14b16bd862bac5367990085795"><td class="mdescLeft">&#160;</td><td class="mdescRight">constified MatrixType <br /></td></tr>
<tr class="separator:aed436d14b16bd862bac5367990085795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48138c0370e55371b95946c90d69e25c" id="r_a48138c0370e55371b95946c90d69e25c"><td class="memItemLeft" align="right" valign="top"><a id="a48138c0370e55371b95946c90d69e25c" name="a48138c0370e55371b95946c90d69e25c"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Dim, Options &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LinearMatrixType</b></td></tr>
<tr class="memdesc:a48138c0370e55371b95946c90d69e25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the matrix used to represent the linear part of the transformation <br /></td></tr>
<tr class="separator:a48138c0370e55371b95946c90d69e25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2195bd42561e691a8f6e7d989e77f328" id="r_a2195bd42561e691a8f6e7d989e77f328"><td class="memItemLeft" align="right" valign="top"><a id="a2195bd42561e691a8f6e7d989e77f328" name="a2195bd42561e691a8f6e7d989e77f328"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, Dim, Dim, int(Mode)==(<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>) &amp;&amp;(int(Options)&amp;<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a>)==0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LinearPart</b></td></tr>
<tr class="memdesc:a2195bd42561e691a8f6e7d989e77f328"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of read/write reference to the linear part of the transformation <br /></td></tr>
<tr class="separator:a2195bd42561e691a8f6e7d989e77f328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75810d3f0d098e00b43a5531f33d78e1" id="r_a75810d3f0d098e00b43a5531f33d78e1"><td class="memItemLeft" align="right" valign="top"><a id="a75810d3f0d098e00b43a5531f33d78e1" name="a75810d3f0d098e00b43a5531f33d78e1"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1Transform.html#aed436d14b16bd862bac5367990085795">ConstMatrixType</a>, Dim, Dim, int(Mode)==(<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>) &amp;&amp;(int(Options)&amp;<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a>)==0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstLinearPart</b></td></tr>
<tr class="memdesc:a75810d3f0d098e00b43a5531f33d78e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of read reference to the linear part of the transformation <br /></td></tr>
<tr class="separator:a75810d3f0d098e00b43a5531f33d78e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654d40214886008458a977f738252c1d" id="r_a654d40214886008458a977f738252c1d"><td class="memItemLeft" align="right" valign="top"><a id="a654d40214886008458a977f738252c1d" name="a654d40214886008458a977f738252c1d"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; int(Mode)==int(<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>), <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &amp;, <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, Dim, HDim &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>AffinePart</b></td></tr>
<tr class="memdesc:a654d40214886008458a977f738252c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of read/write reference to the affine part of the transformation <br /></td></tr>
<tr class="separator:a654d40214886008458a977f738252c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719486ada918954a8ffad3d174d08817" id="r_a719486ada918954a8ffad3d174d08817"><td class="memItemLeft" align="right" valign="top"><a id="a719486ada918954a8ffad3d174d08817" name="a719486ada918954a8ffad3d174d08817"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; int(Mode)==int(<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>), <a class="el" href="classEigen_1_1MatrixBase.html">constMatrixType</a> &amp;, <a class="el" href="classEigen_1_1MatrixBase.html">constBlock</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">constMatrixType</a>, Dim, HDim &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>ConstAffinePart</b></td></tr>
<tr class="memdesc:a719486ada918954a8ffad3d174d08817"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of read reference to the affine part of the transformation <br /></td></tr>
<tr class="separator:a719486ada918954a8ffad3d174d08817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb4ae2f95c8edb0655fd84ab3f89e79" id="r_aaeb4ae2f95c8edb0655fd84ab3f89e79"><td class="memItemLeft" align="right" valign="top"><a id="aaeb4ae2f95c8edb0655fd84ab3f89e79" name="aaeb4ae2f95c8edb0655fd84ab3f89e79"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>VectorType</b></td></tr>
<tr class="memdesc:aaeb4ae2f95c8edb0655fd84ab3f89e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a vector <br /></td></tr>
<tr class="separator:aaeb4ae2f95c8edb0655fd84ab3f89e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabeaa2d375bf1b6b1d5cb5d1904fbd06" id="r_aabeaa2d375bf1b6b1d5cb5d1904fbd06"><td class="memItemLeft" align="right" valign="top"><a id="aabeaa2d375bf1b6b1d5cb5d1904fbd06" name="aabeaa2d375bf1b6b1d5cb5d1904fbd06"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, Dim, 1,!(<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &gt;::Flags &amp;<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TranslationPart</b></td></tr>
<tr class="memdesc:aabeaa2d375bf1b6b1d5cb5d1904fbd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a read/write reference to the translation part of the rotation <br /></td></tr>
<tr class="separator:aabeaa2d375bf1b6b1d5cb5d1904fbd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eab3259d3fac8106eb3139bc96ba852" id="r_a3eab3259d3fac8106eb3139bc96ba852"><td class="memItemLeft" align="right" valign="top"><a id="a3eab3259d3fac8106eb3139bc96ba852" name="a3eab3259d3fac8106eb3139bc96ba852"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1Transform.html#aed436d14b16bd862bac5367990085795">ConstMatrixType</a>, Dim, 1,!(<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &gt;::Flags &amp;<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstTranslationPart</b></td></tr>
<tr class="memdesc:a3eab3259d3fac8106eb3139bc96ba852"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a read reference to the translation part of the rotation <br /></td></tr>
<tr class="separator:a3eab3259d3fac8106eb3139bc96ba852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b463d14d8be4c0eda2eed6e943b831f" id="r_a6b463d14d8be4c0eda2eed6e943b831f"><td class="memItemLeft" align="right" valign="top"><a id="a6b463d14d8be4c0eda2eed6e943b831f" name="a6b463d14d8be4c0eda2eed6e943b831f"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="classEigen_1_1Translation.html">Translation</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TranslationType</b></td></tr>
<tr class="memdesc:a6b463d14d8be4c0eda2eed6e943b831f"><td class="mdescLeft">&#160;</td><td class="mdescRight">corresponding translation type <br /></td></tr>
<tr class="separator:a6b463d14d8be4c0eda2eed6e943b831f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51af5e8d8d9d9bfec091ff8aa5b7845a" id="r_a51af5e8d8d9d9bfec091ff8aa5b7845a"><td class="memItemLeft" align="right" valign="top"><a id="a51af5e8d8d9d9bfec091ff8aa5b7845a" name="a51af5e8d8d9d9bfec091ff8aa5b7845a"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, TransformTimeDiagonalMode &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TransformTimeDiagonalReturnType</b></td></tr>
<tr class="memdesc:a51af5e8d8d9d9bfec091ff8aa5b7845a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type of the product between a diagonal matrix and a transform. <br /></td></tr>
<tr class="separator:a51af5e8d8d9d9bfec091ff8aa5b7845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c105f3c0083254208966f3b53512b93" id="r_a9c105f3c0083254208966f3b53512b93"><td class="memItemLeft" align="right" valign="top"><a id="a9c105f3c0083254208966f3b53512b93" name="a9c105f3c0083254208966f3b53512b93"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="structEigen_1_1internal_1_1transform__take__affine__part.html">internal::transform_take_affine_part</a>&lt; <a class="el" href="classEigen_1_1Transform.html">Transform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>take_affine_part</b></td></tr>
<tr class="separator:a9c105f3c0083254208966f3b53512b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af538d4c4c92e65f65cd84f9a04e791e0" id="r_af538d4c4c92e65f65cd84f9a04e791e0"><td class="memItemLeft" align="right" valign="top"><a id="af538d4c4c92e65f65cd84f9a04e791e0" name="af538d4c4c92e65f65cd84f9a04e791e0"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; int(Mode)==<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a84413028615d2d718bafd2dfb93dafef">Isometry</a>, <a class="el" href="classEigen_1_1Transform.html#a75810d3f0d098e00b43a5531f33d78e1">ConstLinearPart</a>, <a class="el" href="classEigen_1_1MatrixBase.html">constLinearMatrixType</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>RotationReturnType</b></td></tr>
<tr class="separator:af538d4c4c92e65f65cd84f9a04e791e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a30c94c2156e9345f4bdb6cc9661e275b" id="r_a30c94c2156e9345f4bdb6cc9661e275b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a30c94c2156e9345f4bdb6cc9661e275b">EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE</a> (_Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>==<a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> ? <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> :(<a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>+1) *(<a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>+1)) <a class="el" href="classEigen_1_1MatrixBase.html">enum</a></td></tr>
<tr class="separator:a30c94c2156e9345f4bdb6cc9661e275b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b94ccee0f7871610fa2fa084e0fd59" id="r_a79b94ccee0f7871610fa2fa084e0fd59"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a79b94ccee0f7871610fa2fa084e0fd59">Transform</a> ()</td></tr>
<tr class="memdesc:a79b94ccee0f7871610fa2fa084e0fd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor without initialization of the meaningful coefficients.  <br /></td></tr>
<tr class="separator:a79b94ccee0f7871610fa2fa084e0fd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb098a407862f706546443ee47375aed" id="r_adb098a407862f706546443ee47375aed"><td class="memItemLeft" align="right" valign="top"><a id="adb098a407862f706546443ee47375aed" name="adb098a407862f706546443ee47375aed"></a>
EIGEN_DEVICE_FUNC&#160;</td><td class="memItemRight" valign="bottom"><b>Transform</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a6b463d14d8be4c0eda2eed6e943b831f">TranslationType</a> &amp;t)</td></tr>
<tr class="separator:adb098a407862f706546443ee47375aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96652ea1105a98cc2f450bd1d62aab49" id="r_a96652ea1105a98cc2f450bd1d62aab49"><td class="memItemLeft" align="right" valign="top"><a id="a96652ea1105a98cc2f450bd1d62aab49" name="a96652ea1105a98cc2f450bd1d62aab49"></a>
EIGEN_DEVICE_FUNC&#160;</td><td class="memItemRight" valign="bottom"><b>Transform</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1UniformScaling.html">UniformScaling</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &gt; &amp;s)</td></tr>
<tr class="separator:a96652ea1105a98cc2f450bd1d62aab49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec4aaba86a9b0fc68f5ae4094e1a395" id="r_a1ec4aaba86a9b0fc68f5ae4094e1a395"><td class="memTemplParams" colspan="2"><a id="a1ec4aaba86a9b0fc68f5ae4094e1a395" name="a1ec4aaba86a9b0fc68f5ae4094e1a395"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> Derived &gt; </td></tr>
<tr class="memitem:a1ec4aaba86a9b0fc68f5ae4094e1a395"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Transform</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a>&lt; Derived, Dim &gt; &amp;r)</td></tr>
<tr class="separator:a1ec4aaba86a9b0fc68f5ae4094e1a395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee8b0067f6dadc04684be504e11a0c3" id="r_a5ee8b0067f6dadc04684be504e11a0c3"><td class="memTemplParams" colspan="2"><a id="a5ee8b0067f6dadc04684be504e11a0c3" name="a5ee8b0067f6dadc04684be504e11a0c3"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:a5ee8b0067f6dadc04684be504e11a0c3"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Transform</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:a5ee8b0067f6dadc04684be504e11a0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and initializes a transformation from a Dim^2 or a (Dim+1)^2 matrix. <br /></td></tr>
<tr class="separator:a5ee8b0067f6dadc04684be504e11a0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ce9c87aa49358297336c4a6c9abc29" id="r_a78ce9c87aa49358297336c4a6c9abc29"><td class="memTemplParams" colspan="2"><a id="a78ce9c87aa49358297336c4a6c9abc29" name="a78ce9c87aa49358297336c4a6c9abc29"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:a78ce9c87aa49358297336c4a6c9abc29"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:a78ce9c87aa49358297336c4a6c9abc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>*this</code> from a Dim^2 or (Dim+1)^2 matrix. <br /></td></tr>
<tr class="separator:a78ce9c87aa49358297336c4a6c9abc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5271ad7a41a47b7a6ab1d55141a69192" id="r_a5271ad7a41a47b7a6ab1d55141a69192"><td class="memTemplParams" colspan="2"><a id="a5271ad7a41a47b7a6ab1d55141a69192" name="a5271ad7a41a47b7a6ab1d55141a69192"></a>
template&lt;int OtherOptions&gt; </td></tr>
<tr class="memitem:a5271ad7a41a47b7a6ab1d55141a69192"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Transform</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, <a class="el" href="classEigen_1_1MatrixBase.html">OtherOptions</a> &gt; &amp;other)</td></tr>
<tr class="separator:a5271ad7a41a47b7a6ab1d55141a69192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee5c6820f39d01ba818c07c1d33133d" id="r_afee5c6820f39d01ba818c07c1d33133d"><td class="memTemplParams" colspan="2"><a id="afee5c6820f39d01ba818c07c1d33133d" name="afee5c6820f39d01ba818c07c1d33133d"></a>
template&lt;int OtherMode, int OtherOptions&gt; </td></tr>
<tr class="memitem:afee5c6820f39d01ba818c07c1d33133d"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Transform</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, <a class="el" href="classEigen_1_1MatrixBase.html">OtherMode</a>, <a class="el" href="classEigen_1_1MatrixBase.html">OtherOptions</a> &gt; &amp;other)</td></tr>
<tr class="separator:afee5c6820f39d01ba818c07c1d33133d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6398bba010bc76b11cce93fa52ca5c" id="r_a5b6398bba010bc76b11cce93fa52ca5c"><td class="memTemplParams" colspan="2"><a id="a5b6398bba010bc76b11cce93fa52ca5c" name="a5b6398bba010bc76b11cce93fa52ca5c"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:a5b6398bba010bc76b11cce93fa52ca5c"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Transform</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1ReturnByValue.html">ReturnByValue</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="separator:a5b6398bba010bc76b11cce93fa52ca5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0956af8b32df9b74389dd390c10a70b" id="r_ad0956af8b32df9b74389dd390c10a70b"><td class="memTemplParams" colspan="2"><a id="ad0956af8b32df9b74389dd390c10a70b" name="ad0956af8b32df9b74389dd390c10a70b"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:ad0956af8b32df9b74389dd390c10a70b"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1ReturnByValue.html">ReturnByValue</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="separator:ad0956af8b32df9b74389dd390c10a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4618e5329afa729ee1b8351e91dbae67" id="r_a4618e5329afa729ee1b8351e91dbae67"><td class="memItemLeft" align="right" valign="top"><a id="a4618e5329afa729ee1b8351e91dbae67" name="a4618e5329afa729ee1b8351e91dbae67"></a>
EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR <a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rows</b> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a> EIGEN_NOEXCEPT</td></tr>
<tr class="separator:a4618e5329afa729ee1b8351e91dbae67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d21d6371391d718d2b86c134e86350" id="r_a15d21d6371391d718d2b86c134e86350"><td class="memItemLeft" align="right" valign="top"><a id="a15d21d6371391d718d2b86c134e86350" name="a15d21d6371391d718d2b86c134e86350"></a>
EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR <a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cols</b> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a> EIGEN_NOEXCEPT</td></tr>
<tr class="separator:a15d21d6371391d718d2b86c134e86350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a930a85c51566fe06d281da85d1a4a" id="r_aa0a930a85c51566fe06d281da85d1a4a"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#aa0a930a85c51566fe06d281da85d1a4a">operator()</a> (<a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a> row, <a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a> col) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="memdesc:aa0a930a85c51566fe06d281da85d1a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut for m_matrix(row,col);  <br /></td></tr>
<tr class="separator:aa0a930a85c51566fe06d281da85d1a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466edc122165a02326dd1126d7f93078" id="r_a466edc122165a02326dd1126d7f93078"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a466edc122165a02326dd1126d7f93078">operator()</a> (<a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a> row, <a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a> col)</td></tr>
<tr class="memdesc:a466edc122165a02326dd1126d7f93078"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut for m_matrix(row,col);  <br /></td></tr>
<tr class="separator:a466edc122165a02326dd1126d7f93078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5d077e6e87e7d0a1f347fbc4d52a6e" id="r_a8a5d077e6e87e7d0a1f347fbc4d52a6e"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a8a5d077e6e87e7d0a1f347fbc4d52a6e">matrix</a> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:a8a5d077e6e87e7d0a1f347fbc4d52a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146347395d7dcfd250b6f9f96f9ed233" id="r_a146347395d7dcfd250b6f9f96f9ed233"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a146347395d7dcfd250b6f9f96f9ed233">matrix</a> ()</td></tr>
<tr class="separator:a146347395d7dcfd250b6f9f96f9ed233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535bd63d047c2a36585c3f9b62219a1e" id="r_a535bd63d047c2a36585c3f9b62219a1e"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a75810d3f0d098e00b43a5531f33d78e1">ConstLinearPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a535bd63d047c2a36585c3f9b62219a1e">linear</a> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:a535bd63d047c2a36585c3f9b62219a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540cef80cd714fa01d124536d39ac8da" id="r_a540cef80cd714fa01d124536d39ac8da"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a2195bd42561e691a8f6e7d989e77f328">LinearPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a540cef80cd714fa01d124536d39ac8da">linear</a> ()</td></tr>
<tr class="separator:a540cef80cd714fa01d124536d39ac8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c996ca4cccf46ab4d520b7d99c332b" id="r_a88c996ca4cccf46ab4d520b7d99c332b"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a719486ada918954a8ffad3d174d08817">ConstAffinePart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a88c996ca4cccf46ab4d520b7d99c332b">affine</a> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:a88c996ca4cccf46ab4d520b7d99c332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b379a598ff0e570a8112db65111a94" id="r_a77b379a598ff0e570a8112db65111a94"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a654d40214886008458a977f738252c1d">AffinePart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a77b379a598ff0e570a8112db65111a94">affine</a> ()</td></tr>
<tr class="separator:a77b379a598ff0e570a8112db65111a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa93ba97d26912bb3d8777cbed102045" id="r_afa93ba97d26912bb3d8777cbed102045"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a3eab3259d3fac8106eb3139bc96ba852">ConstTranslationPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#afa93ba97d26912bb3d8777cbed102045">translation</a> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:afa93ba97d26912bb3d8777cbed102045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76fc36f20276787741859cb5ebd5901" id="r_ae76fc36f20276787741859cb5ebd5901"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#aabeaa2d375bf1b6b1d5cb5d1904fbd06">TranslationPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#ae76fc36f20276787741859cb5ebd5901">translation</a> ()</td></tr>
<tr class="separator:ae76fc36f20276787741859cb5ebd5901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eb11fd16b64878e3e07681ab7a695d" id="r_a56eb11fd16b64878e3e07681ab7a695d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:a56eb11fd16b64878e3e07681ab7a695d"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1internal_1_1transform__right__product__impl.html">internal::transform_right_product_impl</a>&lt; <a class="el" href="classEigen_1_1Transform.html">Transform</a>, <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt;::ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a56eb11fd16b64878e3e07681ab7a695d">operator*</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:a56eb11fd16b64878e3e07681ab7a695d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f566a9fef984636431d6d5ebea0ba67" id="r_a4f566a9fef984636431d6d5ebea0ba67"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">DiagonalDerived</a> &gt; </td></tr>
<tr class="memitem:a4f566a9fef984636431d6d5ebea0ba67"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a51af5e8d8d9d9bfec091ff8aa5b7845a">TransformTimeDiagonalReturnType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a4f566a9fef984636431d6d5ebea0ba67">operator*</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1DiagonalBase.html">DiagonalBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">DiagonalDerived</a> &gt; &amp;b) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:a4f566a9fef984636431d6d5ebea0ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f26f51d4b4dd3ec934d787158affa4f" id="r_a5f26f51d4b4dd3ec934d787158affa4f"><td class="memTemplParams" colspan="2"><a id="a5f26f51d4b4dd3ec934d787158affa4f" name="a5f26f51d4b4dd3ec934d787158affa4f"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:a5f26f51d4b4dd3ec934d787158affa4f"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="separator:a5f26f51d4b4dd3ec934d787158affa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6f7fee617deca6f2a9052fadbe81e5" id="r_a5c6f7fee617deca6f2a9052fadbe81e5"><td class="memItemLeft" align="right" valign="top"><a id="a5c6f7fee617deca6f2a9052fadbe81e5" name="a5c6f7fee617deca6f2a9052fadbe81e5"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;other) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="memdesc:a5c6f7fee617deca6f2a9052fadbe81e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two transformations. <br /></td></tr>
<tr class="separator:a5c6f7fee617deca6f2a9052fadbe81e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f09b6582cb700725c8a8f93992025d" id="r_a79f09b6582cb700725c8a8f93992025d"><td class="memTemplParams" colspan="2"><a id="a79f09b6582cb700725c8a8f93992025d" name="a79f09b6582cb700725c8a8f93992025d"></a>
template&lt;int OtherMode, int OtherOptions&gt; </td></tr>
<tr class="memitem:a79f09b6582cb700725c8a8f93992025d"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1transform__transform__product__impl.html">internal::transform_transform_product_impl</a>&lt; <a class="el" href="classEigen_1_1Transform.html">Transform</a>, <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, <a class="el" href="classEigen_1_1MatrixBase.html">OtherMode</a>, <a class="el" href="classEigen_1_1MatrixBase.html">OtherOptions</a> &gt; &gt;::ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, <a class="el" href="classEigen_1_1MatrixBase.html">OtherMode</a>, <a class="el" href="classEigen_1_1MatrixBase.html">OtherOptions</a> &gt; &amp;other) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="memdesc:a79f09b6582cb700725c8a8f93992025d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two different transformations. <br /></td></tr>
<tr class="separator:a79f09b6582cb700725c8a8f93992025d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0c6b74994904b56b621cf3d9ac4a0f" id="r_a4f0c6b74994904b56b621cf3d9ac4a0f"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a4f0c6b74994904b56b621cf3d9ac4a0f">setIdentity</a> ()</td></tr>
<tr class="separator:a4f0c6b74994904b56b621cf3d9ac4a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdc927f1d1d01619b43c2041b93b241" id="r_abfdc927f1d1d01619b43c2041b93b241"><td class="memTemplParams" colspan="2"><a id="abfdc927f1d1d01619b43c2041b93b241" name="abfdc927f1d1d01619b43c2041b93b241"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:abfdc927f1d1d01619b43c2041b93b241"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="separator:abfdc927f1d1d01619b43c2041b93b241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbeff8bc70ccc9e25f5736f88dbab91a" id="r_adbeff8bc70ccc9e25f5736f88dbab91a"><td class="memTemplParams" colspan="2"><a id="adbeff8bc70ccc9e25f5736f88dbab91a" name="adbeff8bc70ccc9e25f5736f88dbab91a"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:adbeff8bc70ccc9e25f5736f88dbab91a"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prescale</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="separator:adbeff8bc70ccc9e25f5736f88dbab91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4f178cd06d8352607a79804e23d275" id="r_a7c4f178cd06d8352607a79804e23d275"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a7c4f178cd06d8352607a79804e23d275">scale</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;s)</td></tr>
<tr class="memdesc:a7c4f178cd06d8352607a79804e23d275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies on the right a uniform scale of a factor <em>c</em> to <code>*this</code> and returns a reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:a7c4f178cd06d8352607a79804e23d275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf0b66220d062523c0e3bc0f99a28b1" id="r_adcf0b66220d062523c0e3bc0f99a28b1"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#adcf0b66220d062523c0e3bc0f99a28b1">prescale</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;s)</td></tr>
<tr class="memdesc:adcf0b66220d062523c0e3bc0f99a28b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies on the left a uniform scale of a factor <em>c</em> to <code>*this</code> and returns a reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:adcf0b66220d062523c0e3bc0f99a28b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcac48f9eb270b8600adc9f61f0f44e2" id="r_afcac48f9eb270b8600adc9f61f0f44e2"><td class="memTemplParams" colspan="2"><a id="afcac48f9eb270b8600adc9f61f0f44e2" name="afcac48f9eb270b8600adc9f61f0f44e2"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:afcac48f9eb270b8600adc9f61f0f44e2"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>translate</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="separator:afcac48f9eb270b8600adc9f61f0f44e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2086414d3ce3be3678994010d87eee7" id="r_ad2086414d3ce3be3678994010d87eee7"><td class="memTemplParams" colspan="2"><a id="ad2086414d3ce3be3678994010d87eee7" name="ad2086414d3ce3be3678994010d87eee7"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:ad2086414d3ce3be3678994010d87eee7"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pretranslate</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="separator:ad2086414d3ce3be3678994010d87eee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecd0773d4d2ccfd7cfc3e781e135385" id="r_a3ecd0773d4d2ccfd7cfc3e781e135385"><td class="memTemplParams" colspan="2"><a id="a3ecd0773d4d2ccfd7cfc3e781e135385" name="a3ecd0773d4d2ccfd7cfc3e781e135385"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &gt; </td></tr>
<tr class="memitem:a3ecd0773d4d2ccfd7cfc3e781e135385"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rotate</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &amp;<a class="el" href="classEigen_1_1Transform.html#a692c68020ac2558ce87fd9dd0c7944cf">rotation</a>)</td></tr>
<tr class="separator:a3ecd0773d4d2ccfd7cfc3e781e135385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67e636cce34b98c24fde6de146882d2" id="r_aa67e636cce34b98c24fde6de146882d2"><td class="memTemplParams" colspan="2"><a id="aa67e636cce34b98c24fde6de146882d2" name="aa67e636cce34b98c24fde6de146882d2"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &gt; </td></tr>
<tr class="memitem:aa67e636cce34b98c24fde6de146882d2"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prerotate</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &amp;<a class="el" href="classEigen_1_1Transform.html#a692c68020ac2558ce87fd9dd0c7944cf">rotation</a>)</td></tr>
<tr class="separator:aa67e636cce34b98c24fde6de146882d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2999a84269a4a08d3af8a3ad1b0598ef" id="r_a2999a84269a4a08d3af8a3ad1b0598ef"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a2999a84269a4a08d3af8a3ad1b0598ef">shear</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;<a class="el" href="classEigen_1_1MatrixBase.html">sx</a>, <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;<a class="el" href="classEigen_1_1MatrixBase.html">sy</a>)</td></tr>
<tr class="memdesc:a2999a84269a4a08d3af8a3ad1b0598ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies on the right the shear transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:a2999a84269a4a08d3af8a3ad1b0598ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2540957bb590f16260689bcf32d28a7a" id="r_a2540957bb590f16260689bcf32d28a7a"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a2540957bb590f16260689bcf32d28a7a">preshear</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;<a class="el" href="classEigen_1_1MatrixBase.html">sx</a>, <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;<a class="el" href="classEigen_1_1MatrixBase.html">sy</a>)</td></tr>
<tr class="memdesc:a2540957bb590f16260689bcf32d28a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies on the left the shear transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:a2540957bb590f16260689bcf32d28a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d406aca4233e1bb6d4a35f48130b46" id="r_af7d406aca4233e1bb6d4a35f48130b46"><td class="memItemLeft" align="right" valign="top"><a id="af7d406aca4233e1bb6d4a35f48130b46" name="af7d406aca4233e1bb6d4a35f48130b46"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a6b463d14d8be4c0eda2eed6e943b831f">TranslationType</a> &amp;t)</td></tr>
<tr class="separator:af7d406aca4233e1bb6d4a35f48130b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b70f45134e512faf7730edd754583" id="r_a844b70f45134e512faf7730edd754583"><td class="memItemLeft" align="right" valign="top"><a id="a844b70f45134e512faf7730edd754583" name="a844b70f45134e512faf7730edd754583"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a6b463d14d8be4c0eda2eed6e943b831f">TranslationType</a> &amp;t)</td></tr>
<tr class="separator:a844b70f45134e512faf7730edd754583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab996e752b1e3c4c770acb948370af604" id="r_ab996e752b1e3c4c770acb948370af604"><td class="memItemLeft" align="right" valign="top"><a id="ab996e752b1e3c4c770acb948370af604" name="ab996e752b1e3c4c770acb948370af604"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a6b463d14d8be4c0eda2eed6e943b831f">TranslationType</a> &amp;t) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:ab996e752b1e3c4c770acb948370af604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f17e37d240ebe05a3e1cef00d542f2" id="r_aa2f17e37d240ebe05a3e1cef00d542f2"><td class="memItemLeft" align="right" valign="top"><a id="aa2f17e37d240ebe05a3e1cef00d542f2" name="aa2f17e37d240ebe05a3e1cef00d542f2"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1UniformScaling.html">UniformScaling</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &gt; &amp;t)</td></tr>
<tr class="separator:aa2f17e37d240ebe05a3e1cef00d542f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3def310ab46566be0430b1d3a627b1d4" id="r_a3def310ab46566be0430b1d3a627b1d4"><td class="memItemLeft" align="right" valign="top"><a id="a3def310ab46566be0430b1d3a627b1d4" name="a3def310ab46566be0430b1d3a627b1d4"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1UniformScaling.html">UniformScaling</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &gt; &amp;s)</td></tr>
<tr class="separator:a3def310ab46566be0430b1d3a627b1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ac6ff4ac93ededc79acd4e16f5c27f" id="r_a09ac6ff4ac93ededc79acd4e16f5c27f"><td class="memItemLeft" align="right" valign="top"><a id="a09ac6ff4ac93ededc79acd4e16f5c27f" name="a09ac6ff4ac93ededc79acd4e16f5c27f"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a51af5e8d8d9d9bfec091ff8aa5b7845a">TransformTimeDiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1UniformScaling.html">UniformScaling</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &gt; &amp;s) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:a09ac6ff4ac93ededc79acd4e16f5c27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab4241142ea2ad1a1e477f8d326e69" id="r_a1cab4241142ea2ad1a1e477f8d326e69"><td class="memItemLeft" align="right" valign="top"><a id="a1cab4241142ea2ad1a1e477f8d326e69" name="a1cab4241142ea2ad1a1e477f8d326e69"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1DiagonalMatrix.html">DiagonalMatrix</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim &gt; &amp;s)</td></tr>
<tr class="separator:a1cab4241142ea2ad1a1e477f8d326e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98a473e5e1042dc3bce9b44aa19d03c" id="r_af98a473e5e1042dc3bce9b44aa19d03c"><td class="memTemplParams" colspan="2"><a id="af98a473e5e1042dc3bce9b44aa19d03c" name="af98a473e5e1042dc3bce9b44aa19d03c"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> Derived &gt; </td></tr>
<tr class="memitem:af98a473e5e1042dc3bce9b44aa19d03c"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a>&lt; Derived, Dim &gt; &amp;r)</td></tr>
<tr class="separator:af98a473e5e1042dc3bce9b44aa19d03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e84e9671a245edd2ccd97ae40e09a95" id="r_a8e84e9671a245edd2ccd97ae40e09a95"><td class="memTemplParams" colspan="2"><a id="a8e84e9671a245edd2ccd97ae40e09a95" name="a8e84e9671a245edd2ccd97ae40e09a95"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> Derived &gt; </td></tr>
<tr class="memitem:a8e84e9671a245edd2ccd97ae40e09a95"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a>&lt; Derived, Dim &gt; &amp;r)</td></tr>
<tr class="separator:a8e84e9671a245edd2ccd97ae40e09a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dc871d26cdb87596b0e89134ace664" id="r_ad9dc871d26cdb87596b0e89134ace664"><td class="memTemplParams" colspan="2"><a id="ad9dc871d26cdb87596b0e89134ace664" name="ad9dc871d26cdb87596b0e89134ace664"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> Derived &gt; </td></tr>
<tr class="memitem:ad9dc871d26cdb87596b0e89134ace664"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a>&lt; Derived, Dim &gt; &amp;r) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:ad9dc871d26cdb87596b0e89134ace664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692c68020ac2558ce87fd9dd0c7944cf" id="r_a692c68020ac2558ce87fd9dd0c7944cf"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1true__type.html">RotationReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a692c68020ac2558ce87fd9dd0c7944cf">rotation</a> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:a692c68020ac2558ce87fd9dd0c7944cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2a75622ed0a24dbe4bd22e5aeccb78" id="r_aff2a75622ed0a24dbe4bd22e5aeccb78"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> RotationMatrixType , <a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">ScalingMatrixType</a> &gt; </td></tr>
<tr class="memitem:aff2a75622ed0a24dbe4bd22e5aeccb78"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#aff2a75622ed0a24dbe4bd22e5aeccb78">computeRotationScaling</a> (RotationMatrixType *<a class="el" href="classEigen_1_1Transform.html#a692c68020ac2558ce87fd9dd0c7944cf">rotation</a>, <a class="el" href="classEigen_1_1MatrixBase.html">ScalingMatrixType</a> *<a class="el" href="classEigen_1_1MatrixBase.html">scaling</a>) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="memdesc:aff2a75622ed0a24dbe4bd22e5aeccb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">decomposes the linear part of the transformation as a product rotation x scaling, the scaling being not necessarily positive.  <br /></td></tr>
<tr class="separator:aff2a75622ed0a24dbe4bd22e5aeccb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f214d6340a4ced22d673d54661e16c" id="r_a88f214d6340a4ced22d673d54661e16c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">ScalingMatrixType</a> , <a class="el" href="classEigen_1_1MatrixBase.html">typename</a> RotationMatrixType &gt; </td></tr>
<tr class="memitem:a88f214d6340a4ced22d673d54661e16c"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a88f214d6340a4ced22d673d54661e16c">computeScalingRotation</a> (<a class="el" href="classEigen_1_1MatrixBase.html">ScalingMatrixType</a> *<a class="el" href="classEigen_1_1MatrixBase.html">scaling</a>, RotationMatrixType *<a class="el" href="classEigen_1_1Transform.html#a692c68020ac2558ce87fd9dd0c7944cf">rotation</a>) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="memdesc:a88f214d6340a4ced22d673d54661e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">decomposes the linear part of the transformation as a product scaling x rotation, the scaling being not necessarily positive.  <br /></td></tr>
<tr class="separator:a88f214d6340a4ced22d673d54661e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bf341bf8a33d16866c807d638f7cf7" id="r_a46bf341bf8a33d16866c807d638f7cf7"><td class="memTemplParams" colspan="2"><a id="a46bf341bf8a33d16866c807d638f7cf7" name="a46bf341bf8a33d16866c807d638f7cf7"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">PositionDerived</a> , <a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OrientationType</a> , <a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">ScaleDerived</a> &gt; </td></tr>
<tr class="memitem:a46bf341bf8a33d16866c807d638f7cf7"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromPositionOrientationScale</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">PositionDerived</a> &gt; &amp;position, <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">OrientationType</a> &amp;<a class="el" href="classEigen_1_1MatrixBase.html">orientation</a>, <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">ScaleDerived</a> &gt; &amp;scale)</td></tr>
<tr class="separator:a46bf341bf8a33d16866c807d638f7cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ca137b84f18b9c41a0fef9c222e0da" id="r_a20ca137b84f18b9c41a0fef9c222e0da"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a20ca137b84f18b9c41a0fef9c222e0da">inverse</a> (<a class="el" href="group__enums.html#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a> traits=(<a class="el" href="group__enums.html#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a>) Mode) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:a20ca137b84f18b9c41a0fef9c222e0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10eaba0024c4b49914f94a1bb940244" id="r_af10eaba0024c4b49914f94a1bb940244"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#af10eaba0024c4b49914f94a1bb940244">data</a> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:af10eaba0024c4b49914f94a1bb940244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436626bc20796ef57877c98009911f34" id="r_a436626bc20796ef57877c98009911f34"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a436626bc20796ef57877c98009911f34">data</a> ()</td></tr>
<tr class="separator:a436626bc20796ef57877c98009911f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7307f094ad81893e4252667940fe4cf2" id="r_a7307f094ad81893e4252667940fe4cf2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> NewScalarType &gt; </td></tr>
<tr class="memitem:a7307f094ad81893e4252667940fe4cf2"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1cast__return__type.html">internal::cast_return_type</a>&lt; <a class="el" href="classEigen_1_1Transform.html">Transform</a>, <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; NewScalarType, Dim, Mode, Options &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a7307f094ad81893e4252667940fe4cf2">cast</a> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:a7307f094ad81893e4252667940fe4cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6f70385c79d72564e9b309f636ce1d" id="r_a2a6f70385c79d72564e9b309f636ce1d"><td class="memTemplParams" colspan="2"><a id="a2a6f70385c79d72564e9b309f636ce1d" name="a2a6f70385c79d72564e9b309f636ce1d"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherScalarType</a> &gt; </td></tr>
<tr class="memitem:a2a6f70385c79d72564e9b309f636ce1d"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Transform</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherScalarType</a>, Dim, Mode, Options &gt; &amp;other)</td></tr>
<tr class="memdesc:a2a6f70385c79d72564e9b309f636ce1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with scalar type conversion. <br /></td></tr>
<tr class="separator:a2a6f70385c79d72564e9b309f636ce1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8aabb371eb391a0d1fa0134b34ae376" id="r_aa8aabb371eb391a0d1fa0134b34ae376"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#aa8aabb371eb391a0d1fa0134b34ae376">isApprox</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;other, <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &gt;::Real &amp;<a class="el" href="classEigen_1_1MatrixBase.html">prec</a>=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &gt;::dummy_precision()) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:aa8aabb371eb391a0d1fa0134b34ae376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18580c6c151bac89f03818164dd19632" id="r_a18580c6c151bac89f03818164dd19632"><td class="memItemLeft" align="right" valign="top"><a id="a18580c6c151bac89f03818164dd19632" name="a18580c6c151bac89f03818164dd19632"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeAffine</b> ()</td></tr>
<tr class="memdesc:a18580c6c151bac89f03818164dd19632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the last row to [0 ... 0 1]. <br /></td></tr>
<tr class="separator:a18580c6c151bac89f03818164dd19632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff82884923ccf4468d49da71f5fb96e" id="r_adff82884923ccf4468d49da71f5fb96e"><td class="memItemLeft" align="right" valign="top"><a id="adff82884923ccf4468d49da71f5fb96e" name="adff82884923ccf4468d49da71f5fb96e"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, int(Mode)==int(<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0f7338b8672884554e8642bce9e44183">Projective</a>)?<a class="el" href="classEigen_1_1MatrixBase.html">HDim:Dim</a>, Dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>linearExt</b> ()</td></tr>
<tr class="separator:adff82884923ccf4468d49da71f5fb96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0154d961fbd710bacc2dabba4c6a7f65" id="r_a0154d961fbd710bacc2dabba4c6a7f65"><td class="memItemLeft" align="right" valign="top"><a id="a0154d961fbd710bacc2dabba4c6a7f65" name="a0154d961fbd710bacc2dabba4c6a7f65"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, int(Mode)==int(<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0f7338b8672884554e8642bce9e44183">Projective</a>)?<a class="el" href="classEigen_1_1MatrixBase.html">HDim:Dim</a>, Dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>linearExt</b> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:a0154d961fbd710bacc2dabba4c6a7f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec7b1ec455d53dbadec8d849a427e47" id="r_a7ec7b1ec455d53dbadec8d849a427e47"><td class="memItemLeft" align="right" valign="top"><a id="a7ec7b1ec455d53dbadec8d849a427e47" name="a7ec7b1ec455d53dbadec8d849a427e47"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, int(Mode)==int(<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0f7338b8672884554e8642bce9e44183">Projective</a>)?<a class="el" href="classEigen_1_1MatrixBase.html">HDim:Dim</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>translationExt</b> ()</td></tr>
<tr class="separator:a7ec7b1ec455d53dbadec8d849a427e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8bd5eb457788cff0dc30f88047c033" id="r_aaf8bd5eb457788cff0dc30f88047c033"><td class="memItemLeft" align="right" valign="top"><a id="aaf8bd5eb457788cff0dc30f88047c033" name="aaf8bd5eb457788cff0dc30f88047c033"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, int(Mode)==int(<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0f7338b8672884554e8642bce9e44183">Projective</a>)?<a class="el" href="classEigen_1_1MatrixBase.html">HDim:Dim</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>translationExt</b> () <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:aaf8bd5eb457788cff0dc30f88047c033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c6c7b9ca4f601ccb561002cf283aea" id="r_aa3c6c7b9ca4f601ccb561002cf283aea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:aa3c6c7b9ca4f601ccb561002cf283aea"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#aa3c6c7b9ca4f601ccb561002cf283aea">scale</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:aa3c6c7b9ca4f601ccb561002cf283aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies on the right the non uniform scale transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:aa3c6c7b9ca4f601ccb561002cf283aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7228fa1402fd49be9b8dde611d279670" id="r_a7228fa1402fd49be9b8dde611d279670"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:a7228fa1402fd49be9b8dde611d279670"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a7228fa1402fd49be9b8dde611d279670">prescale</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:a7228fa1402fd49be9b8dde611d279670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies on the left the non uniform scale transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:a7228fa1402fd49be9b8dde611d279670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac220a761685180ec0416d07bd6d0572b" id="r_ac220a761685180ec0416d07bd6d0572b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:ac220a761685180ec0416d07bd6d0572b"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#ac220a761685180ec0416d07bd6d0572b">translate</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:ac220a761685180ec0416d07bd6d0572b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies on the right the translation matrix represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:ac220a761685180ec0416d07bd6d0572b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6929d982c4b95a115f063a7353a7e8f" id="r_ac6929d982c4b95a115f063a7353a7e8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:ac6929d982c4b95a115f063a7353a7e8f"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#ac6929d982c4b95a115f063a7353a7e8f">pretranslate</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:ac6929d982c4b95a115f063a7353a7e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies on the left the translation matrix represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:ac6929d982c4b95a115f063a7353a7e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d528b872fa9d326edfa451839927f22" id="r_a5d528b872fa9d326edfa451839927f22"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &gt; </td></tr>
<tr class="memitem:a5d528b872fa9d326edfa451839927f22"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a5d528b872fa9d326edfa451839927f22">rotate</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &amp;<a class="el" href="classEigen_1_1Transform.html#a692c68020ac2558ce87fd9dd0c7944cf">rotation</a>)</td></tr>
<tr class="memdesc:a5d528b872fa9d326edfa451839927f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies on the right the rotation represented by the rotation <em>rotation</em> to <code>*this</code> and returns a reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:a5d528b872fa9d326edfa451839927f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a3920deeba7314e35a05ca46cea00c" id="r_a84a3920deeba7314e35a05ca46cea00c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &gt; </td></tr>
<tr class="memitem:a84a3920deeba7314e35a05ca46cea00c"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a84a3920deeba7314e35a05ca46cea00c">prerotate</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &amp;<a class="el" href="classEigen_1_1Transform.html#a692c68020ac2558ce87fd9dd0c7944cf">rotation</a>)</td></tr>
<tr class="memdesc:a84a3920deeba7314e35a05ca46cea00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies on the left the rotation represented by the rotation <em>rotation</em> to <code>*this</code> and returns a reference to <code>*this</code>.  <br /></td></tr>
<tr class="separator:a84a3920deeba7314e35a05ca46cea00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4b15a2186e293a829ae85fb68584a8" id="r_aec4b15a2186e293a829ae85fb68584a8"><td class="memTemplParams" colspan="2"><a id="aec4b15a2186e293a829ae85fb68584a8" name="aec4b15a2186e293a829ae85fb68584a8"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> Derived &gt; </td></tr>
<tr class="memitem:aec4b15a2186e293a829ae85fb68584a8"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a>&lt; Derived, Dim &gt; &amp;r)</td></tr>
<tr class="separator:aec4b15a2186e293a829ae85fb68584a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c9697ed25072cbfaada8ac1a894240" id="r_af8c9697ed25072cbfaada8ac1a894240"><td class="memTemplParams" colspan="2"><a id="af8c9697ed25072cbfaada8ac1a894240" name="af8c9697ed25072cbfaada8ac1a894240"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> Derived &gt; </td></tr>
<tr class="memitem:af8c9697ed25072cbfaada8ac1a894240"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a>&lt; Derived, Dim &gt; &amp;r) <a class="el" href="classEigen_1_1MatrixBase.html">const</a></td></tr>
<tr class="separator:af8c9697ed25072cbfaada8ac1a894240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a773950897cffaddcfc1e1b458cbcd" id="r_a56a773950897cffaddcfc1e1b458cbcd"><td class="memTemplParams" colspan="2"><a id="a56a773950897cffaddcfc1e1b458cbcd" name="a56a773950897cffaddcfc1e1b458cbcd"></a>
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">PositionDerived</a> , <a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OrientationType</a> , <a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">ScaleDerived</a> &gt; </td></tr>
<tr class="memitem:a56a773950897cffaddcfc1e1b458cbcd"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromPositionOrientationScale</b> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">PositionDerived</a> &gt; &amp;position, <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">OrientationType</a> &amp;<a class="el" href="classEigen_1_1MatrixBase.html">orientation</a>, <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">ScaleDerived</a> &gt; &amp;scale)</td></tr>
<tr class="memdesc:a56a773950897cffaddcfc1e1b458cbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient method to set <code>*this</code> from a position, orientation and scale of a 3D object. <br /></td></tr>
<tr class="separator:a56a773950897cffaddcfc1e1b458cbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a41e2e58b09790eb8e3e220acceb7de1f" id="r_a41e2e58b09790eb8e3e220acceb7de1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html">static</a> EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a41e2e58b09790eb8e3e220acceb7de1f">Identity</a> ()</td></tr>
<tr class="memdesc:a41e2e58b09790eb8e3e220acceb7de1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity transformation.  <br /></td></tr>
<tr class="separator:a41e2e58b09790eb8e3e220acceb7de1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:af75a08a53b1769e6e92bb6d71ea39fc4" id="r_af75a08a53b1769e6e92bb6d71ea39fc4"><td class="memItemLeft" align="right" valign="top"><a id="af75a08a53b1769e6e92bb6d71ea39fc4" name="af75a08a53b1769e6e92bb6d71ea39fc4"></a>
<a class="el" href="classEigen_1_1MatrixBase.html">static</a> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1MatrixBase.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>check_template_params</b> ()</td></tr>
<tr class="separator:af75a08a53b1769e6e92bb6d71ea39fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a36319dc6139bfc7e102143d7d16cbe10" id="r_a36319dc6139bfc7e102143d7d16cbe10"><td class="memItemLeft" align="right" valign="top"><a id="a36319dc6139bfc7e102143d7d16cbe10" name="a36319dc6139bfc7e102143d7d16cbe10"></a>
<a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_matrix</b></td></tr>
<tr class="separator:a36319dc6139bfc7e102143d7d16cbe10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:acf92e7145cc20f09f5d0bee9fce26389" id="r_acf92e7145cc20f09f5d0bee9fce26389"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </td></tr>
<tr class="memitem:acf92e7145cc20f09f5d0bee9fce26389"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1internal_1_1transform__left__product__impl.html">internal::transform_left_product_impl</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a>, Mode, Options, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>+1 &gt;::ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#acf92e7145cc20f09f5d0bee9fce26389">operator*</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;a, <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;b)</td></tr>
<tr class="separator:acf92e7145cc20f09f5d0bee9fce26389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee8a506136a4ac8084b2913cc249ec8" id="r_a1ee8a506136a4ac8084b2913cc249ec8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">DiagonalDerived</a> &gt; </td></tr>
<tr class="memitem:a1ee8a506136a4ac8084b2913cc249ec8"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">friend</a> <a class="el" href="classEigen_1_1Transform.html#a51af5e8d8d9d9bfec091ff8aa5b7845a">TransformTimeDiagonalReturnType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html#a1ee8a506136a4ac8084b2913cc249ec8">operator*</a> (<a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1DiagonalBase.html">DiagonalBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">DiagonalDerived</a> &gt; &amp;a, <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a> &amp;b)</td></tr>
<tr class="separator:a1ee8a506136a4ac8084b2913cc249ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar, int _Dim, int _Mode, int _Options&gt;<br />
class Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt;</div><p>\geometry_module </p>
<p>Represents an homogeneous transformation in a N dimensional space</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Scalar</td><td>the scalar type, i.e., the type of the coefficients </td></tr>
    <tr><td class="paramname">_Dim</td><td>the dimension of the space </td></tr>
    <tr><td class="paramname">_Mode</td><td>the type of the transformation. Can be:<ul>
<li><a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0872f0a82453aaae40339c33acbb31fb" title="Transformation is an affine transformation stored as a (Dim+1)^2 matrix whose last row is assumed to ...">Affine</a>: the transformation is stored as a (Dim+1)^2 matrix, where the last row is assumed to be [0 ... 0 1].</li>
<li><a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490" title="Transformation is an affine transformation stored as a (Dim) x (Dim+1) matrix.">AffineCompact</a>: the transformation is stored as a (Dim)x(Dim+1) matrix.</li>
<li><a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0f7338b8672884554e8642bce9e44183" title="Transformation is a general projective transformation stored as a (Dim+1)^2 matrix.">Projective</a>: the transformation is stored as a (Dim+1)^2 matrix without any assumption.</li>
<li><a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a84413028615d2d718bafd2dfb93dafef" title="Transformation is an isometry.">Isometry</a>: same as <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0872f0a82453aaae40339c33acbb31fb" title="Transformation is an affine transformation stored as a (Dim+1)^2 matrix whose last row is assumed to ...">Affine</a> with the additional assumption that the linear part represents a rotation. This assumption is exploited to speed up some functions such as <a class="el" href="classEigen_1_1Transform.html#a20ca137b84f18b9c41a0fef9c222e0da">inverse()</a> and <a class="el" href="classEigen_1_1Transform.html#a692c68020ac2558ce87fd9dd0c7944cf">rotation()</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">_Options</td><td>has the same meaning as in class <a class="el" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a>. It allows to specify DontAlign and/or RowMajor. These Options are passed directly to the underlying matrix type.</td></tr>
  </table>
  </dd>
</dl>
<p>The homography is internally represented and stored by a matrix which is available through the <a class="el" href="classEigen_1_1Transform.html#a146347395d7dcfd250b6f9f96f9ed233">matrix()</a> method. To understand the behavior of this class you have to think a <a class="el" href="classEigen_1_1Transform.html" title="\geometry_module">Transform</a> object as its internal matrix representation. The chosen convention is right multiply:</p>
<div class="fragment"><div class="line">v<span class="stringliteral">&#39; = T * v </span></div>
</div><!-- fragment --><p>Therefore, an affine transformation matrix M is shaped like this:</p>
<p><picture><source srcset="form_119_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \left( \begin{array}{cc}
 linear &amp; translation\\
 0 ... 0 &amp; 1
 \end{array} \right) $" src="form_119.png"/></picture></p>
<p>Note that for a projective transformation the last row can be anything, and then the interpretation of different parts might be slightly different.</p>
<p>However, unlike a plain matrix, the <a class="el" href="classEigen_1_1Transform.html" title="\geometry_module">Transform</a> class provides many features simplifying both its assembly and usage. In particular, it can be composed with any other transformations (<a class="el" href="classEigen_1_1Transform.html" title="\geometry_module">Transform</a>,<a class="el" href="classEigen_1_1Translation.html" title="\geometry_module">Translation</a>,<a class="el" href="classEigen_1_1RotationBase.html" title="Common base class for compact rotation representations.">RotationBase</a>,<a class="el" href="classEigen_1_1DiagonalMatrix.html" title="Represents a diagonal matrix with its storage.">DiagonalMatrix</a>) and can be directly used to transform implicit homogeneous vectors. All these operations are handled via the operator*. For the composition of transformations, its principle consists to first convert the right/left hand sides of the product to a compatible (Dim+1)^2 matrix and then perform a pure matrix product. Of course, internally, operator* tries to perform the minimal number of operations according to the nature of each terms. Likewise, when applying the transform to points, the latters are automatically promoted to homogeneous vectors before doing the matrix product. The conventions to homogeneous representations are performed as follow:</p>
<p><b><a class="el" href="classEigen_1_1Translation.html" title="\geometry_module">Translation</a></b> t (Dim)x(1):  <picture><source srcset="form_120_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \left( \begin{array}{cc}
 I &amp; t \\
 0\,...\,0 &amp; 1
 \end{array} \right) $" src="form_120.png"/></picture></p>
<p><b>Rotation</b> R (Dim)x(Dim):  <picture><source srcset="form_121_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \left( \begin{array}{cc}
 R &amp; 0\\
 0\,...\,0 &amp; 1
 \end{array} \right) $" src="form_121.png"/></picture></p>
<p><b>Scaling</b> <b><a class="el" href="classEigen_1_1DiagonalMatrix.html" title="Represents a diagonal matrix with its storage.">DiagonalMatrix</a></b> S (Dim)x(Dim):  <picture><source srcset="form_122_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \left( \begin{array}{cc}
 S &amp; 0\\
 0\,...\,0 &amp; 1
 \end{array} \right) $" src="form_122.png"/></picture></p>
<p><b>Column</b> <b>point</b> v (Dim)x(1):  <picture><source srcset="form_123_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \left( \begin{array}{c}
 v\\
 1
 \end{array} \right) $" src="form_123.png"/></picture></p>
<p><b>Set</b> <b>of</b> <b>column</b> <b>points</b> V1...Vn (Dim)x(n):  <picture><source srcset="form_124_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \left( \begin{array}{ccc}
 v_1 &amp; ... &amp; v_n\\
 1 &amp; ... &amp; 1
 \end{array} \right) $" src="form_124.png"/></picture></p>
<p>The concatenation of a <a class="el" href="classEigen_1_1Transform.html" title="\geometry_module">Transform</a> object with any kind of other transformation always returns a <a class="el" href="classEigen_1_1Transform.html" title="\geometry_module">Transform</a> object.</p>
<p>A little exception to the "as pure matrix product" rule is the case of the transformation of non homogeneous vectors by an affine transformation. In that case the last matrix row can be ignored, and the product returns non homogeneous vectors.</p>
<p>Since, for instance, a Dim x Dim matrix is interpreted as a linear transformation, it is not possible to directly transform Dim vectors stored in a Dim x Dim matrix. The solution is either to use a Dim x Dynamic matrix or explicitly request a vector transformation by making the vector homogeneous: </p><div class="fragment"><div class="line">m<span class="stringliteral">&#39; = T * m.colwise().homogeneous();</span></div>
</div><!-- fragment --><p> Note that there is zero overhead.</p>
<p>Conversion methods from/to Qt's <a class="el" href="classQMatrix.html">QMatrix</a> and QTransform are available if the preprocessor token EIGEN_QT_SUPPORT is defined.</p>
<p>This class can be extended with the help of the plugin mechanism described on the page TopicCustomizing_Plugins by defining the preprocessor symbol <code>EIGEN_TRANSFORM_PLUGIN</code>.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a>, class <a class="el" href="classEigen_1_1Quaternion.html" title="\geometry_module">Quaternion</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a49df3689ac2b736bcb564dec47d6486c" name="a49df3689ac2b736bcb564dec47d6486c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49df3689ac2b736bcb564dec47d6486c">&#9670;&#160;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">typedef</a> <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::Index</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>since <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3 </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a79b94ccee0f7871610fa2fa084e0fd59" name="a79b94ccee0f7871610fa2fa084e0fd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b94ccee0f7871610fa2fa084e0fd59">&#9670;&#160;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::Transform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor without initialization of the meaningful coefficients. </p>
<p>If Mode==Affine or Mode==Isometry, then the last row is set to [0 ... 0 1] </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a77b379a598ff0e570a8112db65111a94" name="a77b379a598ff0e570a8112db65111a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b379a598ff0e570a8112db65111a94">&#9670;&#160;</a></span>affine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a654d40214886008458a977f738252c1d">AffinePart</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::affine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable expression of the Dim x HDim affine part of the transformation </dd></dl>

</div>
</div>
<a id="a88c996ca4cccf46ab4d520b7d99c332b" name="a88c996ca4cccf46ab4d520b7d99c332b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c996ca4cccf46ab4d520b7d99c332b">&#9670;&#160;</a></span>affine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a719486ada918954a8ffad3d174d08817">ConstAffinePart</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::affine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a read-only expression of the Dim x HDim affine part of the transformation </dd></dl>

</div>
</div>
<a id="a7307f094ad81893e4252667940fe4cf2" name="a7307f094ad81893e4252667940fe4cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7307f094ad81893e4252667940fe4cf2">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> NewScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1cast__return__type.html">internal::cast_return_type</a>&lt; <a class="el" href="classEigen_1_1Transform.html">Transform</a>, <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; NewScalarType, Dim, Mode, Options &gt; &gt;::type <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> with scalar type casted to <em>NewScalarType</em> </dd></dl>
<p>Note that if <em>NewScalarType</em> is equal to the current scalar type of <code>*this</code> then this function smartly returns a const reference to <code>*this</code>. </p>

</div>
</div>
<a id="aff2a75622ed0a24dbe4bd22e5aeccb78" name="aff2a75622ed0a24dbe4bd22e5aeccb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2a75622ed0a24dbe4bd22e5aeccb78">&#9670;&#160;</a></span>computeRotationScaling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> , int Dim, int Mode, int Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> RotationMatrixType , <a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">ScalingMatrixType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">void</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::computeRotationScaling </td>
          <td>(</td>
          <td class="paramtype">RotationMatrixType *&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">ScalingMatrixType</a> *&#160;</td>
          <td class="paramname"><em>scaling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decomposes the linear part of the transformation as a product rotation x scaling, the scaling being not necessarily positive. </p>
<p>If either pointer is zero, the corresponding computation is skipped.</p>
<p>\svd_module</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1Transform.html#a88f214d6340a4ced22d673d54661e16c" title="decomposes the linear part of the transformation as a product scaling x rotation, the scaling being n...">computeScalingRotation()</a>, <a class="el" href="classEigen_1_1Transform.html#a692c68020ac2558ce87fd9dd0c7944cf">rotation()</a>, class SVD </dd></dl>

</div>
</div>
<a id="a88f214d6340a4ced22d673d54661e16c" name="a88f214d6340a4ced22d673d54661e16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f214d6340a4ced22d673d54661e16c">&#9670;&#160;</a></span>computeScalingRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> , int Dim, int Mode, int Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">ScalingMatrixType</a> , <a class="el" href="classEigen_1_1MatrixBase.html">typename</a> RotationMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">void</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::computeScalingRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">ScalingMatrixType</a> *&#160;</td>
          <td class="paramname"><em>scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RotationMatrixType *&#160;</td>
          <td class="paramname"><em>rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decomposes the linear part of the transformation as a product scaling x rotation, the scaling being not necessarily positive. </p>
<p>If either pointer is zero, the corresponding computation is skipped.</p>
<p>\svd_module</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1Transform.html#aff2a75622ed0a24dbe4bd22e5aeccb78" title="decomposes the linear part of the transformation as a product rotation x scaling, the scaling being n...">computeRotationScaling()</a>, <a class="el" href="classEigen_1_1Transform.html#a692c68020ac2558ce87fd9dd0c7944cf">rotation()</a>, class SVD </dd></dl>

</div>
</div>
<a id="a436626bc20796ef57877c98009911f34" name="a436626bc20796ef57877c98009911f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436626bc20796ef57877c98009911f34">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> * <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the column major internal matrix </dd></dl>

</div>
</div>
<a id="af10eaba0024c4b49914f94a1bb940244" name="af10eaba0024c4b49914f94a1bb940244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10eaba0024c4b49914f94a1bb940244">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> * <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the column major internal matrix </dd></dl>

</div>
</div>
<a id="a30c94c2156e9345f4bdb6cc9661e275b" name="a30c94c2156e9345f4bdb6cc9661e275b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c94c2156e9345f4bdb6cc9661e275b">&#9670;&#160;</a></span>EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE </td>
          <td>(</td>
          <td class="paramtype">_Scalar&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>&#160;</td>
          <td class="paramname"> = <code>=<a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&#160;?&#160;<a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&#160;:&#160;(<a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>+1)*(<a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>+1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>&lt; space dimension in which the transformation holds</p>
<p>&lt; size of a respective homogeneous vector</p>

</div>
</div>
<a id="a41e2e58b09790eb8e3e220acceb7de1f" name="a41e2e58b09790eb8e3e220acceb7de1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e2e58b09790eb8e3e220acceb7de1f">&#9670;&#160;</a></span>Identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">static</a> EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::Identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity transformation. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>In the future this function should be returning a <a class="el" href="classEigen_1_1Transform.html" title="\geometry_module">Transform</a> expression. </dd></dl>

</div>
</div>
<a id="a20ca137b84f18b9c41a0fef9c222e0da" name="a20ca137b84f18b9c41a0fef9c222e0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ca137b84f18b9c41a0fef9c222e0da">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> , int Dim, int Mode, int Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a>&#160;</td>
          <td class="paramname"><em>hint</em> = <code>(<a class="el" href="group__enums.html#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a>)Mode</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inverse transformation according to some given knowledge on <code>*this</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>allows to optimize the inversion process when the transformation is known to be not a general transformation (optional). The possible values are:<ul>
<li><a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0f7338b8672884554e8642bce9e44183" title="Transformation is a general projective transformation stored as a (Dim+1)^2 matrix.">Projective</a> if the transformation is not necessarily affine, i.e., if the last row is not guaranteed to be [0 ... 0 1]</li>
<li><a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0872f0a82453aaae40339c33acbb31fb" title="Transformation is an affine transformation stored as a (Dim+1)^2 matrix whose last row is assumed to ...">Affine</a> if the last row can be assumed to be [0 ... 0 1]</li>
<li><a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a84413028615d2d718bafd2dfb93dafef" title="Transformation is an isometry.">Isometry</a> if the transformation is only a concatenations of translations and rotations. The default is the template class parameter <code>Mode</code>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>unless <em>traits</em> is always set to NoShear or NoScaling, this function requires the generic inverse method of <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> defined in the LU module. If you forget to include this module, then you will get hard to debug linking errors.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#add090d35d12d42d01eba1a24f22cf8f3" title="\lu_module">MatrixBase::inverse()</a> </dd></dl>

</div>
</div>
<a id="aa8aabb371eb391a0d1fa0134b34ae376" name="aa8aabb371eb391a0d1fa0134b34ae376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8aabb371eb391a0d1fa0134b34ae376">&#9670;&#160;</a></span>isApprox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC bool <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::isApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &gt;::Real &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> is approximately equal to <em>other</em>, within the precision determined by <em>prec</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#af3793521d788a946cb9c5f4f92bab4d3">MatrixBase::isApprox()</a> </dd></dl>

</div>
</div>
<a id="a540cef80cd714fa01d124536d39ac8da" name="a540cef80cd714fa01d124536d39ac8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540cef80cd714fa01d124536d39ac8da">&#9670;&#160;</a></span>linear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a2195bd42561e691a8f6e7d989e77f328">LinearPart</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::linear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable expression of the linear part of the transformation </dd></dl>

</div>
</div>
<a id="a535bd63d047c2a36585c3f9b62219a1e" name="a535bd63d047c2a36585c3f9b62219a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535bd63d047c2a36585c3f9b62219a1e">&#9670;&#160;</a></span>linear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a75810d3f0d098e00b43a5531f33d78e1">ConstLinearPart</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::linear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a read-only expression of the linear part of the transformation </dd></dl>

</div>
</div>
<a id="a146347395d7dcfd250b6f9f96f9ed233" name="a146347395d7dcfd250b6f9f96f9ed233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146347395d7dcfd250b6f9f96f9ed233">&#9670;&#160;</a></span>matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable expression of the transformation matrix </dd></dl>

</div>
</div>
<a id="a8a5d077e6e87e7d0a1f347fbc4d52a6e" name="a8a5d077e6e87e7d0a1f347fbc4d52a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5d077e6e87e7d0a1f347fbc4d52a6e">&#9670;&#160;</a></span>matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a read-only expression of the transformation matrix </dd></dl>

</div>
</div>
<a id="a466edc122165a02326dd1126d7f93078" name="a466edc122165a02326dd1126d7f93078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466edc122165a02326dd1126d7f93078">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>shortcut for m_matrix(row,col); </p>
<dl class="section see"><dt>See also</dt><dd>MatrixBase::operator(Index,Index) </dd></dl>

</div>
</div>
<a id="aa0a930a85c51566fe06d281da85d1a4a" name="aa0a930a85c51566fe06d281da85d1a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a930a85c51566fe06d281da85d1a4a">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Transform.html#a49df3689ac2b736bcb564dec47d6486c">Index</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>shortcut for m_matrix(row,col); </p>
<dl class="section see"><dt>See also</dt><dd>MatrixBase::operator(Index,Index) const  </dd></dl>

</div>
</div>
<a id="a4f566a9fef984636431d6d5ebea0ba67" name="a4f566a9fef984636431d6d5ebea0ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f566a9fef984636431d6d5ebea0ba67">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">DiagonalDerived</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a51af5e8d8d9d9bfec091ff8aa5b7845a">TransformTimeDiagonalReturnType</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1DiagonalBase.html">DiagonalBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">DiagonalDerived</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The product expression of a transform <em>a</em> times a diagonal matrix <em>b</em> </dd></dl>
<p>The rhs diagonal matrix is interpreted as an affine scaling transformation. The product results in a <a class="el" href="classEigen_1_1Transform.html" title="\geometry_module">Transform</a> of the same type (mode) as the lhs only if the lhs mode is no isometry. In that case, the returned transform is an affinity. </p>

</div>
</div>
<a id="a56eb11fd16b64878e3e07681ab7a695d" name="a56eb11fd16b64878e3e07681ab7a695d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56eb11fd16b64878e3e07681ab7a695d">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1internal_1_1transform__right__product__impl.html">internal::transform_right_product_impl</a>&lt; <a class="el" href="classEigen_1_1Transform.html">Transform</a>, <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt;::ResultType <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the product between the transform <code>*this</code> and a matrix expression <em>other</em>.</dd></dl>
<p>The right-hand-side <em>other</em> can be either: </p><ul>
<li>an homogeneous vector of size Dim+1, </li>
<li>a set of homogeneous vectors of size Dim+1 x N, </li>
<li>a transformation matrix of size Dim+1 x Dim+1.</li>
</ul>
<p>Moreover, if <code>*this</code> represents an affine transformation (i.e., Mode!=Projective), then <em>other</em> can also be: </p><ul>
<li>a point of size Dim (computes: <div class="fragment"><div class="line">this-&gt;<a class="code hl_function" href="classEigen_1_1Transform.html#a535bd63d047c2a36585c3f9b62219a1e">linear</a>() * other + this-&gt;<a class="code hl_function" href="classEigen_1_1Transform.html#afa93ba97d26912bb3d8777cbed102045">translation</a>()</div>
<div class="ttc" id="aclassEigen_1_1Transform_html_a535bd63d047c2a36585c3f9b62219a1e"><div class="ttname"><a href="classEigen_1_1Transform.html#a535bd63d047c2a36585c3f9b62219a1e">Eigen::Transform::linear</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC ConstLinearPart linear() const</div><div class="ttdef"><b>Definition</b> Transform.h:394</div></div>
<div class="ttc" id="aclassEigen_1_1Transform_html_afa93ba97d26912bb3d8777cbed102045"><div class="ttname"><a href="classEigen_1_1Transform.html#afa93ba97d26912bb3d8777cbed102045">Eigen::Transform::translation</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC ConstTranslationPart translation() const</div><div class="ttdef"><b>Definition</b> Transform.h:404</div></div>
</div><!-- fragment -->), </li>
<li>a set of N points as a Dim x N matrix (computes: <div class="fragment"><div class="line">(this-&gt;<a class="code hl_function" href="classEigen_1_1Transform.html#a535bd63d047c2a36585c3f9b62219a1e">linear</a>() * other).colwise() + this-&gt;<a class="code hl_function" href="classEigen_1_1Transform.html#afa93ba97d26912bb3d8777cbed102045">translation</a>()</div>
</div><!-- fragment -->),</li>
</ul>
<p>In all cases, the return type is a matrix or vector of same sizes as the right-hand-side <em>other</em>.</p>
<p>If you want to interpret <em>other</em> as a linear or affine transformation, then first convert it to a Transform&lt;&gt; type, or do your own cooking.</p>
<p>Finally, if you want to apply Affine transformations to vectors, then explicitly apply the linear part only: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1MatrixBase.html">Affine3f</a> A;</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1MatrixBase.html">Vector3f</a> <a class="code hl_class" href="classEigen_1_1MatrixBase.html">v1</a>, <a class="code hl_class" href="classEigen_1_1MatrixBase.html">v2</a>;</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1MatrixBase.html">v2</a> = A.linear() * <a class="code hl_class" href="classEigen_1_1MatrixBase.html">v1</a>;</div>
<div class="ttc" id="aclassEigen_1_1MatrixBase_html"><div class="ttname"><a href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a></div><div class="ttdoc">Base class for all dense matrices, vectors, and expressions.</div><div class="ttdef"><b>Definition</b> MatrixBase.h:50</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a84a3920deeba7314e35a05ca46cea00c" name="a84a3920deeba7314e35a05ca46cea00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a3920deeba7314e35a05ca46cea00c">&#9670;&#160;</a></span>prerotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::prerotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies on the left the rotation represented by the rotation <em>rotation</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<p>See rotate() for further details.</p>
<dl class="section see"><dt>See also</dt><dd>rotate() </dd></dl>

</div>
</div>
<a id="a7228fa1402fd49be9b8dde611d279670" name="a7228fa1402fd49be9b8dde611d279670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7228fa1402fd49be9b8dde611d279670">&#9670;&#160;</a></span>prescale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::prescale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies on the left the non uniform scale transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl class="section see"><dt>See also</dt><dd>scale() </dd></dl>

</div>
</div>
<a id="adcf0b66220d062523c0e3bc0f99a28b1" name="adcf0b66220d062523c0e3bc0f99a28b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf0b66220d062523c0e3bc0f99a28b1">&#9670;&#160;</a></span>prescale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> , int Dim, int Mode, int Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::prescale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies on the left a uniform scale of a factor <em>c</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl class="section see"><dt>See also</dt><dd>scale(Scalar) </dd></dl>

</div>
</div>
<a id="a2540957bb590f16260689bcf32d28a7a" name="a2540957bb590f16260689bcf32d28a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2540957bb590f16260689bcf32d28a7a">&#9670;&#160;</a></span>preshear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> , int Dim, int Mode, int Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::preshear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies on the left the shear transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>2D only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1Transform.html#a2999a84269a4a08d3af8a3ad1b0598ef" title="Applies on the right the shear transformation represented by the vector other to *this and returns a ...">shear()</a> </dd></dl>

</div>
</div>
<a id="ac6929d982c4b95a115f063a7353a7e8f" name="ac6929d982c4b95a115f063a7353a7e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6929d982c4b95a115f063a7353a7e8f">&#9670;&#160;</a></span>pretranslate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::pretranslate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies on the left the translation matrix represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl class="section see"><dt>See also</dt><dd>translate() </dd></dl>

</div>
</div>
<a id="a5d528b872fa9d326edfa451839927f22" name="a5d528b872fa9d326edfa451839927f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d528b872fa9d326edfa451839927f22">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">RotationType</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies on the right the rotation represented by the rotation <em>rotation</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<p>The template parameter <em>RotationType</em> is the type of the rotation which must be known by internal::toRotationMatrix&lt;&gt;.</p>
<p>Natively supported types includes:</p><ul>
<li>any scalar (2D),</li>
<li>a Dim x Dim matrix expression,</li>
<li>a <a class="el" href="classEigen_1_1Quaternion.html" title="\geometry_module">Quaternion</a> (3D),</li>
<li>a <a class="el" href="classEigen_1_1AngleAxis.html" title="\geometry_module">AngleAxis</a> (3D)</li>
</ul>
<p>This mechanism is easily extendable to support user types such as Euler angles, or a pair of <a class="el" href="classEigen_1_1Quaternion.html" title="\geometry_module">Quaternion</a> for 4D rotations.</p>
<dl class="section see"><dt>See also</dt><dd>rotate(Scalar), class <a class="el" href="classEigen_1_1Quaternion.html" title="\geometry_module">Quaternion</a>, class <a class="el" href="classEigen_1_1AngleAxis.html" title="\geometry_module">AngleAxis</a>, prerotate(RotationType) </dd></dl>

</div>
</div>
<a id="a692c68020ac2558ce87fd9dd0c7944cf" name="a692c68020ac2558ce87fd9dd0c7944cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692c68020ac2558ce87fd9dd0c7944cf">&#9670;&#160;</a></span>rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> , int Dim, int Mode, int Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::RotationReturnType <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::rotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the rotation part of the transformation</dd></dl>
<p>If Mode==Isometry, then this method is an alias for <a class="el" href="classEigen_1_1Transform.html#a535bd63d047c2a36585c3f9b62219a1e">linear()</a>, otherwise it calls <a class="el" href="classEigen_1_1Transform.html#aff2a75622ed0a24dbe4bd22e5aeccb78" title="decomposes the linear part of the transformation as a product rotation x scaling, the scaling being n...">computeRotationScaling()</a> to extract the rotation through a SVD decomposition.</p>
<p>\svd_module</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1Transform.html#aff2a75622ed0a24dbe4bd22e5aeccb78" title="decomposes the linear part of the transformation as a product rotation x scaling, the scaling being n...">computeRotationScaling()</a>, <a class="el" href="classEigen_1_1Transform.html#a88f214d6340a4ced22d673d54661e16c" title="decomposes the linear part of the transformation as a product scaling x rotation, the scaling being n...">computeScalingRotation()</a>, class SVD </dd></dl>

</div>
</div>
<a id="aa3c6c7b9ca4f601ccb561002cf283aea" name="aa3c6c7b9ca4f601ccb561002cf283aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c6c7b9ca4f601ccb561002cf283aea">&#9670;&#160;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies on the right the non uniform scale transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl class="section see"><dt>See also</dt><dd>prescale() </dd></dl>

</div>
</div>
<a id="a7c4f178cd06d8352607a79804e23d275" name="a7c4f178cd06d8352607a79804e23d275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4f178cd06d8352607a79804e23d275">&#9670;&#160;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> , int Dim, int Mode, int Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies on the right a uniform scale of a factor <em>c</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl class="section see"><dt>See also</dt><dd>prescale(Scalar) </dd></dl>

</div>
</div>
<a id="a4f0c6b74994904b56b621cf3d9ac4a0f" name="a4f0c6b74994904b56b621cf3d9ac4a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0c6b74994904b56b621cf3d9ac4a0f">&#9670;&#160;</a></span>setIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">void</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::setIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ae05be7fcc1ade707f0b73eb5f9d8cf33" title="Writes the identity expression (not necessarily square) into *this.">MatrixBase::setIdentity()</a> </dd></dl>

</div>
</div>
<a id="a2999a84269a4a08d3af8a3ad1b0598ef" name="a2999a84269a4a08d3af8a3ad1b0598ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2999a84269a4a08d3af8a3ad1b0598ef">&#9670;&#160;</a></span>shear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> , int Dim, int Mode, int Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::shear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies on the right the shear transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>2D only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1Transform.html#a2540957bb590f16260689bcf32d28a7a" title="Applies on the left the shear transformation represented by the vector other to *this and returns a r...">preshear()</a> </dd></dl>

</div>
</div>
<a id="ac220a761685180ec0416d07bd6d0572b" name="ac220a761685180ec0416d07bd6d0572b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac220a761685180ec0416d07bd6d0572b">&#9670;&#160;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; <a class="el" href="classEigen_1_1Transform.html#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies on the right the translation matrix represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl class="section see"><dt>See also</dt><dd>pretranslate() </dd></dl>

</div>
</div>
<a id="ae76fc36f20276787741859cb5ebd5901" name="ae76fc36f20276787741859cb5ebd5901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76fc36f20276787741859cb5ebd5901">&#9670;&#160;</a></span>translation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#aabeaa2d375bf1b6b1d5cb5d1904fbd06">TranslationPart</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::translation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable expression of the translation vector of the transformation </dd></dl>

</div>
</div>
<a id="afa93ba97d26912bb3d8777cbed102045" name="afa93ba97d26912bb3d8777cbed102045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa93ba97d26912bb3d8777cbed102045">&#9670;&#160;</a></span>translation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transform.html#a3eab3259d3fac8106eb3139bc96ba852">ConstTranslationPart</a> <a class="el" href="classEigen_1_1Transform.html">Eigen::Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt;::translation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a read-only expression of the translation vector of the transformation </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a1ee8a506136a4ac8084b2913cc249ec8" name="a1ee8a506136a4ac8084b2913cc249ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee8a506136a4ac8084b2913cc249ec8">&#9670;&#160;</a></span>operator* <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">DiagonalDerived</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">friend</a> <a class="el" href="classEigen_1_1Transform.html#a51af5e8d8d9d9bfec091ff8aa5b7845a">TransformTimeDiagonalReturnType</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1DiagonalBase.html">DiagonalBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">DiagonalDerived</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The product expression of a diagonal matrix <em>a</em> times a transform <em>b</em> </dd></dl>
<p>The lhs diagonal matrix is interpreted as an affine scaling transformation. The product results in a <a class="el" href="classEigen_1_1Transform.html" title="\geometry_module">Transform</a> of the same type (mode) as the lhs only if the lhs mode is no isometry. In that case, the returned transform is an affinity. </p>

</div>
</div>
<a id="acf92e7145cc20f09f5d0bee9fce26389" name="acf92e7145cc20f09f5d0bee9fce26389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf92e7145cc20f09f5d0bee9fce26389">&#9670;&#160;</a></span>operator* <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> _Scalar , int _Dim, int _Mode, int _Options&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classEigen_1_1MatrixBase.html">typename</a> <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1internal_1_1transform__left__product__impl.html">internal::transform_left_product_impl</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a>, Mode, Options, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>+1 &gt;::ResultType operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; <a class="el" href="classEigen_1_1MatrixBase.html">OtherDerived</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1MatrixBase.html">const</a> <a class="el" href="classEigen_1_1Transform.html">Transform</a>&lt; _Scalar, <a class="el" href="classEigen_1_1MatrixBase.html">_Dim</a>, <a class="el" href="classEigen_1_1MatrixBase.html">_Mode</a>, _Options &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the product expression of a transformation matrix <em>a</em> times a transform <em>b</em> </dd></dl>
<p>The left hand side <em>other</em> can be either: </p><ul>
<li>a linear transformation matrix of size Dim x Dim, </li>
<li>an affine transformation matrix of size Dim x Dim+1, </li>
<li>a general transformation matrix of size Dim+1 x Dim+1. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>External/Eigen/src/Core/util/<a class="el" href="ForwardDeclarations_8h_source.html">ForwardDeclarations.h</a></li>
<li>External/Eigen/src/Geometry/<a class="el" href="Transform_8h_source.html">Transform.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 10 2025 06:12:32 for Medial Code Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
