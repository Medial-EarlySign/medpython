<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medial Code Documentation: medial::process Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Medial Code Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemedial.html">medial</a></li><li class="navelem"><a class="el" href="namespacemedial_1_1process.html">process</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">medial::process Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>process namespace  
<a href="namespacemedial_1_1process.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab28b8696972d6035acde37b54ce92853" id="r_ab28b8696972d6035acde37b54ce92853"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemedial_1_1process.html#ab28b8696972d6035acde37b54ce92853">split_feature_to_bins</a> (const <a class="el" href="classBinSettings.html">BinSettings</a> &amp;setting, vector&lt; float &gt; &amp;feature, const vector&lt; int &gt; &amp;sel_indexes, vector&lt; float &gt; &amp;y)</td></tr>
<tr class="memdesc:ab28b8696972d6035acde37b54ce92853"><td class="mdescLeft">&#160;</td><td class="mdescRight">splits feature to bin using setting  <br /></td></tr>
<tr class="separator:ab28b8696972d6035acde37b54ce92853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee703f7ae6a7341376b724990d27715" id="r_afee703f7ae6a7341376b724990d27715"><td class="memItemLeft" align="right" valign="top"><a id="afee703f7ae6a7341376b724990d27715" name="afee703f7ae6a7341376b724990d27715"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_feature_to_uniform</b> (const <a class="el" href="classBinSettings.html">BinSettings</a> &amp;setting, vector&lt; float &gt; &amp;feature)</td></tr>
<tr class="memdesc:afee703f7ae6a7341376b724990d27715"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalize feature to be between [0-1] but also change the distribution of values to be uniform <br /></td></tr>
<tr class="separator:afee703f7ae6a7341376b724990d27715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ca4828b7f481327779c782926c0b16" id="r_a96ca4828b7f481327779c782926c0b16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemedial_1_1process.html#a96ca4828b7f481327779c782926c0b16">compare_populations</a> (const <a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;population1, const <a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;population2, const string &amp;name1, const string &amp;name2, const string &amp;output_file, const string &amp;predictor_type=&quot;&quot;, const string &amp;predictor_init=&quot;&quot;, int nfolds=5, int max_learn=0)</td></tr>
<tr class="memdesc:a96ca4828b7f481327779c782926c0b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">compares two matrixes populations.  <br /></td></tr>
<tr class="separator:a96ca4828b7f481327779c782926c0b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47edc48a239b44b3216214338ed2ff18" id="r_a47edc48a239b44b3216214338ed2ff18"><td class="memTemplParams" colspan="2"><a id="a47edc48a239b44b3216214338ed2ff18" name="a47edc48a239b44b3216214338ed2ff18"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a47edc48a239b44b3216214338ed2ff18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>commit_selection</b> (vector&lt; T &gt; &amp;vec, const vector&lt; int &gt; &amp;idx)</td></tr>
<tr class="memdesc:a47edc48a239b44b3216214338ed2ff18"><td class="mdescLeft">&#160;</td><td class="mdescRight">commit selection of indexes on vector <br /></td></tr>
<tr class="separator:a47edc48a239b44b3216214338ed2ff18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd09c7e050038ffc39b1eed932afe55" id="r_a3fd09c7e050038ffc39b1eed932afe55"><td class="memItemLeft" align="right" valign="top"><a id="a3fd09c7e050038ffc39b1eed932afe55" name="a3fd09c7e050038ffc39b1eed932afe55"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>filter_row_indexes</b> (<a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;dataMat, vector&lt; int &gt; &amp;selected_indexes, bool op_flag=false)</td></tr>
<tr class="memdesc:a3fd09c7e050038ffc39b1eed932afe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">filtering <a class="el" href="classMedFeatures.html" title="A class for holding features data as a virtual matrix">MedFeatures</a> by selected indexes rows <br /></td></tr>
<tr class="separator:a3fd09c7e050038ffc39b1eed932afe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30b0de1adfb8fa802f854a3ba37fb3a" id="r_ab30b0de1adfb8fa802f854a3ba37fb3a"><td class="memItemLeft" align="right" valign="top"><a id="ab30b0de1adfb8fa802f854a3ba37fb3a" name="ab30b0de1adfb8fa802f854a3ba37fb3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>filter_row_indexes_safe</b> (<a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;dataMat, const vector&lt; int &gt; &amp;selected_indexes, bool op_flag=false)</td></tr>
<tr class="memdesc:ab30b0de1adfb8fa802f854a3ba37fb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">filtering <a class="el" href="classMedFeatures.html" title="A class for holding features data as a virtual matrix">MedFeatures</a> by selected indexes rows (thread safe for selected_indexes) no sort of selected_indexes <br /></td></tr>
<tr class="separator:ab30b0de1adfb8fa802f854a3ba37fb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7489521743c40b6b1520e77db445cb18" id="r_a7489521743c40b6b1520e77db445cb18"><td class="memItemLeft" align="right" valign="top"><a id="a7489521743c40b6b1520e77db445cb18" name="a7489521743c40b6b1520e77db445cb18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>down_sample</b> (<a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;dataMat, double take_ratio, bool with_repeats=false, vector&lt; int &gt; *selected_indexes=NULL)</td></tr>
<tr class="memdesc:a7489521743c40b6b1520e77db445cb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">down sampling with ratio <br /></td></tr>
<tr class="separator:a7489521743c40b6b1520e77db445cb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cbb242d14958e377644ad1c97dc341" id="r_ae8cbb242d14958e377644ad1c97dc341"><td class="memItemLeft" align="right" valign="top"><a id="ae8cbb242d14958e377644ad1c97dc341" name="ae8cbb242d14958e377644ad1c97dc341"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>reweight_by_general</b> (<a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;data_records, const vector&lt; string &gt; &amp;groups, vector&lt; float &gt; &amp;weigths, bool print_verbose)</td></tr>
<tr class="memdesc:ae8cbb242d14958e377644ad1c97dc341"><td class="mdescLeft">&#160;</td><td class="mdescRight">reweighting method by given groups uniq values. return weights and min_factor <br /></td></tr>
<tr class="separator:ae8cbb242d14958e377644ad1c97dc341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f2c9ee92dda4c19403bf294a2559e3" id="r_a21f2c9ee92dda4c19403bf294a2559e3"><td class="memItemLeft" align="right" valign="top"><a id="a21f2c9ee92dda4c19403bf294a2559e3" name="a21f2c9ee92dda4c19403bf294a2559e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>match_by_general</b> (<a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;data_records, const vector&lt; string &gt; &amp;groups, vector&lt; int &gt; &amp;filtered_row_ids, float price_ratio, int min_grp_size, bool print_verbose)</td></tr>
<tr class="memdesc:a21f2c9ee92dda4c19403bf294a2559e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">matching by given groups uniq values. returns also the row_ids filtered <br /></td></tr>
<tr class="separator:a21f2c9ee92dda4c19403bf294a2559e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0846d99db797d644290f63c2ecbf41" id="r_a2d0846d99db797d644290f63c2ecbf41"><td class="memItemLeft" align="right" valign="top"><a id="a2d0846d99db797d644290f63c2ecbf41" name="a2d0846d99db797d644290f63c2ecbf41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>match_by_general</b> (<a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;data_records, const vector&lt; string &gt; &amp;groups, vector&lt; int &gt; &amp;filtered_row_ids, float price_ratio, float max_ratio, int min_grp_size, bool print_verbose)</td></tr>
<tr class="memdesc:a2d0846d99db797d644290f63c2ecbf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">matching by given groups uniq values. returns also the row_ids filtered. max_ratio is maximal allowed ratio, inf if &lt; 0. <br /></td></tr>
<tr class="separator:a2d0846d99db797d644290f63c2ecbf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c3a29c06944b0a5502f3dd0198b787" id="r_ac0c3a29c06944b0a5502f3dd0198b787"><td class="memItemLeft" align="right" valign="top"><a id="ac0c3a29c06944b0a5502f3dd0198b787" name="ac0c3a29c06944b0a5502f3dd0198b787"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>split_matrix</b> (const <a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;matrix, vector&lt; int &gt; &amp;folds, int iFold, <a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;trainMatrix, <a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;testMatrix, const vector&lt; string &gt; *selected_features=NULL)</td></tr>
<tr class="memdesc:ac0c3a29c06944b0a5502f3dd0198b787"><td class="mdescLeft">&#160;</td><td class="mdescRight">split matrix to train test based on iFold value. folds is fold id for each sample <br /></td></tr>
<tr class="separator:ac0c3a29c06944b0a5502f3dd0198b787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab132825fc4807a8d7c0d7aa7090a1dbb" id="r_ab132825fc4807a8d7c0d7aa7090a1dbb"><td class="memItemLeft" align="right" valign="top"><a id="ab132825fc4807a8d7c0d7aa7090a1dbb" name="ab132825fc4807a8d7c0d7aa7090a1dbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>split_matrix</b> (const <a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;matrix, unordered_map&lt; int, int &gt; &amp;folds, int iFold, <a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;trainMatrix, <a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;testMatrix, const vector&lt; string &gt; *selected_features=NULL)</td></tr>
<tr class="memdesc:ab132825fc4807a8d7c0d7aa7090a1dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">split matrix to train test based on iFold value. folds is map from patient id to fold <br /></td></tr>
<tr class="separator:ab132825fc4807a8d7c0d7aa7090a1dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f70ddf1f79f09e836578683cddfd9c2" id="r_a9f70ddf1f79f09e836578683cddfd9c2"><td class="memItemLeft" align="right" valign="top"><a id="a9f70ddf1f79f09e836578683cddfd9c2" name="a9f70ddf1f79f09e836578683cddfd9c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>convert_prctile</b> (vector&lt; float &gt; &amp;features_prctiles)</td></tr>
<tr class="memdesc:a9f70ddf1f79f09e836578683cddfd9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert feature vector to it's prctil's value in each element <br /></td></tr>
<tr class="separator:a9f70ddf1f79f09e836578683cddfd9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae514b7fd10f7277af01c0236faa387a7" id="r_ae514b7fd10f7277af01c0236faa387a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemedial_1_1process.html#ae514b7fd10f7277af01c0236faa387a7">match_to_prior</a> (const vector&lt; float &gt; &amp;outcome, const vector&lt; float &gt; &amp;group_values, float target_prior, vector&lt; int &gt; &amp;sel_idx)</td></tr>
<tr class="memdesc:ae514b7fd10f7277af01c0236faa387a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">does matching to specific target_prior.  <br /></td></tr>
<tr class="separator:ae514b7fd10f7277af01c0236faa387a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a4c30403a89fc4838ffd2e7ea097d9" id="r_a76a4c30403a89fc4838ffd2e7ea097d9"><td class="memItemLeft" align="right" valign="top"><a id="a76a4c30403a89fc4838ffd2e7ea097d9" name="a76a4c30403a89fc4838ffd2e7ea097d9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>match_to_prior</b> (<a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples, float target_prior, vector&lt; int &gt; &amp;sel_idx)</td></tr>
<tr class="memdesc:a76a4c30403a89fc4838ffd2e7ea097d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">does matching to specific prior for <a class="el" href="classMedSamples.html" title="MedSamples represent a collection of samples per different id   The data is conatined in a vector of ...">MedSamples</a> <br /></td></tr>
<tr class="separator:a76a4c30403a89fc4838ffd2e7ea097d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb7c4ae2dc526aa86e5047b1be2c6f9" id="r_a6bb7c4ae2dc526aa86e5047b1be2c6f9"><td class="memItemLeft" align="right" valign="top"><a id="a6bb7c4ae2dc526aa86e5047b1be2c6f9" name="a6bb7c4ae2dc526aa86e5047b1be2c6f9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>match_to_prior</b> (<a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;features, float target_prior, vector&lt; int &gt; &amp;sel_idx)</td></tr>
<tr class="memdesc:a6bb7c4ae2dc526aa86e5047b1be2c6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">does matching to specific prior for <a class="el" href="classMedFeatures.html" title="A class for holding features data as a virtual matrix">MedFeatures</a> <br /></td></tr>
<tr class="separator:a6bb7c4ae2dc526aa86e5047b1be2c6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f23dbeff8ca7e2b085ecdb22fe88e1" id="r_ad7f23dbeff8ca7e2b085ecdb22fe88e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemedial_1_1process.html#ad7f23dbeff8ca7e2b085ecdb22fe88e1">match_to_prior</a> (<a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;features, const vector&lt; string &gt; &amp;group_values, float target_prior, vector&lt; int &gt; &amp;sel_idx, bool print_verbose=true)</td></tr>
<tr class="memdesc:ad7f23dbeff8ca7e2b085ecdb22fe88e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">does matching to specific target_prior.  <br /></td></tr>
<tr class="separator:ad7f23dbeff8ca7e2b085ecdb22fe88e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696722371418ef97d7cf1e02760f3256" id="r_a696722371418ef97d7cf1e02760f3256"><td class="memItemLeft" align="right" valign="top"><a id="a696722371418ef97d7cf1e02760f3256" name="a696722371418ef97d7cf1e02760f3256"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nSplits</b> (vector&lt; <a class="el" href="classMedSample.html">MedSample</a> &gt; &amp;samples)</td></tr>
<tr class="memdesc:a696722371418ef97d7cf1e02760f3256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of splits, also check mismatches between idSample and internal <a class="el" href="classMedSamples.html" title="MedSamples represent a collection of samples per different id   The data is conatined in a vector of ...">MedSamples</a> and set idSamples.split if missing. <br /></td></tr>
<tr class="separator:a696722371418ef97d7cf1e02760f3256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9f2fd98b6c6d8c4d312c0b654487f1" id="r_a6f9f2fd98b6c6d8c4d312c0b654487f1"><td class="memItemLeft" align="right" valign="top"><a id="a6f9f2fd98b6c6d8c4d312c0b654487f1" name="a6f9f2fd98b6c6d8c4d312c0b654487f1"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>match_multi_class</b> (<a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;data, const vector&lt; string &gt; &amp;groups, vector&lt; int &gt; &amp;filtered_row_ids, vector&lt; float &gt; &amp;price_ratios, int nRand=10000, int verbose=false)</td></tr>
<tr class="memdesc:a6f9f2fd98b6c6d8c4d312c0b654487f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">multi-class matching. <br /></td></tr>
<tr class="separator:a6f9f2fd98b6c6d8c4d312c0b654487f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac385e1e54ccb21b170eb022ffe75ee65" id="r_ac385e1e54ccb21b170eb022ffe75ee65"><td class="memItemLeft" align="right" valign="top"><a id="ac385e1e54ccb21b170eb022ffe75ee65" name="ac385e1e54ccb21b170eb022ffe75ee65"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>match_multi_class</b> (vector&lt; <a class="el" href="classMedSample.html">MedSample</a> &gt; &amp;data, const vector&lt; string &gt; &amp;groups, vector&lt; int &gt; &amp;filtered_row_ids, vector&lt; float &gt; &amp;price_ratios, int nRand=10000, int verbose=false)</td></tr>
<tr class="separator:ac385e1e54ccb21b170eb022ffe75ee65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb61dc1310ccd34b2557242a207815c" id="r_acdb61dc1310ccd34b2557242a207815c"><td class="memItemLeft" align="right" valign="top"><a id="acdb61dc1310ccd34b2557242a207815c" name="acdb61dc1310ccd34b2557242a207815c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>match_multi_class_to_dist</b> (<a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;data, const vector&lt; string &gt; &amp;groups, vector&lt; int &gt; &amp;filtered_row_ids, vector&lt; float &gt; probs)</td></tr>
<tr class="separator:acdb61dc1310ccd34b2557242a207815c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b59da3953e6d3451e2fce3b9daa32b" id="r_a52b59da3953e6d3451e2fce3b9daa32b"><td class="memItemLeft" align="right" valign="top"><a id="a52b59da3953e6d3451e2fce3b9daa32b" name="a52b59da3953e6d3451e2fce3b9daa32b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>match_multi_class_to_dist</b> (vector&lt; <a class="el" href="classMedSample.html">MedSample</a> &gt; &amp;data, const vector&lt; string &gt; &amp;groups, vector&lt; int &gt; &amp;filtered_row_ids, vector&lt; float &gt; probs)</td></tr>
<tr class="separator:a52b59da3953e6d3451e2fce3b9daa32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8ae055210a8bb64fbeff9711e7da7b" id="r_aae8ae055210a8bb64fbeff9711e7da7b"><td class="memItemLeft" align="right" valign="top"><a id="aae8ae055210a8bb64fbeff9711e7da7b" name="aae8ae055210a8bb64fbeff9711e7da7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>down_sample</b> (<a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples, double take_ratio, bool with_repeats=false)</td></tr>
<tr class="memdesc:aae8ae055210a8bb64fbeff9711e7da7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">down sammling <br /></td></tr>
<tr class="separator:aae8ae055210a8bb64fbeff9711e7da7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaba7f9788a4eab7386da21eff2983f9" id="r_aeaba7f9788a4eab7386da21eff2983f9"><td class="memItemLeft" align="right" valign="top"><a id="aeaba7f9788a4eab7386da21eff2983f9" name="aeaba7f9788a4eab7386da21eff2983f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>down_sample_by_pid</b> (<a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples, double take_ratio, bool with_repeats=false)</td></tr>
<tr class="memdesc:aeaba7f9788a4eab7386da21eff2983f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">down sample by selecting from pids <br /></td></tr>
<tr class="separator:aeaba7f9788a4eab7386da21eff2983f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9203c3c1a8c744e23cb21406da033d06" id="r_a9203c3c1a8c744e23cb21406da033d06"><td class="memItemLeft" align="right" valign="top"><a id="a9203c3c1a8c744e23cb21406da033d06" name="a9203c3c1a8c744e23cb21406da033d06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>down_sample</b> (<a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples, int no_more_than, bool with_repeats=false)</td></tr>
<tr class="memdesc:a9203c3c1a8c744e23cb21406da033d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">down sammling <br /></td></tr>
<tr class="separator:a9203c3c1a8c744e23cb21406da033d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8da653cb393525872ab46298cbd4f2" id="r_aaf8da653cb393525872ab46298cbd4f2"><td class="memItemLeft" align="right" valign="top"><a id="aaf8da653cb393525872ab46298cbd4f2" name="aaf8da653cb393525872ab46298cbd4f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>down_sample_by_pid</b> (<a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples, int no_more_than, bool with_repeats=false)</td></tr>
<tr class="memdesc:aaf8da653cb393525872ab46298cbd4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">down sample by selecting from pids <br /></td></tr>
<tr class="separator:aaf8da653cb393525872ab46298cbd4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793e8a00d2dee7d1bfc2b2ece2968740" id="r_a793e8a00d2dee7d1bfc2b2ece2968740"><td class="memTemplParams" colspan="2"><a id="a793e8a00d2dee7d1bfc2b2ece2968740" name="a793e8a00d2dee7d1bfc2b2ece2968740"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a793e8a00d2dee7d1bfc2b2ece2968740"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prctils</b> (const vector&lt; T &gt; &amp;x, const vector&lt; double &gt; &amp;prc, vector&lt; T &gt; &amp;res, const vector&lt; float &gt; *weights=NULL)</td></tr>
<tr class="memdesc:a793e8a00d2dee7d1bfc2b2ece2968740"><td class="mdescLeft">&#160;</td><td class="mdescRight">calc prctile <br /></td></tr>
<tr class="separator:a793e8a00d2dee7d1bfc2b2ece2968740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af5294791a988f799b671ea085b52fa" id="r_a7af5294791a988f799b671ea085b52fa"><td class="memTemplParams" colspan="2"><a id="a7af5294791a988f799b671ea085b52fa" name="a7af5294791a988f799b671ea085b52fa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7af5294791a988f799b671ea085b52fa"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binary_search_index</b> (const T *begin, const T *end, T val)</td></tr>
<tr class="memdesc:a7af5294791a988f799b671ea085b52fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary search for index. -1 if not found <br /></td></tr>
<tr class="separator:a7af5294791a988f799b671ea085b52fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761e2a390f505fbf96c32e1fa54f9140" id="r_a761e2a390f505fbf96c32e1fa54f9140"><td class="memTemplParams" colspan="2"><a id="a761e2a390f505fbf96c32e1fa54f9140" name="a761e2a390f505fbf96c32e1fa54f9140"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a761e2a390f505fbf96c32e1fa54f9140"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binary_search_position</b> (const T *begin, const T *end, T val, bool reversed=false)</td></tr>
<tr class="memdesc:a761e2a390f505fbf96c32e1fa54f9140"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary search for position to add new element in sorted manner (first position if equal elements found). <br /></td></tr>
<tr class="separator:a761e2a390f505fbf96c32e1fa54f9140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a30af351d23f3e8e55ac73003b9fee" id="r_aa7a30af351d23f3e8e55ac73003b9fee"><td class="memTemplParams" colspan="2"><a id="aa7a30af351d23f3e8e55ac73003b9fee" name="aa7a30af351d23f3e8e55ac73003b9fee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7a30af351d23f3e8e55ac73003b9fee"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binary_search_position_last</b> (const T *begin, const T *end, T val, bool reversed=false)</td></tr>
<tr class="memdesc:aa7a30af351d23f3e8e55ac73003b9fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary search for position to add new element in sorted manner (last position if equal elements found). <br /></td></tr>
<tr class="separator:aa7a30af351d23f3e8e55ac73003b9fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3681d4a998c5e47ff8cb4ce7f7ca5b1f" id="r_a3681d4a998c5e47ff8cb4ce7f7ca5b1f"><td class="memTemplParams" colspan="2"><a id="a3681d4a998c5e47ff8cb4ce7f7ca5b1f" name="a3681d4a998c5e47ff8cb4ce7f7ca5b1f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3681d4a998c5e47ff8cb4ce7f7ca5b1f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binary_search_position</b> (const vector&lt; T &gt; &amp;v, T search)</td></tr>
<tr class="memdesc:a3681d4a998c5e47ff8cb4ce7f7ca5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary search for position to add new element in sorted manner (first position if equal elements found). <br /></td></tr>
<tr class="separator:a3681d4a998c5e47ff8cb4ce7f7ca5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1ccb53bf060cd7bc34b724b2ecf6a3" id="r_a0d1ccb53bf060cd7bc34b724b2ecf6a3"><td class="memTemplParams" colspan="2"><a id="a0d1ccb53bf060cd7bc34b724b2ecf6a3" name="a0d1ccb53bf060cd7bc34b724b2ecf6a3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0d1ccb53bf060cd7bc34b724b2ecf6a3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binary_search_position</b> (const vector&lt; T &gt; &amp;v, T search, int start, int end)</td></tr>
<tr class="memdesc:a0d1ccb53bf060cd7bc34b724b2ecf6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary search for position to add new element in sorted manner (first position if equal elements found). <br /></td></tr>
<tr class="separator:a0d1ccb53bf060cd7bc34b724b2ecf6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>process namespace </p>
<p>process </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a96ca4828b7f481327779c782926c0b16" name="a96ca4828b7f481327779c782926c0b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ca4828b7f481327779c782926c0b16">&#9670;&#160;</a></span>compare_populations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void medial::process::compare_populations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;&#160;</td>
          <td class="paramname"><em>population1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;&#160;</td>
          <td class="paramname"><em>population2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>output_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>predictor_type</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>predictor_init</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfolds</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_learn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compares two matrixes populations. </p>
<p>it's also try to seperate between populations using the predictor parameters if given </p>

</div>
</div>
<a id="ae514b7fd10f7277af01c0236faa387a7" name="ae514b7fd10f7277af01c0236faa387a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae514b7fd10f7277af01c0236faa387a7">&#9670;&#160;</a></span>match_to_prior() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void medial::process::match_to_prior </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>outcome</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>group_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sel_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does matching to specific target_prior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outcome</td><td>is the outcome vector for measure prior in each group </td></tr>
    <tr><td class="paramname">group_values</td><td>is the groups to split the matching to. it can be year signature or age or unique combination of both </td></tr>
    <tr><td class="paramname">target_prior</td><td>the target prior </td></tr>
    <tr><td class="paramname">the</td><td>return value of selected indexes to do the matching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7f23dbeff8ca7e2b085ecdb22fe88e1" name="ad7f23dbeff8ca7e2b085ecdb22fe88e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f23dbeff8ca7e2b085ecdb22fe88e1">&#9670;&#160;</a></span>match_to_prior() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void medial::process::match_to_prior </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMedFeatures.html">MedFeatures</a> &amp;&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>group_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sel_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_verbose</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does matching to specific target_prior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">features</td><td>the matrix to match. will use outcome in samples </td></tr>
    <tr><td class="paramname">group_values</td><td>is the groups to split the matching to. it can be year signature or age or unique combination of both </td></tr>
    <tr><td class="paramname">target_prior</td><td>the target prior </td></tr>
    <tr><td class="paramname">sel_idx</td><td>the original indecies <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab28b8696972d6035acde37b54ce92853" name="ab28b8696972d6035acde37b54ce92853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28b8696972d6035acde37b54ce92853">&#9670;&#160;</a></span>split_feature_to_bins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void medial::process::split_feature_to_bins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBinSettings.html">BinSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>setting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sel_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>splits feature to bin using setting </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setting</td><td>the settings of split </td></tr>
    <tr><td class="paramname">feature</td><td>the feature vector values </td></tr>
    <tr><td class="paramname">sel_indexes</td><td>the indexes to take from feature. if empty will take all feature vector </td></tr>
    <tr><td class="paramname">y</td><td>labels if we have. some binning methods uses the labels for better split</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>it updates feature to the binned values </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 10 2025 11:46:21 for Medial Code Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
