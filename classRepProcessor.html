<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medial Code Documentation: RepProcessor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Medial Code Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">RepProcessor Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for RepProcessor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRepProcessor.png" usemap="#RepProcessor_map" alt=""/>
  <map id="RepProcessor_map" name="RepProcessor_map">
<area href="classSerializableObject.html" alt="SerializableObject" shape="rect" coords="0,0,177,24"/>
<area href="classRepAggregateSignal.html" title="An Aggregator for signal in sliding time window." alt="RepAggregateSignal" shape="rect" coords="187,112,364,136"/>
<area href="classRepAggregationPeriod.html" title="creates a signal of time ranges in which the input signal (usually medication) was active ranges are ..." alt="RepAggregationPeriod" shape="rect" coords="187,168,364,192"/>
<area href="classRepBasicOutlierCleaner.html" title="A simple cleaner considering each value of a certain signal separatley." alt="RepBasicOutlierCleaner" shape="rect" coords="187,224,364,248"/>
<area href="classRepBasicRangeCleaner.html" alt="RepBasicRangeCleaner" shape="rect" coords="187,280,364,304"/>
<area href="classRepCalcSimpleSignals.html" title="A simple class for calculating virtual signals." alt="RepCalcSimpleSignals" shape="rect" coords="187,336,364,360"/>
<area href="classRepCategoryDescenders.html" title="RepCategoryDescenders - creates all descenders values for each values in the original signal value." alt="RepCategoryDescenders" shape="rect" coords="187,392,364,416"/>
<area href="classRepCheckReq.html" title="RepCheckReq does not actually process the repository but rather check each sample for compliance with..." alt="RepCheckReq" shape="rect" coords="187,448,364,472"/>
<area href="classRepClearSignalByDiag.html" title="Filter signal by diag removing signals from dates were existing diag (other, not relevant to outcome)..." alt="RepClearSignalByDiag" shape="rect" coords="187,504,364,528"/>
<area href="classRepCombineSignals.html" title="RepCreateReigsty creates registries (e.g." alt="RepCombineSignals" shape="rect" coords="187,560,364,584"/>
<area href="classRepCreateBitSignal.html" alt="RepCreateBitSignal" shape="rect" coords="187,616,364,640"/>
<area href="classRepCreateRegistry.html" alt="RepCreateRegistry" shape="rect" coords="187,672,364,696"/>
<area href="classRepFilterByChannel.html" title="Filter signal by different set of values in channels." alt="RepFilterByChannel" shape="rect" coords="187,728,364,752"/>
<area href="classRepHistoryLimit.html" alt="RepHistoryLimit" shape="rect" coords="187,784,364,808"/>
<area href="classRepMultiProcessor.html" title="RepMultiProcessor is a repository processor which contains a vector of simpler processors that can be..." alt="RepMultiProcessor" shape="rect" coords="187,840,364,864"/>
<area href="classRepNbrsOutlierCleaner.html" title="RepNbrsOutlierCleaner is cleaner that looks at the neighbourhood of a certain signal value." alt="RepNbrsOutlierCleaner" shape="rect" coords="187,896,364,920"/>
<area href="classRepNumericNoiser.html" alt="RepNumericNoiser" shape="rect" coords="187,952,364,976"/>
<area href="classRepPanelCompleter.html" title="A Repository panel completer for a complete panel of signals that are dependent and given on same tim..." alt="RepPanelCompleter" shape="rect" coords="187,1008,364,1032"/>
<area href="classRepReoderChannels.html" alt="RepReoderChannels" shape="rect" coords="187,1064,364,1088"/>
<area href="classRepRuleBasedOutlierCleaner.html" title="A cleaner that is based on rules that describe relations of signal values to each other." alt="RepRuleBasedOutlierCleaner" shape="rect" coords="187,1120,364,1144"/>
<area href="classRepSignalRate.html" title="Normalize Signal Values by time - divide by time to calculate rate." alt="RepSignalRate" shape="rect" coords="187,1176,364,1200"/>
<area href="classRepSimValHandler.html" alt="RepSimValHandler" shape="rect" coords="187,1232,364,1256"/>
<area href="classRepSplitSignal.html" title="split signal based on set of values." alt="RepSplitSignal" shape="rect" coords="187,1288,364,1312"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad1689b6c89b2224a9f6d530030a862f0" id="r_ad1689b6c89b2224a9f6d530030a862f0"><td class="memItemLeft" align="right" valign="top"><a id="ad1689b6c89b2224a9f6d530030a862f0" name="ad1689b6c89b2224a9f6d530030a862f0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:ad1689b6c89b2224a9f6d530030a862f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1c77457bf1afe5b10cef12f83499a3" id="r_a8b1c77457bf1afe5b10cef12f83499a3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a8b1c77457bf1afe5b10cef12f83499a3">init</a> (void *params)</td></tr>
<tr class="memdesc:a8b1c77457bf1afe5b10cef12f83499a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize from a params object : Should be implemented for inheriting classes that have parameters  <br /></td></tr>
<tr class="separator:a8b1c77457bf1afe5b10cef12f83499a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad266f41bd5a6e5a9bd8c632b8be97f86" id="r_ad266f41bd5a6e5a9bd8c632b8be97f86"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#ad266f41bd5a6e5a9bd8c632b8be97f86">init</a> (map&lt; string, string &gt; &amp;mapper)</td></tr>
<tr class="memdesc:ad266f41bd5a6e5a9bd8c632b8be97f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize from a map : Should be implemented for inheriting classes that have parameters  <br /></td></tr>
<tr class="separator:ad266f41bd5a6e5a9bd8c632b8be97f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339d1587dd21ff9789a427cd348ed5f7" id="r_a339d1587dd21ff9789a427cd348ed5f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a339d1587dd21ff9789a427cd348ed5f7">init_defaults</a> ()</td></tr>
<tr class="memdesc:a339d1587dd21ff9789a427cd348ed5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize to default values : Should be implemented for inheriting classes that have parameters  <br /></td></tr>
<tr class="separator:a339d1587dd21ff9789a427cd348ed5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54096b50830f1163e2a115640af04fd5" id="r_a54096b50830f1163e2a115640af04fd5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a54096b50830f1163e2a115640af04fd5">set_signal</a> (const string &amp;_signalName)</td></tr>
<tr class="memdesc:a54096b50830f1163e2a115640af04fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">set signal-name : Should be implemented for inheriting classes that have signalName  <br /></td></tr>
<tr class="separator:a54096b50830f1163e2a115640af04fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8fb090f4e52c3fe03e57c4029dd984" id="r_a7c8fb090f4e52c3fe03e57c4029dd984"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a7c8fb090f4e52c3fe03e57c4029dd984">set_signal_ids</a> (<a class="el" href="classMedSignals.html">MedSignals</a> &amp;sigs)</td></tr>
<tr class="memdesc:a7c8fb090f4e52c3fe03e57c4029dd984"><td class="mdescLeft">&#160;</td><td class="mdescRight">set signal-ids : Should be implemented for inheriting classes that have signalId  <br /></td></tr>
<tr class="separator:a7c8fb090f4e52c3fe03e57c4029dd984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebb3919cad4f925d25f6c9fe4ea67a0" id="r_a1ebb3919cad4f925d25f6c9fe4ea67a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a1ebb3919cad4f925d25f6c9fe4ea67a0">get_required_signal_names</a> (unordered_set&lt; string &gt; &amp;signalNames)</td></tr>
<tr class="memdesc:a1ebb3919cad4f925d25f6c9fe4ea67a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append required signal names to set : parent function just uses req_signals.  <br /></td></tr>
<tr class="separator:a1ebb3919cad4f925d25f6c9fe4ea67a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854f927b866730036cbbd782ee8bda2d" id="r_a854f927b866730036cbbd782ee8bda2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a854f927b866730036cbbd782ee8bda2d">get_required_signal_names</a> (unordered_set&lt; string &gt; &amp;signalNames, unordered_set&lt; string &gt; preReqSignals)</td></tr>
<tr class="memdesc:a854f927b866730036cbbd782ee8bda2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append required signal names to set only if processor is actually required to produce any of preReqSignals : parent function just uses req_signals.  <br /></td></tr>
<tr class="separator:a854f927b866730036cbbd782ee8bda2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79aebdeb6669f434a769ce8290d1b1f4" id="r_a79aebdeb6669f434a769ce8290d1b1f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a79aebdeb6669f434a769ce8290d1b1f4">set_required_signal_ids</a> (<a class="el" href="classMedDictionarySections.html">MedDictionarySections</a> &amp;dict)</td></tr>
<tr class="memdesc:a79aebdeb6669f434a769ce8290d1b1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill req_signal_ids : parent function just fills from req_signals.  <br /></td></tr>
<tr class="separator:a79aebdeb6669f434a769ce8290d1b1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5935a833d52f4bd98ea460dd0810fad" id="r_ad5935a833d52f4bd98ea460dd0810fad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#ad5935a833d52f4bd98ea460dd0810fad">add_virtual_signals</a> (map&lt; string, int &gt; &amp;_virtual_signals, map&lt; string, string &gt; &amp;_virtual_signals_generic) const</td></tr>
<tr class="memdesc:ad5935a833d52f4bd98ea460dd0810fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">rep processors CREATING virtual signals need to implement this: adding their signals to the pile  <br /></td></tr>
<tr class="separator:ad5935a833d52f4bd98ea460dd0810fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14083adda53a5f82f488b18d8619d4a" id="r_ad14083adda53a5f82f488b18d8619d4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#ad14083adda53a5f82f488b18d8619d4a">get_required_signal_ids</a> (unordered_set&lt; int &gt; &amp;signalIds)</td></tr>
<tr class="memdesc:ad14083adda53a5f82f488b18d8619d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append required signal names to set : parent function just uses req_signals.  <br /></td></tr>
<tr class="separator:ad14083adda53a5f82f488b18d8619d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142e21a5ff147dab5d2f7f181403fc6f" id="r_a142e21a5ff147dab5d2f7f181403fc6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a142e21a5ff147dab5d2f7f181403fc6f">get_required_signal_ids</a> (unordered_set&lt; int &gt; &amp;signalIds, unordered_set&lt; int &gt; preReqSignals)</td></tr>
<tr class="memdesc:a142e21a5ff147dab5d2f7f181403fc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append required signal names to set only if processor is actually required to produce any of preReqSignals : parent function just uses req_signals.  <br /></td></tr>
<tr class="separator:a142e21a5ff147dab5d2f7f181403fc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c6df24c0b6c111e9edf8c971fe1e2e" id="r_a28c6df24c0b6c111e9edf8c971fe1e2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a28c6df24c0b6c111e9edf8c971fe1e2e">set_affected_signal_ids</a> (<a class="el" href="classMedDictionarySections.html">MedDictionarySections</a> &amp;dict)</td></tr>
<tr class="memdesc:a28c6df24c0b6c111e9edf8c971fe1e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill aff_signal_ids : parent function just fills from aff_signals.  <br /></td></tr>
<tr class="separator:a28c6df24c0b6c111e9edf8c971fe1e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f841ac6441b8ad1308d0406ead270d5" id="r_a9f841ac6441b8ad1308d0406ead270d5"><td class="memItemLeft" align="right" valign="top"><a id="a9f841ac6441b8ad1308d0406ead270d5" name="a9f841ac6441b8ad1308d0406ead270d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_signal_affected</b> (int signalId)</td></tr>
<tr class="memdesc:a9f841ac6441b8ad1308d0406ead270d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a signal is affected by processor &lt;/summray&gt; </p><dl class="section return"><dt>Returns</dt><dd>true if affected, false if not </dd></dl>
<br /></td></tr>
<tr class="separator:a9f841ac6441b8ad1308d0406ead270d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cd6a670246c6a39899b6e30461c85c" id="r_a06cd6a670246c6a39899b6e30461c85c"><td class="memItemLeft" align="right" valign="top"><a id="a06cd6a670246c6a39899b6e30461c85c" name="a06cd6a670246c6a39899b6e30461c85c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_signal_affected</b> (string &amp;signalName)</td></tr>
<tr class="separator:a06cd6a670246c6a39899b6e30461c85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43105179b01b461eaf0bbd28b66cb013" id="r_a43105179b01b461eaf0bbd28b66cb013"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a43105179b01b461eaf0bbd28b66cb013">fit_for_repository</a> (<a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;rep)</td></tr>
<tr class="memdesc:a43105179b01b461eaf0bbd28b66cb013"><td class="mdescLeft">&#160;</td><td class="mdescRight">make changes to <a class="el" href="classRepProcessor.html">RepProcessor</a> according to available signals in Repository  <br /></td></tr>
<tr class="separator:a43105179b01b461eaf0bbd28b66cb013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7ee88d8b5e73adbacb80451c981895" id="r_a5c7ee88d8b5e73adbacb80451c981895"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a5c7ee88d8b5e73adbacb80451c981895">register_virtual_section_name_id</a> (<a class="el" href="classMedDictionarySections.html">MedDictionarySections</a> &amp;dict)</td></tr>
<tr class="memdesc:a5c7ee88d8b5e73adbacb80451c981895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register section id to section name of new virtual signals.  <br /></td></tr>
<tr class="separator:a5c7ee88d8b5e73adbacb80451c981895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc98db12a0701abbec238a7c43c0e2a8" id="r_abc98db12a0701abbec238a7c43c0e2a8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#abc98db12a0701abbec238a7c43c0e2a8">filter</a> (unordered_set&lt; string &gt; &amp;reqSignals)</td></tr>
<tr class="memdesc:abc98db12a0701abbec238a7c43c0e2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if processor (and 'sub'-processors within) should be applied according to set of required signals &lt;/summray&gt; </p><dl class="section return"><dt>Returns</dt><dd>true if processor is not required and can be filtered, false otherwise </dd></dl>
 <br /></td></tr>
<tr class="separator:abc98db12a0701abbec238a7c43c0e2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5f40f8dad32df49ea74d03dab4b004" id="r_add5f40f8dad32df49ea74d03dab4b004"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#add5f40f8dad32df49ea74d03dab4b004">init_tables</a> (<a class="el" href="classMedDictionarySections.html">MedDictionarySections</a> &amp;dict, <a class="el" href="classMedSignals.html">MedSignals</a> &amp;sigs)</td></tr>
<tr class="memdesc:add5f40f8dad32df49ea74d03dab4b004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init required tables : Should be implemented for inheriting classes that have such tables.  <br /></td></tr>
<tr class="separator:add5f40f8dad32df49ea74d03dab4b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9033c56b84ed6e1d4724bc2a06d3cf4c" id="r_a9033c56b84ed6e1d4724bc2a06d3cf4c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a9033c56b84ed6e1d4724bc2a06d3cf4c">init_attributes</a> ()</td></tr>
<tr class="memdesc:a9033c56b84ed6e1d4724bc2a06d3cf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init attributes information : Should be implemented for inheriting classes that have attributes.  <br /></td></tr>
<tr class="separator:a9033c56b84ed6e1d4724bc2a06d3cf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21e4a49dcded29690911e9533f6a13" id="r_aae21e4a49dcded29690911e9533f6a13"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#aae21e4a49dcded29690911e9533f6a13">_learn</a> (<a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;rep, <a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples, vector&lt; <a class="el" href="classRepProcessor.html">RepProcessor</a> * &gt; &amp;prev_processors)</td></tr>
<tr class="memdesc:aae21e4a49dcded29690911e9533f6a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">learn processing model on a subset of samples. Apply set of preceeding processors on DynamicPidRec before learning :  <br /></td></tr>
<tr class="separator:aae21e4a49dcded29690911e9533f6a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb47eb142a0ed05219397eccfa672562" id="r_afb47eb142a0ed05219397eccfa672562"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#afb47eb142a0ed05219397eccfa672562">_conditional_learn</a> (<a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;rep, <a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples, vector&lt; <a class="el" href="classRepProcessor.html">RepProcessor</a> * &gt; &amp;prev_processors, unordered_set&lt; int &gt; &amp;neededSignalIds)</td></tr>
<tr class="memdesc:afb47eb142a0ed05219397eccfa672562"><td class="mdescLeft">&#160;</td><td class="mdescRight">learn processing model on a subset of samples only if required. Apply set of preceeding processors on DynamicPidRec before learning :  <br /></td></tr>
<tr class="separator:afb47eb142a0ed05219397eccfa672562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2a9da3f3e4b9dcd8f76236f5455bf9" id="r_aaa2a9da3f3e4b9dcd8f76236f5455bf9"><td class="memItemLeft" align="right" valign="top"><a id="aaa2a9da3f3e4b9dcd8f76236f5455bf9" name="aaa2a9da3f3e4b9dcd8f76236f5455bf9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>learn</b> (<a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;rep, <a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples, vector&lt; <a class="el" href="classRepProcessor.html">RepProcessor</a> * &gt; &amp;prev_processors)</td></tr>
<tr class="memdesc:aaa2a9da3f3e4b9dcd8f76236f5455bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">learn processing model on a subset of ids. Apply set of preceeding processors on DynamicPidRec before learning <br /></td></tr>
<tr class="separator:aaa2a9da3f3e4b9dcd8f76236f5455bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01d3864780e8ae47ca929e0137d71e0" id="r_ae01d3864780e8ae47ca929e0137d71e0"><td class="memItemLeft" align="right" valign="top"><a id="ae01d3864780e8ae47ca929e0137d71e0" name="ae01d3864780e8ae47ca929e0137d71e0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>learn</b> (<a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;rep)</td></tr>
<tr class="memdesc:ae01d3864780e8ae47ca929e0137d71e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">learn on all pids in repository, using fake samples - works only for repProcessors that ignore sample dates <br /></td></tr>
<tr class="separator:ae01d3864780e8ae47ca929e0137d71e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af465ec484abbcb17c9d64b2bffe378d1" id="r_af465ec484abbcb17c9d64b2bffe378d1"><td class="memItemLeft" align="right" valign="top"><a id="af465ec484abbcb17c9d64b2bffe378d1" name="af465ec484abbcb17c9d64b2bffe378d1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>learn</b> (<a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;rep, <a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples)</td></tr>
<tr class="memdesc:af465ec484abbcb17c9d64b2bffe378d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">learn on subset of samples without preceesing processors <br /></td></tr>
<tr class="separator:af465ec484abbcb17c9d64b2bffe378d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad203043e36d0f99080ecd632a3102b8b" id="r_ad203043e36d0f99080ecd632a3102b8b"><td class="memItemLeft" align="right" valign="top"><a id="ad203043e36d0f99080ecd632a3102b8b" name="ad203043e36d0f99080ecd632a3102b8b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>conditional_learn</b> (<a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;rep, <a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples, vector&lt; <a class="el" href="classRepProcessor.html">RepProcessor</a> * &gt; &amp;prev_processors, unordered_set&lt; int &gt; &amp;neededSignalIds)</td></tr>
<tr class="memdesc:ad203043e36d0f99080ecd632a3102b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">learn processing model on a subset of samples only if required. Apply set of preceeding processors on DynamicPidRec before learning : <br /></td></tr>
<tr class="separator:ad203043e36d0f99080ecd632a3102b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555db84486bbd4a6c0b5814487ce7820" id="r_a555db84486bbd4a6c0b5814487ce7820"><td class="memItemLeft" align="right" valign="top"><a id="a555db84486bbd4a6c0b5814487ce7820" name="a555db84486bbd4a6c0b5814487ce7820"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>conditional_learn</b> (<a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;rep, <a class="el" href="classMedSamples.html">MedSamples</a> &amp;samples, unordered_set&lt; int &gt; &amp;neededSignalIds)</td></tr>
<tr class="memdesc:a555db84486bbd4a6c0b5814487ce7820"><td class="mdescLeft">&#160;</td><td class="mdescRight">learn processing model on a subset of ids only if required without preceesing processors <br /></td></tr>
<tr class="separator:a555db84486bbd4a6c0b5814487ce7820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8218a39e4bff0b694ad38182339335" id="r_a2f8218a39e4bff0b694ad38182339335"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a2f8218a39e4bff0b694ad38182339335">_apply</a> (<a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> &amp;rec, vector&lt; int &gt; &amp;time_points, vector&lt; vector&lt; float &gt; &gt; &amp;attributes_vals)</td></tr>
<tr class="memdesc:a2f8218a39e4bff0b694ad38182339335"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply processing on a single <a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> at a set of time-points : Should be implemented for all inheriting classes.  <br /></td></tr>
<tr class="separator:a2f8218a39e4bff0b694ad38182339335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85279a2a854d046bcc81d62439e7f29f" id="r_a85279a2a854d046bcc81d62439e7f29f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a85279a2a854d046bcc81d62439e7f29f">_conditional_apply</a> (<a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> &amp;rec, vector&lt; int &gt; &amp;time_points, unordered_set&lt; int &gt; &amp;neededSignalIds, vector&lt; vector&lt; float &gt; &gt; &amp;attributes_vals)</td></tr>
<tr class="memdesc:a85279a2a854d046bcc81d62439e7f29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply processing on a single <a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> at a set of time-points only if required : May be implemented for inheriting classes  <br /></td></tr>
<tr class="separator:a85279a2a854d046bcc81d62439e7f29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dcc8961819f76cacd348d568885ec8" id="r_ab8dcc8961819f76cacd348d568885ec8"><td class="memItemLeft" align="right" valign="top"><a id="ab8dcc8961819f76cacd348d568885ec8" name="ab8dcc8961819f76cacd348d568885ec8"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>_apply_simple</b> (<a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> &amp;rec, vector&lt; int &gt; &amp;time_points)</td></tr>
<tr class="separator:ab8dcc8961819f76cacd348d568885ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ecd35ba8f0406c241e59f91c788030" id="r_a88ecd35ba8f0406c241e59f91c788030"><td class="memItemLeft" align="right" valign="top"><a id="a88ecd35ba8f0406c241e59f91c788030" name="a88ecd35ba8f0406c241e59f91c788030"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>apply</b> (<a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> &amp;rec, vector&lt; int &gt; &amp;time_points, vector&lt; vector&lt; float &gt; &gt; &amp;attributes_vals)</td></tr>
<tr class="memdesc:a88ecd35ba8f0406c241e59f91c788030"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply processing on a single <a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> at a set of time-points <br /></td></tr>
<tr class="separator:a88ecd35ba8f0406c241e59f91c788030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171978f58458caf020e2b765352779bc" id="r_a171978f58458caf020e2b765352779bc"><td class="memItemLeft" align="right" valign="top"><a id="a171978f58458caf020e2b765352779bc" name="a171978f58458caf020e2b765352779bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>conditional_apply</b> (<a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> &amp;rec, vector&lt; int &gt; &amp;time_points, unordered_set&lt; int &gt; &amp;neededSignalIds, vector&lt; vector&lt; float &gt; &gt; &amp;attributes_vals)</td></tr>
<tr class="memdesc:a171978f58458caf020e2b765352779bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply processing on a single <a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> at a set of time-points only if required : if any of the signals in neededSignalIds is actually affected by processor <br /></td></tr>
<tr class="separator:a171978f58458caf020e2b765352779bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111c4dba371c240c679b055f31f57bf2" id="r_a111c4dba371c240c679b055f31f57bf2"><td class="memItemLeft" align="right" valign="top"><a id="a111c4dba371c240c679b055f31f57bf2" name="a111c4dba371c240c679b055f31f57bf2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>apply</b> (<a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> &amp;rec, <a class="el" href="classMedIdSamples.html">MedIdSamples</a> &amp;samples)</td></tr>
<tr class="memdesc:a111c4dba371c240c679b055f31f57bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply processing on a single <a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> at a set of time-points given by samples <br /></td></tr>
<tr class="separator:a111c4dba371c240c679b055f31f57bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216ffb1824eb9c99bffff4e51c4cc7cd" id="r_a216ffb1824eb9c99bffff4e51c4cc7cd"><td class="memItemLeft" align="right" valign="top"><a id="a216ffb1824eb9c99bffff4e51c4cc7cd" name="a216ffb1824eb9c99bffff4e51c4cc7cd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>conditional_apply</b> (<a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> &amp;rec, <a class="el" href="classMedIdSamples.html">MedIdSamples</a> &amp;samples, unordered_set&lt; int &gt; &amp;neededSignalIds)</td></tr>
<tr class="memdesc:a216ffb1824eb9c99bffff4e51c4cc7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply processing on a single <a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> at a set of time-points given by samples only if required <br /></td></tr>
<tr class="separator:a216ffb1824eb9c99bffff4e51c4cc7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7a0ce481ca0664a28f1e9f4ad2c9f7" id="r_a9f7a0ce481ca0664a28f1e9f4ad2c9f7"><td class="memItemLeft" align="right" valign="top"><a id="a9f7a0ce481ca0664a28f1e9f4ad2c9f7" name="a9f7a0ce481ca0664a28f1e9f4ad2c9f7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>conditional_apply_without_attributes</b> (<a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> &amp;rec, const <a class="el" href="classMedIdSamples.html">MedIdSamples</a> &amp;samples, unordered_set&lt; int &gt; &amp;neededSignalIds)</td></tr>
<tr class="memdesc:a9f7a0ce481ca0664a28f1e9f4ad2c9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply processing on a single <a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> at a set of time-points given by samples only if required, not affecting attributes <br /></td></tr>
<tr class="separator:a9f7a0ce481ca0664a28f1e9f4ad2c9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2a308033023605ab668bcad5e15d16" id="r_a2f2a308033023605ab668bcad5e15d16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a2f2a308033023605ab668bcad5e15d16">dprint</a> (const string &amp;pref, int rp_flag)</td></tr>
<tr class="memdesc:a2f2a308033023605ab668bcad5e15d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for debug prints, each inheriting class can overload this one to get a more precise debug print.  <br /></td></tr>
<tr class="separator:a2f2a308033023605ab668bcad5e15d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8597e1f64a1dc957d223809e58070c" id="r_aea8597e1f64a1dc957d223809e58070c"><td class="memItemLeft" align="right" valign="top"><a id="aea8597e1f64a1dc957d223809e58070c" name="aea8597e1f64a1dc957d223809e58070c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>make_summary</b> ()</td></tr>
<tr class="separator:aea8597e1f64a1dc957d223809e58070c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfcb3841f19afc26ff40c02963b78d4" id="r_a8bfcb3841f19afc26ff40c02963b78d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a8bfcb3841f19afc26ff40c02963b78d4">get_required_signal_categories</a> (unordered_map&lt; string, vector&lt; string &gt; &gt; &amp;signal_categories_in_use) const</td></tr>
<tr class="memdesc:a8bfcb3841f19afc26ff40c02963b78d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns for each used signal it's used categories  <br /></td></tr>
<tr class="separator:a8bfcb3841f19afc26ff40c02963b78d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f55110955ae305fd3daf2f0bcbee77d" id="r_a4f55110955ae305fd3daf2f0bcbee77d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a4f55110955ae305fd3daf2f0bcbee77d">new_polymorphic</a> (string derived_class_name)</td></tr>
<tr class="memdesc:a4f55110955ae305fd3daf2f0bcbee77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">for polymorphic classes that want to be able to serialize/deserialize a pointer * to the derived class given its type one needs to implement this function to return a new to the derived class given its type (as in my_type)  <br /></td></tr>
<tr class="separator:a4f55110955ae305fd3daf2f0bcbee77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c60e7de7ec87e70dc53f7b66fd4c21a" id="r_a0c60e7de7ec87e70dc53f7b66fd4c21a"><td class="memItemLeft" align="right" valign="top"><a id="a0c60e7de7ec87e70dc53f7b66fd4c21a" name="a0c60e7de7ec87e70dc53f7b66fd4c21a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_processor_size</b> ()</td></tr>
<tr class="memdesc:a0c60e7de7ec87e70dc53f7b66fd4c21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get size of processor + processor_type <br /></td></tr>
<tr class="separator:a0c60e7de7ec87e70dc53f7b66fd4c21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35be14cd72b557f148e48f68ede87b8" id="r_af35be14cd72b557f148e48f68ede87b8"><td class="memItemLeft" align="right" valign="top"><a id="af35be14cd72b557f148e48f68ede87b8" name="af35be14cd72b557f148e48f68ede87b8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>processor_serialize</b> (unsigned char *blob)</td></tr>
<tr class="memdesc:af35be14cd72b557f148e48f68ede87b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">seialize processor + processor_type <br /></td></tr>
<tr class="separator:af35be14cd72b557f148e48f68ede87b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eebf1c987fb703006167d218ce55864" id="r_a9eebf1c987fb703006167d218ce55864"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#a9eebf1c987fb703006167d218ce55864">print</a> ()</td></tr>
<tr class="memdesc:a9eebf1c987fb703006167d218ce55864"><td class="mdescLeft">&#160;</td><td class="mdescRight">optional printing of processor  <br /></td></tr>
<tr class="separator:a9eebf1c987fb703006167d218ce55864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSerializableObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSerializableObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSerializableObject.html">SerializableObject</a></td></tr>
<tr class="memitem:ad3ad0112459c8567ade801b91a8e7cc7 inherit pub_methods_classSerializableObject" id="r_ad3ad0112459c8567ade801b91a8e7cc7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializableObject.html#ad3ad0112459c8567ade801b91a8e7cc7">version</a> () const</td></tr>
<tr class="memdesc:ad3ad0112459c8567ade801b91a8e7cc7 inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relevant for serializations.  <br /></td></tr>
<tr class="separator:ad3ad0112459c8567ade801b91a8e7cc7 inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50adcbc112e3ea0c07ac109ea0ff767b inherit pub_methods_classSerializableObject" id="r_a50adcbc112e3ea0c07ac109ea0ff767b"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializableObject.html#a50adcbc112e3ea0c07ac109ea0ff767b">my_class_name</a> () const</td></tr>
<tr class="memdesc:a50adcbc112e3ea0c07ac109ea0ff767b inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">For better handling of serializations it is highly recommended that each <a class="el" href="classSerializableObject.html">SerializableObject</a> inheriting class will implement the next method.  <br /></td></tr>
<tr class="separator:a50adcbc112e3ea0c07ac109ea0ff767b inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb17cc551baddd0f945567ba60b3f6a inherit pub_methods_classSerializableObject" id="r_a7bb17cc551baddd0f945567ba60b3f6a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializableObject.html#a7bb17cc551baddd0f945567ba60b3f6a">serialized_fields_name</a> (vector&lt; string &gt; &amp;field_names) const</td></tr>
<tr class="memdesc:a7bb17cc551baddd0f945567ba60b3f6a inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">The names of the serialized fields.  <br /></td></tr>
<tr class="separator:a7bb17cc551baddd0f945567ba60b3f6a inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b04c3cb80bfecd99e7b7a49e9177d5 inherit pub_methods_classSerializableObject" id="r_a46b04c3cb80bfecd99e7b7a49e9177d5"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>pre_serialization</b> ()</td></tr>
<tr class="separator:a46b04c3cb80bfecd99e7b7a49e9177d5 inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64de5b115bb5e36fe9d274b456827b5 inherit pub_methods_classSerializableObject" id="r_ad64de5b115bb5e36fe9d274b456827b5"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>post_deserialization</b> ()</td></tr>
<tr class="separator:ad64de5b115bb5e36fe9d274b456827b5 inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c00a3af5197e33e1161c334c90b7b inherit pub_methods_classSerializableObject" id="r_a074c00a3af5197e33e1161c334c90b7b"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializableObject.html#a074c00a3af5197e33e1161c334c90b7b">get_size</a> ()</td></tr>
<tr class="memdesc:a074c00a3af5197e33e1161c334c90b7b inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets bytes sizes for serializations.  <br /></td></tr>
<tr class="separator:a074c00a3af5197e33e1161c334c90b7b inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e50c7f6dfa9adc4a65a206664f21378 inherit pub_methods_classSerializableObject" id="r_a3e50c7f6dfa9adc4a65a206664f21378"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializableObject.html#a3e50c7f6dfa9adc4a65a206664f21378">serialize</a> (unsigned char *blob)</td></tr>
<tr class="memdesc:a3e50c7f6dfa9adc4a65a206664f21378 inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialiazing object to blob memory. return number ob bytes wrote to memory.  <br /></td></tr>
<tr class="separator:a3e50c7f6dfa9adc4a65a206664f21378 inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19a0b6eb6bbb8a5c2203a5b81001712 inherit pub_methods_classSerializableObject" id="r_ab19a0b6eb6bbb8a5c2203a5b81001712"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializableObject.html#ab19a0b6eb6bbb8a5c2203a5b81001712">deserialize</a> (unsigned char *blob)</td></tr>
<tr class="memdesc:ab19a0b6eb6bbb8a5c2203a5b81001712 inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialiazing blob to object. returns number of bytes read.  <br /></td></tr>
<tr class="separator:ab19a0b6eb6bbb8a5c2203a5b81001712 inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f26e5115d8a4ca352e96cf5724276df inherit pub_methods_classSerializableObject" id="r_a7f26e5115d8a4ca352e96cf5724276df"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>serialize_vec</b> (vector&lt; unsigned char &gt; &amp;blob)</td></tr>
<tr class="separator:a7f26e5115d8a4ca352e96cf5724276df inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa3dabbd28777fedd169804b1f558b5 inherit pub_methods_classSerializableObject" id="r_affa3dabbd28777fedd169804b1f558b5"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>deserialize_vec</b> (vector&lt; unsigned char &gt; &amp;blob)</td></tr>
<tr class="separator:affa3dabbd28777fedd169804b1f558b5 inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fc1cc07394e7cf36e6ecbf6741645d inherit pub_methods_classSerializableObject" id="r_aa2fc1cc07394e7cf36e6ecbf6741645d"><td class="memItemLeft" align="right" valign="top">
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (vector&lt; unsigned char &gt; &amp;blob)</td></tr>
<tr class="separator:aa2fc1cc07394e7cf36e6ecbf6741645d inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed35d22688e6e462fbaae5371cc33cef inherit pub_methods_classSerializableObject" id="r_aed35d22688e6e462fbaae5371cc33cef"><td class="memItemLeft" align="right" valign="top">
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>deserialize</b> (vector&lt; unsigned char &gt; &amp;blob)</td></tr>
<tr class="separator:aed35d22688e6e462fbaae5371cc33cef inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3657cd47638125675b7b767c46b595ea inherit pub_methods_classSerializableObject" id="r_a3657cd47638125675b7b767c46b595ea"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializableObject.html#a3657cd47638125675b7b767c46b595ea">read_from_file</a> (const string &amp;fname)</td></tr>
<tr class="memdesc:a3657cd47638125675b7b767c46b595ea inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">read and deserialize model  <br /></td></tr>
<tr class="separator:a3657cd47638125675b7b767c46b595ea inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2379eb492348d9c61caaf4cf52cebb4a inherit pub_methods_classSerializableObject" id="r_a2379eb492348d9c61caaf4cf52cebb4a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializableObject.html#a2379eb492348d9c61caaf4cf52cebb4a">write_to_file</a> (const string &amp;fname)</td></tr>
<tr class="memdesc:a2379eb492348d9c61caaf4cf52cebb4a inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize model and write to file  <br /></td></tr>
<tr class="separator:a2379eb492348d9c61caaf4cf52cebb4a inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7408d7809ef95761270d35857a7a02fb inherit pub_methods_classSerializableObject" id="r_a7408d7809ef95761270d35857a7a02fb"><td class="memItemLeft" align="right" valign="top">
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>read_from_file_unsafe</b> (const string &amp;fname)</td></tr>
<tr class="memdesc:a7408d7809ef95761270d35857a7a02fb inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">read and deserialize model without checking version number - unsafe read <br /></td></tr>
<tr class="separator:a7408d7809ef95761270d35857a7a02fb inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21abb36f80fd484aa2e620432087ea05 inherit pub_methods_classSerializableObject" id="r_a21abb36f80fd484aa2e620432087ea05"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>init_from_string</b> (string init_string)</td></tr>
<tr class="memdesc:a21abb36f80fd484aa2e620432087ea05 inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init from string. <br /></td></tr>
<tr class="separator:a21abb36f80fd484aa2e620432087ea05 inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa987921cb776dc9297b8b0c458d020 inherit pub_methods_classSerializableObject" id="r_aaaa987921cb776dc9297b8b0c458d020"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>init_params_from_file</b> (string init_file)</td></tr>
<tr class="separator:aaaa987921cb776dc9297b8b0c458d020 inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d23872d5125227c0690fbfefab492a inherit pub_methods_classSerializableObject" id="r_ac3d23872d5125227c0690fbfefab492a"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>init_param_from_file</b> (string file_str, string &amp;param)</td></tr>
<tr class="separator:ac3d23872d5125227c0690fbfefab492a inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0937ec139c17041838c0a9ff5686ec8b inherit pub_methods_classSerializableObject" id="r_a0937ec139c17041838c0a9ff5686ec8b"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>update_from_string</b> (const string &amp;init_string)</td></tr>
<tr class="separator:a0937ec139c17041838c0a9ff5686ec8b inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640b323530df7a5abb1eb84ad20ade0b inherit pub_methods_classSerializableObject" id="r_a640b323530df7a5abb1eb84ad20ade0b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerializableObject.html#a640b323530df7a5abb1eb84ad20ade0b">update</a> (map&lt; string, string &gt; &amp;map)</td></tr>
<tr class="memdesc:a640b323530df7a5abb1eb84ad20ade0b inherit pub_methods_classSerializableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual to update object from parsed fields.  <br /></td></tr>
<tr class="separator:a640b323530df7a5abb1eb84ad20ade0b inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ce88641cf2a7eda5a5e91a7cf52e53 inherit pub_methods_classSerializableObject" id="r_a04ce88641cf2a7eda5a5e91a7cf52e53"><td class="memItemLeft" align="right" valign="top">
virtual string&#160;</td><td class="memItemRight" valign="bottom"><b>object_json</b> () const</td></tr>
<tr class="separator:a04ce88641cf2a7eda5a5e91a7cf52e53 inherit pub_methods_classSerializableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a02f4de1bdfc3271e66c07606c21a138a" id="r_a02f4de1bdfc3271e66c07606c21a138a"><td class="memItemLeft" align="right" valign="top"><a id="a02f4de1bdfc3271e66c07606c21a138a" name="a02f4de1bdfc3271e66c07606c21a138a"></a>
static <a class="el" href="classRepProcessor.html">RepProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>make_processor</b> (string name)</td></tr>
<tr class="memdesc:a02f4de1bdfc3271e66c07606c21a138a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new repository processor from name <br /></td></tr>
<tr class="separator:a02f4de1bdfc3271e66c07606c21a138a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79901b365239d9b78743b031e22e9833" id="r_a79901b365239d9b78743b031e22e9833"><td class="memItemLeft" align="right" valign="top"><a id="a79901b365239d9b78743b031e22e9833" name="a79901b365239d9b78743b031e22e9833"></a>
static <a class="el" href="classRepProcessor.html">RepProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>make_processor</b> (string type, string params)</td></tr>
<tr class="memdesc:a79901b365239d9b78743b031e22e9833"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new repository processor from name and a parameters string <br /></td></tr>
<tr class="separator:a79901b365239d9b78743b031e22e9833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c5a218e68bc0cead79b2cb279a1211" id="r_a19c5a218e68bc0cead79b2cb279a1211"><td class="memItemLeft" align="right" valign="top"><a id="a19c5a218e68bc0cead79b2cb279a1211" name="a19c5a218e68bc0cead79b2cb279a1211"></a>
static <a class="el" href="classRepProcessor.html">RepProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>make_processor</b> (<a class="el" href="RepProcess_8h.html#a2772b5cb2b32efafbbd8ba9440b9576a">RepProcessorTypes</a> type)</td></tr>
<tr class="memdesc:a19c5a218e68bc0cead79b2cb279a1211"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new repository processor from type <br /></td></tr>
<tr class="separator:a19c5a218e68bc0cead79b2cb279a1211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024ed477a82e70343943335154615fb2" id="r_a024ed477a82e70343943335154615fb2"><td class="memItemLeft" align="right" valign="top"><a id="a024ed477a82e70343943335154615fb2" name="a024ed477a82e70343943335154615fb2"></a>
static <a class="el" href="classRepProcessor.html">RepProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>make_processor</b> (<a class="el" href="RepProcess_8h.html#a2772b5cb2b32efafbbd8ba9440b9576a">RepProcessorTypes</a> type, string params)</td></tr>
<tr class="memdesc:a024ed477a82e70343943335154615fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new repository processor from type and a parameters string <br /></td></tr>
<tr class="separator:a024ed477a82e70343943335154615fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978ddad5b922f1d997eeb6cfa5c03bf9" id="r_a978ddad5b922f1d997eeb6cfa5c03bf9"><td class="memItemLeft" align="right" valign="top"><a id="a978ddad5b922f1d997eeb6cfa5c03bf9" name="a978ddad5b922f1d997eeb6cfa5c03bf9"></a>
static <a class="el" href="classRepProcessor.html">RepProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>create_processor</b> (string &amp;params)</td></tr>
<tr class="memdesc:a978ddad5b922f1d997eeb6cfa5c03bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new repository processor from parameters string which contains rp_type <br /></td></tr>
<tr class="separator:a978ddad5b922f1d997eeb6cfa5c03bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a6bd2bcaf6a6a26e42f17065d627cd454" id="r_a6bd2bcaf6a6a26e42f17065d627cd454"><td class="memItemLeft" align="right" valign="top"><a id="a6bd2bcaf6a6a26e42f17065d627cd454" name="a6bd2bcaf6a6a26e42f17065d627cd454"></a>
<a class="el" href="RepProcess_8h.html#a2772b5cb2b32efafbbd8ba9440b9576a">RepProcessorTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>processor_type</b> = REP_PROCESS_LAST</td></tr>
<tr class="memdesc:a6bd2bcaf6a6a26e42f17065d627cd454"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of repository processor <br /></td></tr>
<tr class="separator:a6bd2bcaf6a6a26e42f17065d627cd454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceca38d241d2494a16375a05319c377" id="r_a2ceca38d241d2494a16375a05319c377"><td class="memItemLeft" align="right" valign="top"><a id="a2ceca38d241d2494a16375a05319c377" name="a2ceca38d241d2494a16375a05319c377"></a>
unordered_set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>req_signals</b></td></tr>
<tr class="memdesc:a2ceca38d241d2494a16375a05319c377"><td class="mdescLeft">&#160;</td><td class="mdescRight">names of signals required for processsing <br /></td></tr>
<tr class="separator:a2ceca38d241d2494a16375a05319c377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e62297d252ccc4ae2adc860b50c9363" id="r_a9e62297d252ccc4ae2adc860b50c9363"><td class="memItemLeft" align="right" valign="top"><a id="a9e62297d252ccc4ae2adc860b50c9363" name="a9e62297d252ccc4ae2adc860b50c9363"></a>
unordered_set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>req_signal_ids</b></td></tr>
<tr class="memdesc:a9e62297d252ccc4ae2adc860b50c9363"><td class="mdescLeft">&#160;</td><td class="mdescRight">ids of signals required for processing <br /></td></tr>
<tr class="separator:a9e62297d252ccc4ae2adc860b50c9363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dcc0ecea01adeae4c03402bbe7d334" id="r_a26dcc0ecea01adeae4c03402bbe7d334"><td class="memItemLeft" align="right" valign="top"><a id="a26dcc0ecea01adeae4c03402bbe7d334" name="a26dcc0ecea01adeae4c03402bbe7d334"></a>
unordered_set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>aff_signals</b></td></tr>
<tr class="memdesc:a26dcc0ecea01adeae4c03402bbe7d334"><td class="mdescLeft">&#160;</td><td class="mdescRight">names of signals affected by processing <br /></td></tr>
<tr class="separator:a26dcc0ecea01adeae4c03402bbe7d334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f39f9b2772d23449db7c7416d74406a" id="r_a9f39f9b2772d23449db7c7416d74406a"><td class="memItemLeft" align="right" valign="top"><a id="a9f39f9b2772d23449db7c7416d74406a" name="a9f39f9b2772d23449db7c7416d74406a"></a>
unordered_set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>aff_signal_ids</b></td></tr>
<tr class="memdesc:a9f39f9b2772d23449db7c7416d74406a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ids of signals affected by processing <br /></td></tr>
<tr class="separator:a9f39f9b2772d23449db7c7416d74406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28beb6c9377af37267599fca4971bff3" id="r_a28beb6c9377af37267599fca4971bff3"><td class="memItemLeft" align="right" valign="top"><a id="a28beb6c9377af37267599fca4971bff3" name="a28beb6c9377af37267599fca4971bff3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>unconditional</b> = false</td></tr>
<tr class="memdesc:a28beb6c9377af37267599fca4971bff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicated that processor should ALWAYS be applied <br /></td></tr>
<tr class="separator:a28beb6c9377af37267599fca4971bff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164ef02ce1980e6a56ad1715f979a7c1" id="r_a164ef02ce1980e6a56ad1715f979a7c1"><td class="memItemLeft" align="right" valign="top"><a id="a164ef02ce1980e6a56ad1715f979a7c1" name="a164ef02ce1980e6a56ad1715f979a7c1"></a>
vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>attributes</b></td></tr>
<tr class="memdesc:a164ef02ce1980e6a56ad1715f979a7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">attributes generated by the processor (optional) <br /></td></tr>
<tr class="separator:a164ef02ce1980e6a56ad1715f979a7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73d8439f1d028d16767a50f2f2338c2" id="r_af73d8439f1d028d16767a50f2f2338c2"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; string, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRepProcessor.html#af73d8439f1d028d16767a50f2f2338c2">virtual_signals</a></td></tr>
<tr class="memdesc:af73d8439f1d028d16767a50f2f2338c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual signals are created only in rep processors but can be used by any rep processor that comes after or any feture generator as a regular signal.  <br /></td></tr>
<tr class="separator:af73d8439f1d028d16767a50f2f2338c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738deb9ff60673bb6af380d7baf5239d" id="r_a738deb9ff60673bb6af380d7baf5239d"><td class="memItemLeft" align="right" valign="top"><a id="a738deb9ff60673bb6af380d7baf5239d" name="a738deb9ff60673bb6af380d7baf5239d"></a>
vector&lt; pair&lt; string, string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>virtual_signals_generic</b></td></tr>
<tr class="separator:a738deb9ff60673bb6af380d7baf5239d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2f8218a39e4bff0b694ad38182339335" name="a2f8218a39e4bff0b694ad38182339335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8218a39e4bff0b694ad38182339335">&#9670;&#160;</a></span>_apply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int RepProcessor::_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>time_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>attributes_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply processing on a single <a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> at a set of time-points : Should be implemented for all inheriting classes. </p>
<p>if time_points is empty, processinng is done for each version for all times </p>

<p>Reimplemented in <a class="el" href="classRepCategoryDescenders.html#ab5de377ec2e403973c04476ff39bb75b">RepCategoryDescenders</a>, <a class="el" href="classRepClearSignalByDiag.html#aa128298f8595ffdc07c7deb3ab9d3d95">RepClearSignalByDiag</a>, <a class="el" href="classRepCreateRegistry.html#a42748065ae748b21e11a9c50794cb09f">RepCreateRegistry</a>, <a class="el" href="classRepFilterByChannel.html#a0973df8ac51042d4b2cb248cef885be5">RepFilterByChannel</a>, <a class="el" href="classRepBasicOutlierCleaner.html#a4390b1ae4cc6f251ca37e345c3d1e102">RepBasicOutlierCleaner</a>, <a class="el" href="classRepRuleBasedOutlierCleaner.html#a89fa92dba8b5b17ff7c1c356212f07fa">RepRuleBasedOutlierCleaner</a>, <a class="el" href="classRepNbrsOutlierCleaner.html#a181b9962ce36f6d959571198a50f89eb">RepNbrsOutlierCleaner</a>, <a class="el" href="classRepSimValHandler.html#a8994c6d00ec6a8e15ab8b799ca85cb0c">RepSimValHandler</a>, <a class="el" href="classRepPanelCompleter.html#ad306a333883a7955b5895deca838e6e0">RepPanelCompleter</a>, <a class="el" href="classRepCalcSimpleSignals.html#af5fdae83fc64d78c4de832e9832892cd">RepCalcSimpleSignals</a>, <a class="el" href="classRepCombineSignals.html#acbb6f7052e49ca4f5cb0145b387590a1">RepCombineSignals</a>, <a class="el" href="classRepSplitSignal.html#a60e77c264b08b149a41876b06e862f5e">RepSplitSignal</a>, <a class="el" href="classRepAggregationPeriod.html#a87855b9409d0e92a5f6dc020fba23254">RepAggregationPeriod</a>, <a class="el" href="classRepBasicRangeCleaner.html#a8ec03360ea021c2fad0d0cfec088743f">RepBasicRangeCleaner</a>, <a class="el" href="classRepSignalRate.html#adff7afdeafcd9eeaf08b6982fb41c671">RepSignalRate</a>, <a class="el" href="classRepAggregateSignal.html#aeca6022425288acdce03a40527448195">RepAggregateSignal</a>, <a class="el" href="classRepCreateBitSignal.html#a4963258c24d8ba780b4301ea70f4910d">RepCreateBitSignal</a>, <a class="el" href="classRepCheckReq.html#a5e816a958301aa6e5990a97e0bff0309">RepCheckReq</a>, <a class="el" href="classRepHistoryLimit.html#a011154346d50c21fa47e5192dee6cc41">RepHistoryLimit</a>, <a class="el" href="classRepNumericNoiser.html#af18a49145b7c32b3729a4b616124ea93">RepNumericNoiser</a>, <a class="el" href="classRepReoderChannels.html#a1b73e8be9e93214aefc38a429e8f39d1">RepReoderChannels</a>, and <a class="el" href="classRepMultiProcessor.html#a668066fd16368fa15a2488219b0e9909">RepMultiProcessor</a>.</p>

</div>
</div>
<a id="a85279a2a854d046bcc81d62439e7f29f" name="a85279a2a854d046bcc81d62439e7f29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85279a2a854d046bcc81d62439e7f29f">&#9670;&#160;</a></span>_conditional_apply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RepProcessor::_conditional_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>time_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>neededSignalIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>attributes_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply processing on a single <a class="el" href="classPidDynamicRec.html">PidDynamicRec</a> at a set of time-points only if required : May be implemented for inheriting classes </p>

<p>Reimplemented in <a class="el" href="classRepMultiProcessor.html#ab7d39fb9b93eea6329329f1754e60c38">RepMultiProcessor</a>.</p>

</div>
</div>
<a id="afb47eb142a0ed05219397eccfa672562" name="afb47eb142a0ed05219397eccfa672562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb47eb142a0ed05219397eccfa672562">&#9670;&#160;</a></span>_conditional_learn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RepProcessor::_conditional_learn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMedSamples.html">MedSamples</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classRepProcessor.html">RepProcessor</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>prev_processors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>neededSignalIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>learn processing model on a subset of samples only if required. Apply set of preceeding processors on DynamicPidRec before learning : </p>

<p>Reimplemented in <a class="el" href="classRepMultiProcessor.html#adcd7deaedd57d250ecc50ac1e93cee4d">RepMultiProcessor</a>.</p>

</div>
</div>
<a id="aae21e4a49dcded29690911e9533f6a13" name="aae21e4a49dcded29690911e9533f6a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae21e4a49dcded29690911e9533f6a13">&#9670;&#160;</a></span>_learn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int RepProcessor::_learn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMedSamples.html">MedSamples</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classRepProcessor.html">RepProcessor</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>prev_processors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>learn processing model on a subset of samples. Apply set of preceeding processors on DynamicPidRec before learning : </p>

<p>Reimplemented in <a class="el" href="classRepBasicOutlierCleaner.html#ad66674e6a69ede76e4c68f7ecdc9d398">RepBasicOutlierCleaner</a>, <a class="el" href="classRepConfiguredOutlierCleaner.html#a78416f2022edca0654ef4cb7449db938">RepConfiguredOutlierCleaner</a>, <a class="el" href="classRepNbrsOutlierCleaner.html#a025d6c0d1b470f4ca747649e1eecddf1">RepNbrsOutlierCleaner</a>, <a class="el" href="classRepHistoryLimit.html#aac79da025852919867e716cfd1675ea0">RepHistoryLimit</a>, <a class="el" href="classRepNumericNoiser.html#a57189e6da841a257405851ed74329d87">RepNumericNoiser</a>, <a class="el" href="classRepCreateRegistry.html#ab5b7ba0c207d1f7a251475dbc67fffed">RepCreateRegistry</a>, <a class="el" href="classRepMultiProcessor.html#a4cf9651274484d0895962b14faf75298">RepMultiProcessor</a>, <a class="el" href="classRepRuleBasedOutlierCleaner.html#ab6bc9fd4b06e4008c084a34bdea0a943">RepRuleBasedOutlierCleaner</a>, <a class="el" href="classRepPanelCompleter.html#a9bd40147dee8bffa9763f656b473b344">RepPanelCompleter</a>, and <a class="el" href="classRepCalcSimpleSignals.html#ab7cf00389209f2f6f5de412524a2ec9d">RepCalcSimpleSignals</a>.</p>

</div>
</div>
<a id="ad5935a833d52f4bd98ea460dd0810fad" name="ad5935a833d52f4bd98ea460dd0810fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5935a833d52f4bd98ea460dd0810fad">&#9670;&#160;</a></span>add_virtual_signals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RepProcessor::add_virtual_signals </td>
          <td>(</td>
          <td class="paramtype">map&lt; string, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>_virtual_signals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>_virtual_signals_generic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rep processors CREATING virtual signals need to implement this: adding their signals to the pile </p>

<p>Reimplemented in <a class="el" href="classRepMultiProcessor.html#aa4357558d04330ef24f8951f0bf80369">RepMultiProcessor</a>.</p>

</div>
</div>
<a id="a2f2a308033023605ab668bcad5e15d16" name="a2f2a308033023605ab668bcad5e15d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2a308033023605ab668bcad5e15d16">&#9670;&#160;</a></span>dprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RepProcessor::dprint </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>pref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rp_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used for debug prints, each inheriting class can overload this one to get a more precise debug print. </p>
<p>rp_flag can be used to transfer verbosity levels. the default print just prints the basic type, etc. summary&gt; prints summary of rep_processor job. optional, called after apply. for example - prints how many values were cleaned /summary&gt; </p>

<p>Reimplemented in <a class="el" href="classRepMultiProcessor.html#ad23a9a3ea163b5867ac3c2d7d77c85a3">RepMultiProcessor</a>, <a class="el" href="classRepBasicOutlierCleaner.html#a62b1e039f9c8bd2b2aae5759963f5990">RepBasicOutlierCleaner</a>, and <a class="el" href="classRepRuleBasedOutlierCleaner.html#ac3e3c3a72ddb87ee0594463ba179cd61">RepRuleBasedOutlierCleaner</a>.</p>

</div>
</div>
<a id="abc98db12a0701abbec238a7c43c0e2a8" name="abc98db12a0701abbec238a7c43c0e2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc98db12a0701abbec238a7c43c0e2a8">&#9670;&#160;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RepProcessor::filter </td>
          <td>(</td>
          <td class="paramtype">unordered_set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>reqSignals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if processor (and 'sub'-processors within) should be applied according to set of required signals &lt;/summray&gt; </p><dl class="section return"><dt>Returns</dt><dd>true if processor is not required and can be filtered, false otherwise </dd></dl>
</p>

<p>Reimplemented in <a class="el" href="classRepMultiProcessor.html#a447051af9ba8550075bb29be98d8e302">RepMultiProcessor</a>.</p>

</div>
</div>
<a id="a43105179b01b461eaf0bbd28b66cb013" name="a43105179b01b461eaf0bbd28b66cb013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43105179b01b461eaf0bbd28b66cb013">&#9670;&#160;</a></span>fit_for_repository()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RepProcessor::fit_for_repository </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMedPidRepository.html">MedPidRepository</a> &amp;&#160;</td>
          <td class="paramname"><em>rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make changes to <a class="el" href="classRepProcessor.html">RepProcessor</a> according to available signals in Repository </p>

<p>Reimplemented in <a class="el" href="classRepFilterByChannel.html#a2f3ee69b59e504bc6f2f0e557bbc01ba">RepFilterByChannel</a>, <a class="el" href="classRepMultiProcessor.html#a94acec4226e722ffba5e5119458ac2f1">RepMultiProcessor</a>, <a class="el" href="classRepRuleBasedOutlierCleaner.html#afabab03b0b48594493987fbc5b544644">RepRuleBasedOutlierCleaner</a>, <a class="el" href="classRepPanelCompleter.html#ad4b8298af37683dbe9d6941ca1820f2a">RepPanelCompleter</a>, <a class="el" href="classRepCalcSimpleSignals.html#a73af4f997bc5b27093739f512ecfba00">RepCalcSimpleSignals</a>, <a class="el" href="classRepCombineSignals.html#acafc87822bbb7e4d8987049e9d33547b">RepCombineSignals</a>, and <a class="el" href="classRepBasicRangeCleaner.html#ad58826c864999b1276f139575d972d2d">RepBasicRangeCleaner</a>.</p>

</div>
</div>
<a id="a8bfcb3841f19afc26ff40c02963b78d4" name="a8bfcb3841f19afc26ff40c02963b78d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfcb3841f19afc26ff40c02963b78d4">&#9670;&#160;</a></span>get_required_signal_categories()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RepProcessor::get_required_signal_categories </td>
          <td>(</td>
          <td class="paramtype">unordered_map&lt; string, vector&lt; string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>signal_categories_in_use</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns for each used signal it's used categories </p>

<p>Reimplemented in <a class="el" href="classRepCreateRegistry.html#a36ee6f0310777a3c66fb36142997b9cb">RepCreateRegistry</a>, <a class="el" href="classRepMultiProcessor.html#acd24c1b54daf53b6700e6353ad2f4486">RepMultiProcessor</a>, <a class="el" href="classRepCalcSimpleSignals.html#a86a34a8b40d31a2b46e794aebf6061c6">RepCalcSimpleSignals</a>, <a class="el" href="classRepSplitSignal.html#a31089924edf7a220e23a637961e9088b">RepSplitSignal</a>, <a class="el" href="classRepAggregationPeriod.html#a401c2c4d89ee1d3de4e3d5f078dec1ac">RepAggregationPeriod</a>, and <a class="el" href="classRepCreateBitSignal.html#a797b42998170feb8708efeee5dd2b1fc">RepCreateBitSignal</a>.</p>

</div>
</div>
<a id="ad14083adda53a5f82f488b18d8619d4a" name="ad14083adda53a5f82f488b18d8619d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14083adda53a5f82f488b18d8619d4a">&#9670;&#160;</a></span>get_required_signal_ids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RepProcessor::get_required_signal_ids </td>
          <td>(</td>
          <td class="paramtype">unordered_set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>signalIds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append required signal names to set : parent function just uses req_signals. </p>

<p>Reimplemented in <a class="el" href="classRepMultiProcessor.html#a776a34fbe5e9f7b4dc76a0628e387b2c">RepMultiProcessor</a>.</p>

</div>
</div>
<a id="a142e21a5ff147dab5d2f7f181403fc6f" name="a142e21a5ff147dab5d2f7f181403fc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142e21a5ff147dab5d2f7f181403fc6f">&#9670;&#160;</a></span>get_required_signal_ids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RepProcessor::get_required_signal_ids </td>
          <td>(</td>
          <td class="paramtype">unordered_set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>signalIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; int &gt;&#160;</td>
          <td class="paramname"><em>preReqSignals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append required signal names to set only if processor is actually required to produce any of preReqSignals : parent function just uses req_signals. </p>

<p>Reimplemented in <a class="el" href="classRepMultiProcessor.html#ac87901f4b9ad8dafba69f4e84b6b9c08">RepMultiProcessor</a>.</p>

</div>
</div>
<a id="a1ebb3919cad4f925d25f6c9fe4ea67a0" name="a1ebb3919cad4f925d25f6c9fe4ea67a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebb3919cad4f925d25f6c9fe4ea67a0">&#9670;&#160;</a></span>get_required_signal_names() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RepProcessor::get_required_signal_names </td>
          <td>(</td>
          <td class="paramtype">unordered_set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>signalNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append required signal names to set : parent function just uses req_signals. </p>

<p>Reimplemented in <a class="el" href="classRepMultiProcessor.html#ae748a366ca06a650793adecdd03ab2db">RepMultiProcessor</a>.</p>

</div>
</div>
<a id="a854f927b866730036cbbd782ee8bda2d" name="a854f927b866730036cbbd782ee8bda2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854f927b866730036cbbd782ee8bda2d">&#9670;&#160;</a></span>get_required_signal_names() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RepProcessor::get_required_signal_names </td>
          <td>(</td>
          <td class="paramtype">unordered_set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>signalNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; string &gt;&#160;</td>
          <td class="paramname"><em>preReqSignals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append required signal names to set only if processor is actually required to produce any of preReqSignals : parent function just uses req_signals. </p>

<p>Reimplemented in <a class="el" href="classRepMultiProcessor.html#a3b3a271883c3504fde133d1a431bf407">RepMultiProcessor</a>.</p>

</div>
</div>
<a id="ad266f41bd5a6e5a9bd8c632b8be97f86" name="ad266f41bd5a6e5a9bd8c632b8be97f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad266f41bd5a6e5a9bd8c632b8be97f86">&#9670;&#160;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int RepProcessor::init </td>
          <td>(</td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize from a map : Should be implemented for inheriting classes that have parameters </p>

<p>Reimplemented from <a class="el" href="classSerializableObject.html#abcc96dba166dab2d7462a9aab7df4488">SerializableObject</a>.</p>

<p>Reimplemented in <a class="el" href="classRepCategoryDescenders.html#add65d0a61aa44c5baf77d241b89b3a57">RepCategoryDescenders</a>, <a class="el" href="classRepClearSignalByDiag.html#ace78c53aea47c1fc123ab76c4ee7714d">RepClearSignalByDiag</a>, <a class="el" href="classRepCreateRegistry.html#acfc71cf3ee15eee7c347a5ea762b7328">RepCreateRegistry</a>, <a class="el" href="classRepFilterByChannel.html#a92f1b4e9d3e96ec60676c841ac3a3d74">RepFilterByChannel</a>, <a class="el" href="classRepBasicOutlierCleaner.html#a1b5285a6d54acf4533187f709e5de574">RepBasicOutlierCleaner</a>, <a class="el" href="classRepConfiguredOutlierCleaner.html#a38d0a2f5ffe9004be7bd3c258c005ea7">RepConfiguredOutlierCleaner</a>, <a class="el" href="classRepRuleBasedOutlierCleaner.html#a26620b3ed32b20360789508ff3098b3e">RepRuleBasedOutlierCleaner</a>, <a class="el" href="classRepNbrsOutlierCleaner.html#a578ef22c002b635b2039bc641db2d406">RepNbrsOutlierCleaner</a>, <a class="el" href="classRepSimValHandler.html#a12b193c03d977c0a67fd3cb452a7b602">RepSimValHandler</a>, <a class="el" href="classRepPanelCompleter.html#acc6cd717568eda92a6624873dd49788c">RepPanelCompleter</a>, <a class="el" href="classRepCalcSimpleSignals.html#a0086af3e37215f429c280c4337998ed5">RepCalcSimpleSignals</a>, <a class="el" href="classRepCombineSignals.html#ac3c208e470e1ab67092e538c489b0774">RepCombineSignals</a>, <a class="el" href="classRepSplitSignal.html#ad9a40fc7f457586867d89de62d7afa34">RepSplitSignal</a>, <a class="el" href="classRepAggregationPeriod.html#a3c765aff112bb0e747683f561aca5b34">RepAggregationPeriod</a>, <a class="el" href="classRepBasicRangeCleaner.html#afc721799428b0cddc35f353b6af8ad94">RepBasicRangeCleaner</a>, <a class="el" href="classRepSignalRate.html#a0be3ac108d2d998c9374b8dcdd60edc0">RepSignalRate</a>, <a class="el" href="classRepAggregateSignal.html#a2e05949c7b0ee5e1f7ea82889c46407d">RepAggregateSignal</a>, <a class="el" href="classRepCreateBitSignal.html#a0c987aaea92c24f523bc5bfabaf518e2">RepCreateBitSignal</a>, <a class="el" href="classRepCheckReq.html#ac1a3211317c06204290ec95b84b035d8">RepCheckReq</a>, <a class="el" href="classRepHistoryLimit.html#acb109267906d80a0df4ba3a130e3cf04">RepHistoryLimit</a>, <a class="el" href="classRepNumericNoiser.html#a1043581bbd38e8251987fe2182cfb280">RepNumericNoiser</a>, and <a class="el" href="classRepReoderChannels.html#a68ed466503165924cb5f098df188fc46">RepReoderChannels</a>.</p>

</div>
</div>
<a id="a8b1c77457bf1afe5b10cef12f83499a3" name="a8b1c77457bf1afe5b10cef12f83499a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1c77457bf1afe5b10cef12f83499a3">&#9670;&#160;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int RepProcessor::init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize from a params object : Should be implemented for inheriting classes that have parameters </p>

<p>Reimplemented in <a class="el" href="classRepBasicOutlierCleaner.html#a885ea7bd3add36e6d1305e9e7e8cd3ce">RepBasicOutlierCleaner</a>, <a class="el" href="classRepRuleBasedOutlierCleaner.html#a56d894aa06feb5a2bf9aacb2451294e1">RepRuleBasedOutlierCleaner</a>, and <a class="el" href="classRepNbrsOutlierCleaner.html#ae43024024867a175ea38132a53b41093">RepNbrsOutlierCleaner</a>.</p>

</div>
</div>
<a id="a9033c56b84ed6e1d4724bc2a06d3cf4c" name="a9033c56b84ed6e1d4724bc2a06d3cf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9033c56b84ed6e1d4724bc2a06d3cf4c">&#9670;&#160;</a></span>init_attributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RepProcessor::init_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Init attributes information : Should be implemented for inheriting classes that have attributes. </p>

<p>Reimplemented in <a class="el" href="classRepMultiProcessor.html#a0be32720b67bea3fea4365276484fbd4">RepMultiProcessor</a>, <a class="el" href="classRepBasicOutlierCleaner.html#a35cfc1641a6e0c6bf84d3d2d5fcd1060">RepBasicOutlierCleaner</a>, <a class="el" href="classRepRuleBasedOutlierCleaner.html#a269ca7dcc1f22e76e92f6c62ddd7ae01">RepRuleBasedOutlierCleaner</a>, <a class="el" href="classRepNbrsOutlierCleaner.html#a81527e263aec9a807ef8749fbfc13f64">RepNbrsOutlierCleaner</a>, <a class="el" href="classRepSimValHandler.html#a0eed3edc98af7808d1063918f68bd50e">RepSimValHandler</a>, and <a class="el" href="classRepCheckReq.html#a11a5344bf376b90738f0d16362b5a1b5">RepCheckReq</a>.</p>

</div>
</div>
<a id="a339d1587dd21ff9789a427cd348ed5f7" name="a339d1587dd21ff9789a427cd348ed5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339d1587dd21ff9789a427cd348ed5f7">&#9670;&#160;</a></span>init_defaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RepProcessor::init_defaults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize to default values : Should be implemented for inheriting classes that have parameters </p>

<p>Reimplemented in <a class="el" href="classRepBasicOutlierCleaner.html#a9a56be17dc17ceff6e68b2de13c305ce">RepBasicOutlierCleaner</a>, <a class="el" href="classRepConfiguredOutlierCleaner.html#abafb65fca50fb123ea744a7b66861813">RepConfiguredOutlierCleaner</a>, <a class="el" href="classRepRuleBasedOutlierCleaner.html#a10232fd0916493dbdcfea0d39ed73112">RepRuleBasedOutlierCleaner</a>, <a class="el" href="classRepNbrsOutlierCleaner.html#a5676983aa8f82bc09014d911a396a242">RepNbrsOutlierCleaner</a>, <a class="el" href="classRepPanelCompleter.html#aa05a8f741b94256f2ecbfec9ec0cf501">RepPanelCompleter</a>, <a class="el" href="classRepHistoryLimit.html#afb82244fa802bf837cf20de01969e52a">RepHistoryLimit</a>, and <a class="el" href="classRepNumericNoiser.html#ad93d06d0afd505ccdb21c21153da243d">RepNumericNoiser</a>.</p>

</div>
</div>
<a id="add5f40f8dad32df49ea74d03dab4b004" name="add5f40f8dad32df49ea74d03dab4b004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5f40f8dad32df49ea74d03dab4b004">&#9670;&#160;</a></span>init_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RepProcessor::init_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMedDictionarySections.html">MedDictionarySections</a> &amp;&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMedSignals.html">MedSignals</a> &amp;&#160;</td>
          <td class="paramname"><em>sigs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Init required tables : Should be implemented for inheriting classes that have such tables. </p>

<p>Reimplemented in <a class="el" href="classRepCategoryDescenders.html#afa44e2a3cb775509e2afd1226146d214">RepCategoryDescenders</a>, <a class="el" href="classRepClearSignalByDiag.html#aeb7a5d28df72154f6b63e40c76c69086">RepClearSignalByDiag</a>, <a class="el" href="classRepCreateRegistry.html#affd9bbdc26d0816aa23f868d15634036">RepCreateRegistry</a>, <a class="el" href="classRepFilterByChannel.html#af180c69f38fddb75fc7016643e1306bf">RepFilterByChannel</a>, <a class="el" href="classRepMultiProcessor.html#a2f794802646b5fde5714a4c3ed983cae">RepMultiProcessor</a>, <a class="el" href="classRepRuleBasedOutlierCleaner.html#ae1bb8a9954dedb61e48c529f4e977ad3">RepRuleBasedOutlierCleaner</a>, <a class="el" href="classRepSimValHandler.html#a9d17c0057ccf3230cd3311e5163bba3d">RepSimValHandler</a>, <a class="el" href="classRepPanelCompleter.html#a1136d53197edce07b6e56221b0154685">RepPanelCompleter</a>, <a class="el" href="classRepCalcSimpleSignals.html#a81284775059ce9bcb99625a1b1d2b00b">RepCalcSimpleSignals</a>, <a class="el" href="classRepCombineSignals.html#a43c5291dafc18806594d4d14a61f4fbf">RepCombineSignals</a>, <a class="el" href="classRepSplitSignal.html#a5d6bfda5edd96b3b5f0999e776f559f8">RepSplitSignal</a>, <a class="el" href="classRepAggregationPeriod.html#a164ea8cc34cf73ac148ec4987dae1731">RepAggregationPeriod</a>, <a class="el" href="classRepBasicRangeCleaner.html#a8491a9b95600cb79541c358f89ea8cf0">RepBasicRangeCleaner</a>, <a class="el" href="classRepSignalRate.html#ae7113b1c36fcb3c835112e4a983bbe44">RepSignalRate</a>, <a class="el" href="classRepAggregateSignal.html#a007d6c0dd087055260ed2a88a59632ab">RepAggregateSignal</a>, <a class="el" href="classRepCreateBitSignal.html#add527c2a1b01cb7ca23c9bc3aa0fbd01">RepCreateBitSignal</a>, and <a class="el" href="classRepCheckReq.html#a862fa8aaac91c900a6f5d47da8822c94">RepCheckReq</a>.</p>

</div>
</div>
<a id="a4f55110955ae305fd3daf2f0bcbee77d" name="a4f55110955ae305fd3daf2f0bcbee77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f55110955ae305fd3daf2f0bcbee77d">&#9670;&#160;</a></span>new_polymorphic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * RepProcessor::new_polymorphic </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>derived_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for polymorphic classes that want to be able to serialize/deserialize a pointer * to the derived class given its type one needs to implement this function to return a new to the derived class given its type (as in my_type) </p>

<p>Reimplemented from <a class="el" href="classSerializableObject.html#a9c3bcc5ff046bf41f8ad133733213f3c">SerializableObject</a>.</p>

</div>
</div>
<a id="a9eebf1c987fb703006167d218ce55864" name="a9eebf1c987fb703006167d218ce55864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eebf1c987fb703006167d218ce55864">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RepProcessor::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>optional printing of processor </p>

<p>Reimplemented in <a class="el" href="classRepFilterByChannel.html#aea8ff5801f8466b507805d4e297fa22b">RepFilterByChannel</a>, <a class="el" href="classRepMultiProcessor.html#a35521390626f444ef854390d628c11f5">RepMultiProcessor</a>, <a class="el" href="classRepBasicOutlierCleaner.html#adbf1a56a7bc05f091c485f2ee1293c27">RepBasicOutlierCleaner</a>, <a class="el" href="classRepPanelCompleter.html#afca2ae558f57ec6131a0ab58b7f1bd1d">RepPanelCompleter</a>, <a class="el" href="classRepCalcSimpleSignals.html#adf84ae811141c32420f8e8b7fb0605aa">RepCalcSimpleSignals</a>, <a class="el" href="classRepCombineSignals.html#a23599f3873ba47fea7d7882132b597be">RepCombineSignals</a>, <a class="el" href="classRepSplitSignal.html#ab509a9a6b83bb717109211f8f666e5c7">RepSplitSignal</a>, <a class="el" href="classRepAggregationPeriod.html#afaf1b5a9e2f620e2b19287d670adb741">RepAggregationPeriod</a>, <a class="el" href="classRepSignalRate.html#a51180731b9acb90e1087edf7c775a22d">RepSignalRate</a>, <a class="el" href="classRepAggregateSignal.html#a676e25fdbb654c7e9a1c89f73177c4aa">RepAggregateSignal</a>, and <a class="el" href="classRepReoderChannels.html#a37f9db0216308d0074996827f18fd45d">RepReoderChannels</a>.</p>

</div>
</div>
<a id="a5c7ee88d8b5e73adbacb80451c981895" name="a5c7ee88d8b5e73adbacb80451c981895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7ee88d8b5e73adbacb80451c981895">&#9670;&#160;</a></span>register_virtual_section_name_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RepProcessor::register_virtual_section_name_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMedDictionarySections.html">MedDictionarySections</a> &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register section id to section name of new virtual signals. </p>

<p>Reimplemented in <a class="el" href="classRepFilterByChannel.html#a89d490727537813e26d58e6dd91225e8">RepFilterByChannel</a>, <a class="el" href="classRepMultiProcessor.html#a017f638e55eae592bcda843eccc0fd5c">RepMultiProcessor</a>, <a class="el" href="classRepCalcSimpleSignals.html#a75bd3d349153822553a95967c643360a">RepCalcSimpleSignals</a>, <a class="el" href="classRepCombineSignals.html#a1d2d65e79b02a46f83a55d3d4cdacd9a">RepCombineSignals</a>, <a class="el" href="classRepSplitSignal.html#a56cf048d40f1b6f6f463c60392a9683e">RepSplitSignal</a>, <a class="el" href="classRepBasicRangeCleaner.html#a4961a3120155e904e650f1e0eff4ce45">RepBasicRangeCleaner</a>, <a class="el" href="classRepSignalRate.html#a87075af978f0eb6d294981245d591430">RepSignalRate</a>, <a class="el" href="classRepAggregateSignal.html#a1131d5aa154b124cb511f4a41272f346">RepAggregateSignal</a>, and <a class="el" href="classRepCreateBitSignal.html#a8f9446819fa03048a5293c533c5861a2">RepCreateBitSignal</a>.</p>

</div>
</div>
<a id="a28c6df24c0b6c111e9edf8c971fe1e2e" name="a28c6df24c0b6c111e9edf8c971fe1e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c6df24c0b6c111e9edf8c971fe1e2e">&#9670;&#160;</a></span>set_affected_signal_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RepProcessor::set_affected_signal_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMedDictionarySections.html">MedDictionarySections</a> &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill aff_signal_ids : parent function just fills from aff_signals. </p>

<p>Reimplemented in <a class="el" href="classRepClearSignalByDiag.html#a03bf4232054486f65becf02dec3e258f">RepClearSignalByDiag</a>, <a class="el" href="classRepFilterByChannel.html#a16ad6382ef2319b1a9ef2cf4f58b2d39">RepFilterByChannel</a>, <a class="el" href="classRepMultiProcessor.html#a10f8a583fa024cad8bbf27ca5b2b8bb9">RepMultiProcessor</a>, <a class="el" href="classRepCombineSignals.html#a288140b1dfbcd20bd2820f2b037723fa">RepCombineSignals</a>, <a class="el" href="classRepSplitSignal.html#a358c26a0f7fc6c08328a28221166218f">RepSplitSignal</a>, <a class="el" href="classRepSignalRate.html#ae70eb7ca876395fef64034800d0c6155">RepSignalRate</a>, <a class="el" href="classRepAggregateSignal.html#a520e3317deb523b5da955e5ddf9a4a4d">RepAggregateSignal</a>, and <a class="el" href="classRepCreateBitSignal.html#a1703d8cc9a6c394baabec9fcced5736b">RepCreateBitSignal</a>.</p>

</div>
</div>
<a id="a79aebdeb6669f434a769ce8290d1b1f4" name="a79aebdeb6669f434a769ce8290d1b1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79aebdeb6669f434a769ce8290d1b1f4">&#9670;&#160;</a></span>set_required_signal_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RepProcessor::set_required_signal_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMedDictionarySections.html">MedDictionarySections</a> &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill req_signal_ids : parent function just fills from req_signals. </p>

<p>Reimplemented in <a class="el" href="classRepClearSignalByDiag.html#ab3faf87c1de3a8bfb9a87e321fcdecfa">RepClearSignalByDiag</a>, <a class="el" href="classRepFilterByChannel.html#a45e6ee63da4ed581db8d4389dd748569">RepFilterByChannel</a>, <a class="el" href="classRepMultiProcessor.html#a88edb73b7b27de23e70d67001aa3255d">RepMultiProcessor</a>, <a class="el" href="classRepCombineSignals.html#af043514c4db53ccc4327ea9693aed3ed">RepCombineSignals</a>, <a class="el" href="classRepSplitSignal.html#ac6f41a0751e8724bf5b0b6da0138b168">RepSplitSignal</a>, <a class="el" href="classRepSignalRate.html#a4c68d03e663d71e924108d545e80ff32">RepSignalRate</a>, <a class="el" href="classRepAggregateSignal.html#a35ece27f9ae9a316cc2848c4f2fa1bbf">RepAggregateSignal</a>, and <a class="el" href="classRepCreateBitSignal.html#a890c8d331cf611829af3065a8bee1a57">RepCreateBitSignal</a>.</p>

</div>
</div>
<a id="a54096b50830f1163e2a115640af04fd5" name="a54096b50830f1163e2a115640af04fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54096b50830f1163e2a115640af04fd5">&#9670;&#160;</a></span>set_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RepProcessor::set_signal </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>_signalName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set signal-name : Should be implemented for inheriting classes that have signalName </p>

<p>Reimplemented in <a class="el" href="classRepCategoryDescenders.html#acb3e38f1a8e0d0440475114623000cae">RepCategoryDescenders</a>, <a class="el" href="classRepBasicOutlierCleaner.html#af0678afda41ea7239fedb9c6d3d83970">RepBasicOutlierCleaner</a>, <a class="el" href="classRepNbrsOutlierCleaner.html#a6066210eed490909d50f60084eec79fb">RepNbrsOutlierCleaner</a>, <a class="el" href="classRepSimValHandler.html#acadba68a6d342a406a54a80e5f05aeca">RepSimValHandler</a>, and <a class="el" href="classRepReoderChannels.html#a8f7b156d02673775f3cbf441000c8456">RepReoderChannels</a>.</p>

</div>
</div>
<a id="a7c8fb090f4e52c3fe03e57c4029dd984" name="a7c8fb090f4e52c3fe03e57c4029dd984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8fb090f4e52c3fe03e57c4029dd984">&#9670;&#160;</a></span>set_signal_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RepProcessor::set_signal_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMedSignals.html">MedSignals</a> &amp;&#160;</td>
          <td class="paramname"><em>sigs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set signal-ids : Should be implemented for inheriting classes that have signalId </p>

<p>Reimplemented in <a class="el" href="classRepCategoryDescenders.html#a01b0f47ae877ea8a9c0e7cce38045024">RepCategoryDescenders</a>, <a class="el" href="classRepMultiProcessor.html#ae3f0b00b50d69916dea6fedcbbb6d54e">RepMultiProcessor</a>, <a class="el" href="classRepBasicOutlierCleaner.html#aa36de6151a6a5c89247c79f3c055a70f">RepBasicOutlierCleaner</a>, <a class="el" href="classRepConfiguredOutlierCleaner.html#a1cddc9cff1ee078e6ab26a96efcba03b">RepConfiguredOutlierCleaner</a>, <a class="el" href="classRepRuleBasedOutlierCleaner.html#a1adf9371a392b647d29d99880c309d1f">RepRuleBasedOutlierCleaner</a>, <a class="el" href="classRepNbrsOutlierCleaner.html#ae3d94fb4cd3750d0a7fcac54805a7f41">RepNbrsOutlierCleaner</a>, <a class="el" href="classRepSimValHandler.html#af911579b8c072b7c4fff4d7d4a735457">RepSimValHandler</a>, <a class="el" href="classRepPanelCompleter.html#a37ee2bedbe411690a5207211675be29f">RepPanelCompleter</a>, <a class="el" href="classRepCheckReq.html#a50d182991592e4647c353298ffae27b9">RepCheckReq</a>, <a class="el" href="classRepHistoryLimit.html#ae46e3b1baa661fabaad8e10ae866fc98">RepHistoryLimit</a>, <a class="el" href="classRepNumericNoiser.html#a9d59e2afdaca1c82452d89fb24eee4b8">RepNumericNoiser</a>, and <a class="el" href="classRepReoderChannels.html#ae8e142c64cea558339e3039881a1875a">RepReoderChannels</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="af73d8439f1d028d16767a50f2f2338c2" name="af73d8439f1d028d16767a50f2f2338c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73d8439f1d028d16767a50f2f2338c2">&#9670;&#160;</a></span>virtual_signals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;string, int&gt; &gt; RepProcessor::virtual_signals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>virtual signals are created only in rep processors but can be used by any rep processor that comes after or any feture generator as a regular signal. </p>
<p>a virtual signal can be defined as one only once - in the rep processor that actually creates it. The other rep processors and feature generators using it are simply blind to the fact that it is virtual and use it by name as a regular signal. list of all virtual signals CREATED by this rep processor </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Internal/MedProcessTools/MedProcessTools/<a class="el" href="RepProcess_8h_source.html">RepProcess.h</a></li>
<li>Internal/MedProcessTools/MedProcessTools/<b>RepProcess.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 14 2025 17:54:32 for Medial Code Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
